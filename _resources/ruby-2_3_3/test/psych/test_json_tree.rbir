s(:begin,
  s(:send, nil, :require_relative,
    s(:str, "helper")),
  s(:module,
    s(:const, nil, :Psych),
    s(:class,
      s(:const, nil, :TestJSONTree),
      s(:const, nil, :TestCase),
      s(:begin,
        s(:def, :test_string,
          s(:args),
          s(:send, nil, :assert_match,
            s(:regexp,
              s(:str, "\"foo\""),
              s(:regopt)),
            s(:send,
              s(:const, nil, :Psych), :to_json,
              s(:str, "foo")))),
        s(:def, :test_symbol,
          s(:args),
          s(:send, nil, :assert_match,
            s(:regexp,
              s(:str, "\"foo\""),
              s(:regopt)),
            s(:send,
              s(:const, nil, :Psych), :to_json,
              s(:sym, :foo)))),
        s(:def, :test_nil,
          s(:args),
          s(:send, nil, :assert_match,
            s(:regexp,
              s(:str, "^null"),
              s(:regopt)),
            s(:send,
              s(:const, nil, :Psych), :to_json,
              s(:nil)))),
        s(:def, :test_int,
          s(:args),
          s(:send, nil, :assert_match,
            s(:regexp,
              s(:str, "^10"),
              s(:regopt)),
            s(:send,
              s(:const, nil, :Psych), :to_json,
              s(:int, 10)))),
        s(:def, :test_float,
          s(:args),
          s(:send, nil, :assert_match,
            s(:regexp,
              s(:str, "^1.2"),
              s(:regopt)),
            s(:send,
              s(:const, nil, :Psych), :to_json,
              s(:float, 1.2)))),
        s(:def, :test_hash,
          s(:args),
          s(:begin,
            s(:lvasgn, :hash,
              s(:hash,
                s(:pair,
                  s(:str, "one"),
                  s(:str, "two")))),
            s(:lvasgn, :json,
              s(:send,
                s(:const, nil, :Psych), :to_json,
                s(:lvar, :hash))),
            s(:send, nil, :assert_match,
              s(:regexp,
                s(:str, "}$"),
                s(:regopt)),
              s(:lvar, :json)),
            s(:send, nil, :assert_match,
              s(:regexp,
                s(:str, "^\\{"),
                s(:regopt)),
              s(:lvar, :json)),
            s(:send, nil, :assert_match,
              s(:regexp,
                s(:str, "['\"]one['\"]"),
                s(:regopt)),
              s(:lvar, :json)),
            s(:send, nil, :assert_match,
              s(:regexp,
                s(:str, "['\"]two['\"]"),
                s(:regopt)),
              s(:lvar, :json)))),
        s(:class,
          s(:const, nil, :Bar), nil,
          s(:def, :encode_with,
            s(:args,
              s(:arg, :coder)),
            s(:send,
              s(:lvar, :coder), :represent_seq,
              s(:str, "omg"),
              s(:array,
                s(:str, "a"),
                s(:str, "b"),
                s(:str, "c"))))),
        s(:def, :test_json_list_dump_exclude_tag,
          s(:args),
          s(:begin,
            s(:lvasgn, :json,
              s(:send,
                s(:const, nil, :Psych), :to_json,
                s(:send,
                  s(:const, nil, :Bar), :new))),
            s(:send, nil, :refute_match,
              s(:str, "omg"),
              s(:lvar, :json)))),
        s(:def, :test_list_to_json,
          s(:args),
          s(:begin,
            s(:lvasgn, :list,
              s(:array,
                s(:str, "one"),
                s(:str, "two"))),
            s(:lvasgn, :json,
              s(:send,
                s(:const, nil, :Psych), :to_json,
                s(:lvar, :list))),
            s(:send, nil, :assert_match,
              s(:regexp,
                s(:str, "\\]$"),
                s(:regopt)),
              s(:lvar, :json)),
            s(:send, nil, :assert_match,
              s(:regexp,
                s(:str, "^\\["),
                s(:regopt)),
              s(:lvar, :json)),
            s(:send, nil, :assert_match,
              s(:regexp,
                s(:str, "\"one\""),
                s(:regopt)),
              s(:lvar, :json)),
            s(:send, nil, :assert_match,
              s(:regexp,
                s(:str, "\"two\""),
                s(:regopt)),
              s(:lvar, :json)))),
        s(:def, :test_time,
          s(:args),
          s(:begin,
            s(:lvasgn, :time,
              s(:send,
                s(:const, nil, :Time), :utc,
                s(:int, 2010),
                s(:int, 10),
                s(:int, 10))),
            s(:send, nil, :assert_equal,
              s(:str, "{\"a\": \"2010-10-10 00:00:00.000000000 Z\"}\n"),
              s(:send,
                s(:const, nil, :Psych), :to_json,
                s(:hash,
                  s(:pair,
                    s(:str, "a"),
                    s(:lvar, :time))))))),
        s(:def, :test_datetime,
          s(:args),
          s(:begin,
            s(:lvasgn, :time,
              s(:send,
                s(:send,
                  s(:const, nil, :Time), :new,
                  s(:int, 2010),
                  s(:int, 10),
                  s(:int, 10)), :to_datetime)),
            s(:send, nil, :assert_equal,
              s(:dstr,
                s(:str, "{\"a\": \""),
                s(:begin,
                  s(:send,
                    s(:lvar, :time), :strftime,
                    s(:str, "%Y-%m-%d %H:%M:%S.%9N %:z"))),
                s(:str, "\"}\n")),
              s(:send,
                s(:const, nil, :Psych), :to_json,
                s(:hash,
                  s(:pair,
                    s(:str, "a"),
                    s(:lvar, :time)))))))))))
