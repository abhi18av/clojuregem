s(:begin,
  s(:send, nil, :require,
    s(:str, "rdoc/test_case")),
  s(:class,
    s(:const, nil, :TestRDocParserRuby),
    s(:const,
      s(:const, nil, :RDoc), :TestCase),
    s(:begin,
      s(:def, :setup,
        s(:args),
        s(:begin,
          s(:zsuper),
          s(:ivasgn, :@tempfile,
            s(:send,
              s(:const, nil, :Tempfile), :new,
              s(:send,
                s(:send,
                  s(:self), :class), :name))),
          s(:ivasgn, :@filename,
            s(:send,
              s(:ivar, :@tempfile), :path)),
          s(:ivasgn, :@tempfile2,
            s(:send,
              s(:const, nil, :Tempfile), :new,
              s(:send,
                s(:send,
                  s(:self), :class), :name))),
          s(:ivasgn, :@filename2,
            s(:send,
              s(:ivar, :@tempfile2), :path)),
          s(:ivasgn, :@top_level,
            s(:send,
              s(:ivar, :@store), :add_file,
              s(:ivar, :@filename))),
          s(:ivasgn, :@top_level2,
            s(:send,
              s(:ivar, :@store), :add_file,
              s(:ivar, :@filename2))),
          s(:ivasgn, :@options,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Options), :new)),
          s(:send,
            s(:ivar, :@options), :quiet=,
            s(:true)),
          s(:send,
            s(:ivar, :@options), :option_parser=,
            s(:send,
              s(:const, nil, :OptionParser), :new)),
          s(:ivasgn, :@comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, ""),
              s(:ivar, :@top_level))),
          s(:ivasgn, :@stats,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Stats), :new,
              s(:ivar, :@store),
              s(:int, 0))))),
      s(:def, :teardown,
        s(:args),
        s(:begin,
          s(:zsuper),
          s(:send,
            s(:ivar, :@tempfile), :close!),
          s(:send,
            s(:ivar, :@tempfile2), :close!))),
      s(:def, :test_collect_first_comment,
        s(:args),
        s(:begin,
          s(:lvasgn, :p,
            s(:send, nil, :util_parser,
              s(:dstr,
                s(:str, "# first\n"),
                s(:str, "\n"),
                s(:str, "# second\n"),
                s(:str, "class C; end\n")))),
          s(:lvasgn, :comment,
            s(:send,
              s(:lvar, :p), :collect_first_comment)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "# first\n"),
              s(:ivar, :@top_level)),
            s(:lvar, :comment)))),
      s(:def, :test_collect_first_comment_encoding,
        s(:args),
        s(:begin,
          s(:if,
            s(:send,
              s(:const, nil, :Object), :const_defined?,
              s(:sym, :Encoding)), nil,
            s(:send, nil, :skip,
              s(:str, "Encoding not implemented"))),
          s(:send,
            s(:ivar, :@options), :encoding=,
            s(:const,
              s(:const, nil, :Encoding), :CP852)),
          s(:lvasgn, :p,
            s(:send, nil, :util_parser,
              s(:dstr,
                s(:str, "# first\n"),
                s(:str, "\n"),
                s(:str, "# second\n"),
                s(:str, "class C; end\n")))),
          s(:lvasgn, :comment,
            s(:send,
              s(:lvar, :p), :collect_first_comment)),
          s(:send, nil, :assert_equal,
            s(:const,
              s(:const, nil, :Encoding), :CP852),
            s(:send,
              s(:send,
                s(:lvar, :comment), :text), :encoding)))),
      s(:def, :test_collect_first_comment_rd_hash,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:dstr,
                s(:str, "=begin\n"),
                s(:str, "first\n"),
                s(:str, "=end\n"),
                s(:str, "\n"),
                s(:str, "# second\n"),
                s(:str, "class C; end\n")))),
          s(:lvasgn, :comment,
            s(:send,
              s(:lvar, :parser), :collect_first_comment)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "first\n\n"),
              s(:ivar, :@top_level)),
            s(:lvar, :comment)))),
      s(:def, :test_get_class_or_module,
        s(:args),
        s(:begin,
          s(:lvasgn, :ctxt,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Context), :new)),
          s(:send,
            s(:lvar, :ctxt), :store=,
            s(:ivar, :@store)),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :cont),
              s(:lvasgn, :name_t),
              s(:lvasgn, :given_name)),
            s(:send,
              s(:send, nil, :util_parser,
                s(:str, "A")), :get_class_or_module,
              s(:lvar, :ctxt))),
          s(:send, nil, :assert_equal,
            s(:lvar, :ctxt),
            s(:lvar, :cont)),
          s(:send, nil, :assert_equal,
            s(:str, "A"),
            s(:send,
              s(:lvar, :name_t), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "A"),
            s(:lvar, :given_name)),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :cont),
              s(:lvasgn, :name_t),
              s(:lvasgn, :given_name)),
            s(:send,
              s(:send, nil, :util_parser,
                s(:str, "B::C")), :get_class_or_module,
              s(:lvar, :ctxt))),
          s(:lvasgn, :b,
            s(:send,
              s(:ivar, :@store), :find_module_named,
              s(:str, "B"))),
          s(:send, nil, :assert_equal,
            s(:lvar, :b),
            s(:lvar, :cont)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:ivar, :@top_level)),
            s(:send,
              s(:lvar, :b), :in_files)),
          s(:send, nil, :assert_equal,
            s(:str, "C"),
            s(:send,
              s(:lvar, :name_t), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "B::C"),
            s(:lvar, :given_name)),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :cont),
              s(:lvasgn, :name_t),
              s(:lvasgn, :given_name)),
            s(:send,
              s(:send, nil, :util_parser,
                s(:str, "D:: E")), :get_class_or_module,
              s(:lvar, :ctxt))),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:ivar, :@store), :find_module_named,
              s(:str, "D")),
            s(:lvar, :cont)),
          s(:send, nil, :assert_equal,
            s(:str, "E"),
            s(:send,
              s(:lvar, :name_t), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "D::E"),
            s(:lvar, :given_name)),
          s(:block,
            s(:send, nil, :assert_raises,
              s(:const, nil, :NoMethodError)),
            s(:args),
            s(:send,
              s(:send, nil, :util_parser,
                s(:str, "A::\nB")), :get_class_or_module,
              s(:lvar, :ctxt))))),
      s(:def, :test_get_class_or_module_document_children,
        s(:args),
        s(:begin,
          s(:lvasgn, :ctxt,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "A"))),
          s(:send,
            s(:lvar, :ctxt), :stop_doc),
          s(:send,
            s(:send, nil, :util_parser,
              s(:str, "B::C")), :get_class_or_module,
            s(:lvar, :ctxt)),
          s(:lvasgn, :b,
            s(:send,
              s(:ivar, :@store), :find_module_named,
              s(:str, "A::B"))),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :b), :ignored?)),
          s(:lvasgn, :d,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "A::D"))),
          s(:send,
            s(:send, nil, :util_parser,
              s(:str, "D::E")), :get_class_or_module,
            s(:lvar, :ctxt)),
          s(:send, nil, :refute,
            s(:send,
              s(:lvar, :d), :ignored?)))),
      s(:def, :test_get_class_or_module_ignore_constants,
        s(:args),
        s(:begin,
          s(:lvasgn, :ctxt,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Context), :new)),
          s(:send,
            s(:lvar, :ctxt), :store=,
            s(:ivar, :@store)),
          s(:send,
            s(:send, nil, :util_parser,
              s(:str, "A")), :get_class_or_module,
            s(:lvar, :ctxt),
            s(:true)),
          s(:send,
            s(:send, nil, :util_parser,
              s(:str, "A::B")), :get_class_or_module,
            s(:lvar, :ctxt),
            s(:true)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :ctxt), :constants)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:send,
                s(:ivar, :@store), :modules_hash), :keys)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:send,
                s(:ivar, :@store), :classes_hash), :keys)))),
      s(:def, :test_get_class_specification,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:str, "A"),
            s(:send,
              s(:send, nil, :util_parser,
                s(:str, "A")), :get_class_specification)),
          s(:send, nil, :assert_equal,
            s(:str, "A::B"),
            s(:send,
              s(:send, nil, :util_parser,
                s(:str, "A::B")), :get_class_specification)),
          s(:send, nil, :assert_equal,
            s(:str, "::A"),
            s(:send,
              s(:send, nil, :util_parser,
                s(:str, "::A")), :get_class_specification)),
          s(:send, nil, :assert_equal,
            s(:str, "self"),
            s(:send,
              s(:send, nil, :util_parser,
                s(:str, "self")), :get_class_specification)),
          s(:send, nil, :assert_equal,
            s(:str, ""),
            s(:send,
              s(:send, nil, :util_parser,
                s(:str, "")), :get_class_specification)),
          s(:send, nil, :assert_equal,
            s(:str, ""),
            s(:send,
              s(:send, nil, :util_parser,
                s(:str, "$g")), :get_class_specification)))),
      s(:def, :test_get_symbol_or_name,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "* & | + 5 / 4")),
          s(:send, nil, :assert_equal,
            s(:str, "*"),
            s(:send,
              s(:ivar, :@parser), :get_symbol_or_name)),
          s(:send,
            s(:ivar, :@parser), :skip_tkspace),
          s(:send, nil, :assert_equal,
            s(:str, "&"),
            s(:send,
              s(:ivar, :@parser), :get_symbol_or_name)),
          s(:send,
            s(:ivar, :@parser), :skip_tkspace),
          s(:send, nil, :assert_equal,
            s(:str, "|"),
            s(:send,
              s(:ivar, :@parser), :get_symbol_or_name)),
          s(:send,
            s(:ivar, :@parser), :skip_tkspace),
          s(:send, nil, :assert_equal,
            s(:str, "+"),
            s(:send,
              s(:ivar, :@parser), :get_symbol_or_name)),
          s(:send,
            s(:ivar, :@parser), :skip_tkspace),
          s(:send,
            s(:ivar, :@parser), :get_tk),
          s(:send,
            s(:ivar, :@parser), :skip_tkspace),
          s(:send, nil, :assert_equal,
            s(:str, "/"),
            s(:send,
              s(:ivar, :@parser), :get_symbol_or_name)))),
      s(:def, :test_suppress_parents,
        s(:args),
        s(:begin,
          s(:lvasgn, :a,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "A"))),
          s(:lvasgn, :b,
            s(:send,
              s(:lvar, :a), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "B"))),
          s(:lvasgn, :c,
            s(:send,
              s(:lvar, :b), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "C"))),
          s(:send, nil, :util_parser,
            s(:str, "")),
          s(:send,
            s(:ivar, :@parser), :suppress_parents,
            s(:lvar, :c),
            s(:lvar, :a)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :c), :suppressed?)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :b), :suppressed?)),
          s(:send, nil, :refute,
            s(:send,
              s(:lvar, :a), :suppressed?)))),
      s(:def, :test_suppress_parents_documented,
        s(:args),
        s(:begin,
          s(:lvasgn, :a,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "A"))),
          s(:lvasgn, :b,
            s(:send,
              s(:lvar, :a), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "B"))),
          s(:send,
            s(:lvar, :b), :add_comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "hello")),
            s(:ivar, :@top_level)),
          s(:lvasgn, :c,
            s(:send,
              s(:lvar, :b), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "C"))),
          s(:send, nil, :util_parser,
            s(:str, "")),
          s(:send,
            s(:ivar, :@parser), :suppress_parents,
            s(:lvar, :c),
            s(:lvar, :a)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :c), :suppressed?)),
          s(:send, nil, :refute,
            s(:send,
              s(:lvar, :b), :suppressed?)),
          s(:send, nil, :refute,
            s(:send,
              s(:lvar, :a), :suppressed?)))),
      s(:def, :test_look_for_directives_in_attr,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "")),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "# :attr: my_attr\n"),
              s(:ivar, :@top_level))),
          s(:send,
            s(:ivar, :@parser), :look_for_directives_in,
            s(:ivar, :@top_level),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:str, "# :attr: my_attr\n"),
            s(:send,
              s(:lvar, :comment), :text)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "# :attr_reader: my_method\n"),
              s(:ivar, :@top_level))),
          s(:send,
            s(:ivar, :@parser), :look_for_directives_in,
            s(:ivar, :@top_level),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:str, "# :attr_reader: my_method\n"),
            s(:send,
              s(:lvar, :comment), :text)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "# :attr_writer: my_method\n"),
              s(:ivar, :@top_level))),
          s(:send,
            s(:ivar, :@parser), :look_for_directives_in,
            s(:ivar, :@top_level),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:str, "# :attr_writer: my_method\n"),
            s(:send,
              s(:lvar, :comment), :text)))),
      s(:def, :test_look_for_directives_in_commented,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "")),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "# how to make a section:\n"),
                s(:str, "# # :section: new section\n")),
              s(:ivar, :@top_level))),
          s(:send,
            s(:ivar, :@parser), :look_for_directives_in,
            s(:ivar, :@top_level),
            s(:lvar, :comment)),
          s(:lvasgn, :section,
            s(:send,
              s(:ivar, :@top_level), :current_section)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :section), :title)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :section), :comment)),
          s(:send, nil, :assert_equal,
            s(:str, "# how to make a section:\n# # :section: new section\n"),
            s(:send,
              s(:lvar, :comment), :text)))),
      s(:def, :test_look_for_directives_in_method,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "")),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "# :method: my_method\n"),
              s(:ivar, :@top_level))),
          s(:send,
            s(:ivar, :@parser), :look_for_directives_in,
            s(:ivar, :@top_level),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:str, "# :method: my_method\n"),
            s(:send,
              s(:lvar, :comment), :text)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "# :singleton-method: my_method\n"),
              s(:ivar, :@top_level))),
          s(:send,
            s(:ivar, :@parser), :look_for_directives_in,
            s(:ivar, :@top_level),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:str, "# :singleton-method: my_method\n"),
            s(:send,
              s(:lvar, :comment), :text)))),
      s(:def, :test_look_for_directives_in_section,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "")),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "# :section: new section\n"),
                s(:str, "# woo stuff\n")),
              s(:ivar, :@top_level))),
          s(:send,
            s(:ivar, :@parser), :look_for_directives_in,
            s(:ivar, :@top_level),
            s(:lvar, :comment)),
          s(:lvasgn, :section,
            s(:send,
              s(:ivar, :@top_level), :current_section)),
          s(:send, nil, :assert_equal,
            s(:str, "new section"),
            s(:send,
              s(:lvar, :section), :title)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:send, nil, :comment,
                s(:str, "# woo stuff\n"),
                s(:ivar, :@top_level))),
            s(:send,
              s(:lvar, :section), :comments)),
          s(:send, nil, :assert_empty,
            s(:lvar, :comment)))),
      s(:def, :test_look_for_directives_in_unhandled,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "")),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "# :unhandled: blah\n"),
              s(:ivar, :@top_level))),
          s(:send,
            s(:ivar, :@parser), :look_for_directives_in,
            s(:ivar, :@top_level),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:str, "blah"),
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :metadata), :[],
              s(:str, "unhandled"))))),
      s(:def, :test_parse_alias,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "alias :next= :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:lvasgn, :alas,
            s(:send,
              s(:ivar, :@parser), :parse_alias,
              s(:lvar, :klass),
              s(:const,
                s(:const,
                  s(:const,
                    s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
              s(:lvar, :tk),
              s(:str, "comment"))),
          s(:send, nil, :assert_equal,
            s(:str, "bar"),
            s(:send,
              s(:lvar, :alas), :old_name)),
          s(:send, nil, :assert_equal,
            s(:str, "next="),
            s(:send,
              s(:lvar, :alas), :new_name)),
          s(:send, nil, :assert_equal,
            s(:lvar, :klass),
            s(:send,
              s(:lvar, :alas), :parent)),
          s(:send, nil, :assert_equal,
            s(:str, "comment"),
            s(:send,
              s(:lvar, :alas), :comment)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :alas), :file)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:lvar, :alas), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :alas), :line)))),
      s(:def, :test_parse_alias_singleton,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "alias :next= :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:lvasgn, :alas,
            s(:send,
              s(:ivar, :@parser), :parse_alias,
              s(:lvar, :klass),
              s(:const,
                s(:const,
                  s(:const,
                    s(:const, nil, :RDoc), :Parser), :Ruby), :SINGLE),
              s(:lvar, :tk),
              s(:str, "comment"))),
          s(:send, nil, :assert_equal,
            s(:str, "bar"),
            s(:send,
              s(:lvar, :alas), :old_name)),
          s(:send, nil, :assert_equal,
            s(:str, "next="),
            s(:send,
              s(:lvar, :alas), :new_name)),
          s(:send, nil, :assert_equal,
            s(:lvar, :klass),
            s(:send,
              s(:lvar, :alas), :parent)),
          s(:send, nil, :assert_equal,
            s(:str, "comment"),
            s(:send,
              s(:lvar, :alas), :comment)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :alas), :file)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :alas), :singleton)))),
      s(:def, :test_parse_alias_stopdoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send,
            s(:lvar, :klass), :stop_doc),
          s(:send, nil, :util_parser,
            s(:str, "alias :next= :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_alias,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:str, "comment")),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :aliases)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :unmatched_alias_lists)))),
      s(:def, :test_parse_alias_meta,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "alias m.chop m")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:lvasgn, :alas,
            s(:send,
              s(:ivar, :@parser), :parse_alias,
              s(:lvar, :klass),
              s(:const,
                s(:const,
                  s(:const,
                    s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
              s(:lvar, :tk),
              s(:str, "comment"))),
          s(:send, nil, :assert_nil,
            s(:lvar, :alas)))),
      s(:def, :test_parse_attr,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my attr\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "attr :foo, :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_attr,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :length)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "my attr"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:lvar, :foo), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :foo), :line)))),
      s(:def, :test_parse_attr_stopdoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send,
            s(:lvar, :klass), :stop_doc),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my attr\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "attr :foo, :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_attr,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :attributes)))),
      s(:def, :test_parse_attr_accessor,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my attr\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "attr_accessor :foo, :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_attr_accessor,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :length)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "RW"),
            s(:send,
              s(:lvar, :foo), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "my attr"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:lvar, :foo), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :foo), :line)),
          s(:lvasgn, :bar,
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :last)),
          s(:send, nil, :assert_equal,
            s(:str, "bar"),
            s(:send,
              s(:lvar, :bar), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "RW"),
            s(:send,
              s(:lvar, :bar), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "my attr"),
            s(:send,
              s(:send,
                s(:lvar, :bar), :comment), :text)))),
      s(:def, :test_parse_attr_accessor_nodoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my attr\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "attr_accessor :foo, :bar # :nodoc:")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_attr_accessor,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :length)))),
      s(:def, :test_parse_attr_accessor_nodoc_track,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my attr\n"),
              s(:ivar, :@top_level))),
          s(:send,
            s(:ivar, :@options), :visibility=,
            s(:sym, :nodoc)),
          s(:send, nil, :util_parser,
            s(:str, "attr_accessor :foo, :bar # :nodoc:")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_attr_accessor,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :refute_empty,
            s(:send,
              s(:lvar, :klass), :attributes)))),
      s(:def, :test_parse_attr_accessor_stopdoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send,
            s(:lvar, :klass), :stop_doc),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my attr\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "attr_accessor :foo, :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_attr_accessor,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :attributes)))),
      s(:def, :test_parse_attr_accessor_writer,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my attr\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "attr_writer :foo, :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_attr_accessor,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :length)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "W"),
            s(:send,
              s(:lvar, :foo), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "my attr"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)),
          s(:lvasgn, :bar,
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :last)),
          s(:send, nil, :assert_equal,
            s(:str, "bar"),
            s(:send,
              s(:lvar, :bar), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "W"),
            s(:send,
              s(:lvar, :bar), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "my attr"),
            s(:send,
              s(:send,
                s(:lvar, :bar), :comment), :text)))),
      s(:def, :test_parse_meta_attr,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :attr: \n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method :foo, :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_attr,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :length)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "RW"),
            s(:send,
              s(:lvar, :foo), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_meta_attr_accessor,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :attr_accessor: \n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method :foo, :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_attr,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :length)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "RW"),
            s(:send,
              s(:lvar, :foo), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_meta_attr_named,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :attr: foo\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method :foo, :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_attr,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :length)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "RW"),
            s(:send,
              s(:lvar, :foo), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_meta_attr_reader,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :attr_reader: \n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method :foo, :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_attr,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "R"),
            s(:send,
              s(:lvar, :foo), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_meta_attr_stopdoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send,
            s(:lvar, :klass), :stop_doc),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :attr: \n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method :foo, :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_attr,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :attributes)))),
      s(:def, :test_parse_meta_attr_writer,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :attr_writer: \n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method :foo, :bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_attr,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "W"),
            s(:send,
              s(:lvar, :foo), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_class,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my class\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "class Foo\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "my class"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:ivar, :@top_level)),
            s(:send,
              s(:lvar, :foo), :in_files)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:lvar, :foo), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :foo), :line)))),
      s(:def, :test_parse_class_singleton,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my class\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "class C\n"),
              s(:str, "  class << self\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :c,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "C"),
            s(:send,
              s(:lvar, :c), :full_name)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:lvar, :c), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :c), :line)))),
      s(:def, :test_parse_class_ghost_method,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "class Foo\n"),
              s(:str, "  ##\n"),
              s(:str, "  # :method: blah\n"),
              s(:str, "  # my method\n"),
              s(:str, "end\n"))),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:lvasgn, :blah,
            s(:send,
              s(:send,
                s(:lvar, :foo), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#blah"),
            s(:send,
              s(:lvar, :blah), :full_name)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :blah), :file)))),
      s(:def, :test_parse_class_ghost_method_yields,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "class Foo\n"),
              s(:str, "  ##\n"),
              s(:str, "  # :method:\n"),
              s(:str, "  # :call-seq:\n"),
              s(:str, "  #   yields(name)\n"),
              s(:str, "end\n"))),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:lvasgn, :blah,
            s(:send,
              s(:send,
                s(:lvar, :foo), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#yields"),
            s(:send,
              s(:lvar, :blah), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "yields(name)"),
            s(:send,
              s(:lvar, :blah), :call_seq)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :blah), :file)))),
      s(:def, :test_parse_class_multi_ghost_methods,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "class Foo\n"),
              s(:str, "  ##\n"),
              s(:str, "  # :method: one\n"),
              s(:str, "  #\n"),
              s(:str, "  # my method\n"),
              s(:str, "\n"),
              s(:str, "  ##\n"),
              s(:str, "  # :method: two\n"),
              s(:str, "  #\n"),
              s(:str, "  # my method\n"),
              s(:str, "\n"),
              s(:str, "  [:one, :two].each do |t|\n"),
              s(:str, "    eval(\"def \#{t}; \\\"\#{t}\\\"; end\")\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:send,
                s(:lvar, :foo), :method_list), :length)))),
      s(:def, :test_parse_class_nodoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my class\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "class Foo # :nodoc:\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :foo), :comment)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:ivar, :@top_level)),
            s(:send,
              s(:lvar, :foo), :in_files)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:lvar, :foo), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :foo), :line)))),
      s(:def, :test_parse_class_single_root,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my class\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "class << ::Foo\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@store), :all_modules), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)))),
      s(:def, :test_parse_class_stopdoc,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@top_level), :stop_doc),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my class\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "class Foo\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:send,
                s(:send,
                  s(:ivar, :@top_level), :classes), :first), :comment)))),
      s(:def, :test_parse_multi_ghost_methods,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "class Foo\n"),
              s(:str, "  ##\n"),
              s(:str, "  # :method: one\n"),
              s(:str, "  #\n"),
              s(:str, "  # my method\n"),
              s(:str, "\n"),
              s(:str, "  ##\n"),
              s(:str, "  # :method: two\n"),
              s(:str, "  #\n"),
              s(:str, "  # my method\n"),
              s(:str, "\n"),
              s(:str, "  [:one, :two].each do |t|\n"),
              s(:str, "    eval(\"def \#{t}; \\\"\#{t}\\\"; end\")\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:send,
                s(:lvar, :foo), :method_list), :length)))),
      s(:def, :test_parse_const_fail_w_meta,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "class ConstFailMeta\n"),
              s(:str, "  ##\n"),
              s(:str, "  # :attr: one\n"),
              s(:str, "  #\n"),
              s(:str, "  # an attribute\n"),
              s(:str, "\n"),
              s(:str, "  OtherModule.define_attr(self, :one)\n"),
              s(:str, "end\n"))),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :const_fail_meta,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "ConstFailMeta"),
            s(:send,
              s(:lvar, :const_fail_meta), :full_name)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :const_fail_meta), :attributes), :length)))),
      s(:def, :test_parse_class_nested_superclass,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:ivar, :@top_level), :add_module,
              s(:const,
                s(:const, nil, :RDoc), :NormalModule),
              s(:str, "Foo"))),
          s(:send, nil, :util_parser,
            s(:str, "class Bar < Super\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:lvar, :foo),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :bar,
            s(:send,
              s(:send,
                s(:lvar, :foo), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Super"),
            s(:send,
              s(:lvar, :bar), :superclass)))),
      s(:def, :test_parse_module,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my module\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "module Foo\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_module,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :modules), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "my module"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)))),
      s(:def, :test_parse_module_nodoc,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@top_level), :stop_doc),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my module\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "module Foo # :nodoc:\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_module,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :modules), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :foo), :comment)))),
      s(:def, :test_parse_module_stopdoc,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@top_level), :stop_doc),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my module\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "module Foo\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_module,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :modules), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :foo), :comment)))),
      s(:def, :test_parse_class_colon3,
        s(:args),
        s(:begin,
          s(:lvasgn, :code,
            s(:dstr,
              s(:str, "class A\n"),
              s(:str, "  class ::B\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :code)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:false),
            s(:send,
              s(:ivar, :@parser), :get_tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "A"),
              s(:str, "B")),
            s(:send,
              s(:block,
                s(:send,
                  s(:send,
                    s(:ivar, :@store), :all_classes), :map),
                s(:args,
                  s(:arg, :c)),
                s(:send,
                  s(:lvar, :c), :full_name)), :sort)))),
      s(:def, :test_parse_class_colon3_self_reference,
        s(:args),
        s(:begin,
          s(:lvasgn, :code,
            s(:dstr,
              s(:str, "class A::B\n"),
              s(:str, "  class ::A\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :code)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:false),
            s(:send,
              s(:ivar, :@parser), :get_tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "A"),
              s(:str, "A::B")),
            s(:send,
              s(:block,
                s(:send,
                  s(:send,
                    s(:ivar, :@store), :all_classes), :map),
                s(:args,
                  s(:arg, :c)),
                s(:send,
                  s(:lvar, :c), :full_name)), :sort)))),
      s(:def, :test_parse_class_single,
        s(:args),
        s(:begin,
          s(:lvasgn, :code,
            s(:dstr,
              s(:str, "class A\n"),
              s(:str, "  class << B\n"),
              s(:str, "  end\n"),
              s(:str, "  class << d = Object.new\n"),
              s(:str, "    def foo; end\n"),
              s(:str, "    alias bar foo\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :code)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:false),
            s(:send,
              s(:ivar, :@parser), :get_tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "A")),
            s(:block,
              s(:send,
                s(:send,
                  s(:ivar, :@store), :all_classes), :map),
              s(:args,
                s(:arg, :c)),
              s(:send,
                s(:lvar, :c), :full_name))),
          s(:lvasgn, :modules,
            s(:block,
              s(:send,
                s(:send,
                  s(:ivar, :@store), :all_modules), :sort_by),
              s(:args,
                s(:arg, :c)),
              s(:send,
                s(:lvar, :c), :full_name))),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "A::B"),
              s(:str, "A::d")),
            s(:block,
              s(:send,
                s(:lvar, :modules), :map),
              s(:args,
                s(:arg, :c)),
              s(:send,
                s(:lvar, :c), :full_name))),
          s(:lvasgn, :b,
            s(:send,
              s(:lvar, :modules), :first)),
          s(:send, nil, :assert_equal,
            s(:int, 10),
            s(:send,
              s(:lvar, :b), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:lvar, :b), :line)),
          s(:lvasgn, :a,
            s(:send,
              s(:send,
                s(:ivar, :@store), :classes_hash), :[],
              s(:str, "A"))),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :a), :method_list)),
          s(:lvasgn, :d,
            s(:send,
              s(:send,
                s(:ivar, :@store), :modules_hash), :[],
              s(:str, "A::d"))),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :d), :remove_from_documentation?)))),
      s(:def, :test_parse_class_single_gvar,
        s(:args),
        s(:begin,
          s(:lvasgn, :code,
            s(:dstr,
              s(:str, "class << $g\n"),
              s(:str, "  def m\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :code)),
          s(:send,
            s(:ivar, :@parser), :parse_class,
            s(:ivar, :@top_level),
            s(:false),
            s(:send,
              s(:ivar, :@parser), :get_tk),
            s(:str, "")),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:ivar, :@store), :all_classes)),
          s(:lvasgn, :mod,
            s(:send,
              s(:send,
                s(:ivar, :@store), :all_modules), :first)),
          s(:send, nil, :refute,
            s(:send,
              s(:lvar, :mod), :document_self)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :mod), :method_list)))),
      s(:def, :test_parse_class_object,
        s(:args),
        s(:begin,
          s(:lvasgn, :code,
            s(:dstr,
              s(:str, "module A\n"),
              s(:str, "  class B\n"),
              s(:str, "  end\n"),
              s(:str, "  class Object\n"),
              s(:str, "  end\n"),
              s(:str, "  class C < Object\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :code)),
          s(:send,
            s(:ivar, :@parser), :parse_module,
            s(:ivar, :@top_level),
            s(:false),
            s(:send,
              s(:ivar, :@parser), :get_tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "A")),
            s(:block,
              s(:send,
                s(:send,
                  s(:ivar, :@store), :all_modules), :map),
              s(:args,
                s(:arg, :c)),
              s(:send,
                s(:lvar, :c), :full_name))),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "A::B"),
              s(:str, "A::C"),
              s(:str, "A::Object")),
            s(:send,
              s(:block,
                s(:send,
                  s(:send,
                    s(:ivar, :@store), :all_classes), :map),
                s(:args,
                  s(:arg, :c)),
                s(:send,
                  s(:lvar, :c), :full_name)), :sort)),
          s(:send, nil, :assert_equal,
            s(:str, "Object"),
            s(:send,
              s(:send,
                s(:send,
                  s(:ivar, :@store), :classes_hash), :[],
                s(:str, "A::B")), :superclass)),
          s(:send, nil, :assert_equal,
            s(:str, "Object"),
            s(:send,
              s(:send,
                s(:send,
                  s(:ivar, :@store), :classes_hash), :[],
                s(:str, "A::Object")), :superclass)),
          s(:send, nil, :assert_equal,
            s(:str, "A::Object"),
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@store), :classes_hash), :[],
                  s(:str, "A::C")), :superclass), :full_name)))),
      s(:def, :test_parse_class_mistaken_for_module,
        s(:args),
        s(:begin,
          s(:lvasgn, :code,
            s(:dstr,
              s(:str, "class Foo::Bar\n"),
              s(:str, "end\n"),
              s(:str, "\n"),
              s(:str, "module Foo::Baz\n"),
              s(:str, "end\n"),
              s(:str, "\n"),
              s(:str, "class Foo\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :code)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "Foo::Baz")),
            s(:send,
              s(:send,
                s(:ivar, :@store), :modules_hash), :keys)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:ivar, :@top_level), :modules)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:lvasgn, :bar,
            s(:send,
              s(:send,
                s(:lvar, :foo), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo::Bar"),
            s(:send,
              s(:lvar, :bar), :full_name)),
          s(:lvasgn, :baz,
            s(:send,
              s(:send,
                s(:lvar, :foo), :modules), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo::Baz"),
            s(:send,
              s(:lvar, :baz), :full_name)))),
      s(:def, :test_parse_class_definition_encountered_after_class_reference,
        s(:args),
        s(:begin,
          s(:lvasgn, :code,
            s(:dstr,
              s(:str, "def Foo.bar\n"),
              s(:str, "end\n"),
              s(:str, "\n"),
              s(:str, "class Foo < IO\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :code)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:ivar, :@store), :modules_hash)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:ivar, :@store), :all_modules)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "IO"),
            s(:send,
              s(:lvar, :foo), :superclass)),
          s(:lvasgn, :bar,
            s(:send,
              s(:send,
                s(:lvar, :foo), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "bar"),
            s(:send,
              s(:lvar, :bar), :name)))),
      s(:def, :test_parse_module_relative_to_top_level_namespace,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "#\n"),
                s(:str, "# Weirdly named module\n"),
                s(:str, "#\n")),
              s(:ivar, :@top_level))),
          s(:lvasgn, :code,
            s(:dstr,
              s(:begin,
                s(:send,
                  s(:lvar, :comment), :text)),
              s(:str, "\n"),
              s(:str, "module ::Foo\n"),
              s(:str, "  class Helper\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :code)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :modules), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "Weirdly named module"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:lvasgn, :helper,
            s(:send,
              s(:send,
                s(:lvar, :foo), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo::Helper"),
            s(:send,
              s(:lvar, :helper), :full_name)))),
      s(:def, :test_parse_comment_attr,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :attr: foo\n# my attr\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "\n")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_comment,
            s(:lvar, :klass),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "RW"),
            s(:send,
              s(:lvar, :foo), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "my attr"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:lvar, :foo), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :foo), :line)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :viewer)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:lvar, :foo), :document_children)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:lvar, :foo), :document_self)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :done_documenting)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :force_documentation)),
          s(:send, nil, :assert_equal,
            s(:lvar, :klass),
            s(:send,
              s(:lvar, :foo), :parent)),
          s(:send, nil, :assert_equal,
            s(:sym, :public),
            s(:send,
              s(:lvar, :foo), :visibility)),
          s(:send, nil, :assert_equal,
            s(:str, "\n"),
            s(:send,
              s(:lvar, :foo), :text)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:lvar, :klass), :current_section),
            s(:send,
              s(:lvar, :foo), :section)))),
      s(:def, :test_parse_comment_attr_attr_reader,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :attr_reader: foo\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "\n")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_comment,
            s(:lvar, :klass),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :attributes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "R"),
            s(:send,
              s(:lvar, :foo), :rw)))),
      s(:def, :test_parse_comment_attr_stopdoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send,
            s(:lvar, :klass), :stop_doc),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :attr: foo\n# my attr\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "\n")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_comment,
            s(:lvar, :klass),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :attributes)))),
      s(:def, :test_parse_comment_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :method: foo\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "\n")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_comment,
            s(:lvar, :klass),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:lvar, :foo), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :foo), :line)),
          s(:send, nil, :assert_equal,
            s(:array),
            s(:send,
              s(:lvar, :foo), :aliases)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :block_params)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :call_seq)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :is_alias_for)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :viewer)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:lvar, :foo), :document_children)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:lvar, :foo), :document_self)),
          s(:send, nil, :assert_equal,
            s(:str, ""),
            s(:send,
              s(:lvar, :foo), :params)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :done_documenting)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :dont_rename_initialize)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :force_documentation)),
          s(:send, nil, :assert_equal,
            s(:lvar, :klass),
            s(:send,
              s(:lvar, :foo), :parent)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :singleton)),
          s(:send, nil, :assert_equal,
            s(:sym, :public),
            s(:send,
              s(:lvar, :foo), :visibility)),
          s(:send, nil, :assert_equal,
            s(:str, "\n"),
            s(:send,
              s(:lvar, :foo), :text)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:lvar, :klass), :current_section),
            s(:send,
              s(:lvar, :foo), :section)),
          s(:lvasgn, :stream,
            s(:array,
              s(:send, nil, :tk,
                s(:sym, :COMMENT),
                s(:int, 0),
                s(:int, 1),
                s(:int, 1),
                s(:nil),
                s(:dstr,
                  s(:str, "# File "),
                  s(:begin,
                    s(:send,
                      s(:ivar, :@top_level), :relative_name)),
                  s(:str, ", line 1"))),
              s(:const,
                s(:const,
                  s(:const,
                    s(:const, nil, :RDoc), :Parser), :Ruby), :NEWLINE_TOKEN),
              s(:send, nil, :tk,
                s(:sym, :SPACE),
                s(:int, 0),
                s(:int, 1),
                s(:int, 1),
                s(:nil),
                s(:str, "")))),
          s(:send, nil, :assert_equal,
            s(:lvar, :stream),
            s(:send,
              s(:lvar, :foo), :token_stream)))),
      s(:def, :test_parse_comment_method_args,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "\n")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_comment,
            s(:lvar, :klass),
            s(:lvar, :tk),
            s(:send, nil, :comment,
              s(:str, "##\n# :method: foo\n# :args: a, b\n"))),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "a, b"),
            s(:send,
              s(:lvar, :foo), :params)))),
      s(:def, :test_parse_comment_method_stopdoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send,
            s(:lvar, :klass), :stop_doc),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :method: foo\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "\n")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_comment,
            s(:lvar, :klass),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :method_list)))),
      s(:def, :test_parse_constant,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send, nil, :util_parser,
            s(:str, "A = v")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_constant,
            s(:lvar, :klass),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :constants), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "A"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:lvar, :foo), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :foo), :line)))),
      s(:def, :test_parse_constant_attrasgn,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send, nil, :util_parser,
            s(:str, "A[k] = v")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_constant,
            s(:lvar, :klass),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert,
            s(:send,
              s(:send,
                s(:lvar, :klass), :constants), :empty?)))),
      s(:def, :test_parse_constant_alias,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :add_class,
            s(:const,
              s(:const, nil, :RDoc), :NormalClass),
            s(:str, "B")),
          s(:send, nil, :util_parser,
            s(:str, "A = B")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_constant,
            s(:lvar, :klass),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo::A"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :find_module_named,
                s(:str, "A")), :full_name)))),
      s(:def, :test_parse_constant_alias_same_name,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send,
            s(:ivar, :@top_level), :add_class,
            s(:const,
              s(:const, nil, :RDoc), :NormalClass),
            s(:str, "Bar")),
          s(:lvasgn, :bar,
            s(:send,
              s(:lvar, :foo), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Bar"))),
          s(:send, nil, :assert,
            s(:send,
              s(:ivar, :@store), :find_class_or_module,
              s(:str, "::Bar"))),
          s(:send, nil, :util_parser,
            s(:str, "A = ::Bar")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_constant,
            s(:lvar, :foo),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_equal,
            s(:str, "A"),
            s(:send,
              s(:send,
                s(:lvar, :bar), :find_module_named,
                s(:str, "A")), :full_name)))),
      s(:def, :test_parse_constant_in_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send, nil, :util_parser,
            s(:str, "A::B = v")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_constant,
            s(:lvar, :klass),
            s(:lvar, :tk),
            s(:ivar, :@comment),
            s(:true)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :constants)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:send,
                s(:ivar, :@store), :modules_hash), :keys)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "Foo")),
            s(:send,
              s(:send,
                s(:ivar, :@store), :classes_hash), :keys)))),
      s(:def, :test_parse_constant_rescue,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send, nil, :util_parser,
            s(:str, "A => e")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_constant,
            s(:lvar, :klass),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :constants)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :modules)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:send,
                s(:ivar, :@store), :modules_hash), :keys)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "Foo")),
            s(:send,
              s(:send,
                s(:ivar, :@store), :classes_hash), :keys)))),
      s(:def, :test_parse_constant_stopdoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :stop_doc),
          s(:send, nil, :util_parser,
            s(:str, "A = v")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_constant,
            s(:lvar, :klass),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :constants)))),
      s(:def, :test_parse_comment_nested,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:str, "A::B::C = 1\n")),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:lvasgn, :parsed,
            s(:send,
              s(:ivar, :@parser), :parse_constant,
              s(:ivar, :@top_level),
              s(:lvar, :tk),
              s(:str, "comment"))),
          s(:send, nil, :assert,
            s(:lvar, :parsed)),
          s(:lvasgn, :a,
            s(:send,
              s(:ivar, :@top_level), :find_module_named,
              s(:str, "A"))),
          s(:lvasgn, :b,
            s(:send,
              s(:lvar, :a), :find_module_named,
              s(:str, "B"))),
          s(:lvasgn, :c,
            s(:send,
              s(:send,
                s(:lvar, :b), :constants), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "A::B::C"),
            s(:send,
              s(:lvar, :c), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "comment"),
            s(:send,
              s(:lvar, :c), :comment)))),
      s(:def, :test_parse_extend_or_include_extend,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "C"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "# my extend\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "extend I")),
          s(:send,
            s(:ivar, :@parser), :get_tk),
          s(:send,
            s(:ivar, :@parser), :parse_extend_or_include,
            s(:const,
              s(:const, nil, :RDoc), :Extend),
            s(:lvar, :klass),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :klass), :extends), :length)),
          s(:lvasgn, :ext,
            s(:send,
              s(:send,
                s(:lvar, :klass), :extends), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "I"),
            s(:send,
              s(:lvar, :ext), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "my extend"),
            s(:send,
              s(:send,
                s(:lvar, :ext), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :ext), :file)))),
      s(:def, :test_parse_extend_or_include_include,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "C"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "# my include\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "include I")),
          s(:send,
            s(:ivar, :@parser), :get_tk),
          s(:send,
            s(:ivar, :@parser), :parse_extend_or_include,
            s(:const,
              s(:const, nil, :RDoc), :Include),
            s(:lvar, :klass),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :klass), :includes), :length)),
          s(:lvasgn, :incl,
            s(:send,
              s(:send,
                s(:lvar, :klass), :includes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "I"),
            s(:send,
              s(:lvar, :incl), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "my include"),
            s(:send,
              s(:send,
                s(:lvar, :incl), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :incl), :file)))),
      s(:def, :test_parse_meta_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method :foo, :bar\nadd_my_method :baz")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:lvar, :foo), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :foo), :line)),
          s(:send, nil, :assert_equal,
            s(:array),
            s(:send,
              s(:lvar, :foo), :aliases)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :block_params)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :call_seq)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:lvar, :foo), :document_children)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:lvar, :foo), :document_self)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :done_documenting)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :dont_rename_initialize)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :force_documentation)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :is_alias_for)),
          s(:send, nil, :assert_equal,
            s(:str, ""),
            s(:send,
              s(:lvar, :foo), :params)),
          s(:send, nil, :assert_equal,
            s(:lvar, :klass),
            s(:send,
              s(:lvar, :foo), :parent)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :singleton)),
          s(:send, nil, :assert_equal,
            s(:str, "add_my_method :foo"),
            s(:send,
              s(:lvar, :foo), :text)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :viewer)),
          s(:send, nil, :assert_equal,
            s(:sym, :public),
            s(:send,
              s(:lvar, :foo), :visibility)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:lvar, :klass), :current_section),
            s(:send,
              s(:lvar, :foo), :section)),
          s(:lvasgn, :stream,
            s(:array,
              s(:send, nil, :tk,
                s(:sym, :COMMENT),
                s(:int, 0),
                s(:int, 1),
                s(:int, 1),
                s(:nil),
                s(:dstr,
                  s(:str, "# File "),
                  s(:begin,
                    s(:send,
                      s(:ivar, :@top_level), :relative_name)),
                  s(:str, ", line 1"))),
              s(:const,
                s(:const,
                  s(:const,
                    s(:const, nil, :RDoc), :Parser), :Ruby), :NEWLINE_TOKEN),
              s(:send, nil, :tk,
                s(:sym, :SPACE),
                s(:int, 0),
                s(:int, 1),
                s(:int, 1),
                s(:nil),
                s(:str, "")),
              s(:send, nil, :tk,
                s(:sym, :IDENTIFIER),
                s(:int, 0),
                s(:int, 1),
                s(:int, 0),
                s(:str, "add_my_method"),
                s(:str, "add_my_method")),
              s(:send, nil, :tk,
                s(:sym, :SPACE),
                s(:int, 0),
                s(:int, 1),
                s(:int, 13),
                s(:nil),
                s(:str, " ")),
              s(:send, nil, :tk,
                s(:sym, :SYMBOL),
                s(:int, 0),
                s(:int, 1),
                s(:int, 14),
                s(:nil),
                s(:str, ":foo")),
              s(:send, nil, :tk,
                s(:sym, :COMMA),
                s(:int, 0),
                s(:int, 1),
                s(:int, 18),
                s(:nil),
                s(:str, ",")),
              s(:send, nil, :tk,
                s(:sym, :SPACE),
                s(:int, 0),
                s(:int, 1),
                s(:int, 19),
                s(:nil),
                s(:str, " ")),
              s(:send, nil, :tk,
                s(:sym, :SYMBOL),
                s(:int, 0),
                s(:int, 1),
                s(:int, 20),
                s(:nil),
                s(:str, ":bar")),
              s(:send, nil, :tk,
                s(:sym, :NL),
                s(:int, 0),
                s(:int, 1),
                s(:int, 24),
                s(:nil),
                s(:str, "\n")))),
          s(:send, nil, :assert_equal,
            s(:lvar, :stream),
            s(:send,
              s(:lvar, :foo), :token_stream)))),
      s(:def, :test_parse_meta_method_block,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "inline(:my_method) do |*args|\n"),
              s(:str, "  \"this method causes z to disappear\"\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:send, nil, :tk,
              s(:sym, :NL),
              s(:int, 0),
              s(:int, 3),
              s(:int, 3),
              s(:int, 3),
              s(:str, "\n")),
            s(:send,
              s(:ivar, :@parser), :get_tk)))),
      s(:def, :test_parse_meta_method_define_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "define_method :foo do end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_meta_method_name,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :method: woo_hoo!\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method :foo, :bar\nadd_my_method :baz")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "woo_hoo!"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_meta_method_singleton,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :singleton-method:\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method :foo, :bar\nadd_my_method :baz")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:lvar, :foo), :singleton),
            s(:str, "singleton method")),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_meta_method_singleton_name,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# :singleton-method: woo_hoo!\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method :foo, :bar\nadd_my_method :baz")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "woo_hoo!"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:lvar, :foo), :singleton),
            s(:str, "singleton method")),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_meta_method_string_name,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method 'foo'")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_meta_method_stopdoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send,
            s(:lvar, :klass), :stop_doc),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method :foo, :bar\nadd_my_method :baz")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :method_list)))),
      s(:def, :test_parse_meta_method_unknown,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "add_my_method ('foo')")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_meta_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "unknown"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "def foo() :bar end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:lvar, :foo), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :foo), :line)),
          s(:send, nil, :assert_equal,
            s(:array),
            s(:send,
              s(:lvar, :foo), :aliases)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :block_params)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :call_seq)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :is_alias_for)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :foo), :viewer)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:lvar, :foo), :document_children)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:lvar, :foo), :document_self)),
          s(:send, nil, :assert_equal,
            s(:str, "()"),
            s(:send,
              s(:lvar, :foo), :params)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :done_documenting)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :dont_rename_initialize)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :force_documentation)),
          s(:send, nil, :assert_equal,
            s(:lvar, :klass),
            s(:send,
              s(:lvar, :foo), :parent)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :singleton)),
          s(:send, nil, :assert_equal,
            s(:sym, :public),
            s(:send,
              s(:lvar, :foo), :visibility)),
          s(:send, nil, :assert_equal,
            s(:str, "def foo"),
            s(:send,
              s(:lvar, :foo), :text)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:lvar, :klass), :current_section),
            s(:send,
              s(:lvar, :foo), :section)),
          s(:lvasgn, :stream,
            s(:array,
              s(:send, nil, :tk,
                s(:sym, :COMMENT),
                s(:int, 0),
                s(:int, 1),
                s(:int, 1),
                s(:nil),
                s(:dstr,
                  s(:str, "# File "),
                  s(:begin,
                    s(:send,
                      s(:ivar, :@top_level), :relative_name)),
                  s(:str, ", line 1"))),
              s(:const,
                s(:const,
                  s(:const,
                    s(:const, nil, :RDoc), :Parser), :Ruby), :NEWLINE_TOKEN),
              s(:send, nil, :tk,
                s(:sym, :SPACE),
                s(:int, 0),
                s(:int, 1),
                s(:int, 1),
                s(:nil),
                s(:str, "")),
              s(:send, nil, :tk,
                s(:sym, :DEF),
                s(:int, 0),
                s(:int, 1),
                s(:int, 0),
                s(:str, "def"),
                s(:str, "def")),
              s(:send, nil, :tk,
                s(:sym, :SPACE),
                s(:int, 3),
                s(:int, 1),
                s(:int, 3),
                s(:nil),
                s(:str, " ")),
              s(:send, nil, :tk,
                s(:sym, :IDENTIFIER),
                s(:int, 4),
                s(:int, 1),
                s(:int, 4),
                s(:str, "foo"),
                s(:str, "foo")),
              s(:send, nil, :tk,
                s(:sym, :LPAREN),
                s(:int, 7),
                s(:int, 1),
                s(:int, 7),
                s(:nil),
                s(:str, "(")),
              s(:send, nil, :tk,
                s(:sym, :RPAREN),
                s(:int, 8),
                s(:int, 1),
                s(:int, 8),
                s(:nil),
                s(:str, ")")),
              s(:send, nil, :tk,
                s(:sym, :SPACE),
                s(:int, 9),
                s(:int, 1),
                s(:int, 9),
                s(:nil),
                s(:str, " ")),
              s(:send, nil, :tk,
                s(:sym, :COLON),
                s(:int, 10),
                s(:int, 1),
                s(:int, 10),
                s(:nil),
                s(:str, ":")),
              s(:send, nil, :tk,
                s(:sym, :IDENTIFIER),
                s(:int, 11),
                s(:int, 1),
                s(:int, 11),
                s(:str, "bar"),
                s(:str, "bar")),
              s(:send, nil, :tk,
                s(:sym, :SPACE),
                s(:int, 14),
                s(:int, 1),
                s(:int, 14),
                s(:nil),
                s(:str, " ")),
              s(:send, nil, :tk,
                s(:sym, :END),
                s(:int, 15),
                s(:int, 1),
                s(:int, 15),
                s(:str, "end"),
                s(:str, "end")))),
          s(:send, nil, :assert_equal,
            s(:lvar, :stream),
            s(:send,
              s(:lvar, :foo), :token_stream)))),
      s(:def, :test_parse_method_alias,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def m() alias a b; end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert,
            s(:send,
              s(:send,
                s(:lvar, :klass), :aliases), :empty?)))),
      s(:def, :test_parse_method_ampersand,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def self.&\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :ampersand,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "&"),
            s(:send,
              s(:lvar, :ampersand), :name)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :ampersand), :singleton)))),
      s(:def, :test_parse_method_constant,
        s(:args),
        s(:begin,
          s(:lvasgn, :c,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Constant), :new,
              s(:str, "CONST"),
              s(:nil),
              s(:str, ""))),
          s(:lvasgn, :m,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalModule),
              s(:str, "M"))),
          s(:send,
            s(:lvar, :m), :add_constant,
            s(:lvar, :c)),
          s(:send, nil, :util_parser,
            s(:str, "def CONST.m() end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :m),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:send,
                s(:ivar, :@store), :modules_hash), :keys)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "M")),
            s(:send,
              s(:send,
                s(:ivar, :@store), :classes_hash), :keys)))),
      s(:def, :test_parse_method_false,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "def false.foo() :bar end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@store), :find_class_named,
              s(:str, "FalseClass"))),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)))),
      s(:def, :test_parse_method_funky,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def (blah).foo() :bar end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :method_list)))),
      s(:def, :test_parse_method_gvar,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "def $stdout.foo() :bar end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :method_list), :empty?)))),
      s(:def, :test_parse_method_gvar_insane,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "def $stdout.foo() class << $other; end; end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :method_list), :empty?)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:ivar, :@store), :all_classes)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:ivar, :@store), :all_modules), :length)),
          s(:send, nil, :refute,
            s(:send,
              s(:send,
                s(:send,
                  s(:ivar, :@store), :all_modules), :first), :document_self)))),
      s(:def, :test_parse_method_internal_gvar,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def foo() def $blah.bar() end end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :length)))),
      s(:def, :test_parse_method_internal_ivar,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def foo() def @blah.bar() end end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :length)))),
      s(:def, :test_parse_method_internal_lvar,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def foo() def blah.bar() end end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :length)))),
      s(:def, :test_parse_method_nil,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "def nil.foo() :bar end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@store), :find_class_named,
              s(:str, "NilClass"))),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)))),
      s(:def, :test_parse_method_nodoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def foo # :nodoc:\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:send, nil, :comment,
              s(:str, ""))),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :method_list)))),
      s(:def, :test_parse_method_nodoc_track,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send,
            s(:ivar, :@options), :visibility=,
            s(:sym, :nodoc)),
          s(:send, nil, :util_parser,
            s(:str, "def foo # :nodoc:\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:send, nil, :comment,
              s(:str, ""))),
          s(:send, nil, :refute_empty,
            s(:send,
              s(:lvar, :klass), :method_list)))),
      s(:def, :test_parse_method_no_parens,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def foo arg1, arg2 = {}\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "(arg1, arg2 = {})"),
            s(:send,
              s(:lvar, :foo), :params)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_method_parameters_comment,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def foo arg1, arg2 # some useful comment\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "(arg1, arg2)"),
            s(:send,
              s(:lvar, :foo), :params)))),
      s(:def, :test_parse_method_parameters_comment_continue,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def foo arg1, arg2, # some useful comment\narg3\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "(arg1, arg2, arg3)"),
            s(:send,
              s(:lvar, :foo), :params)))),
      s(:def, :test_parse_method_star,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def self.*\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :ampersand,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "*"),
            s(:send,
              s(:lvar, :ampersand), :name)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :ampersand), :singleton)))),
      s(:def, :test_parse_method_stopdoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send,
            s(:lvar, :klass), :stop_doc),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:str, "def foo() :bar end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:lvar, :comment)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :method_list)))),
      s(:def, :test_parse_method_toplevel,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def foo arg1, arg2\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :object,
            s(:send,
              s(:ivar, :@store), :find_class_named,
              s(:str, "Object"))),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :object), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Object#foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :foo), :file)))),
      s(:def, :test_parse_method_toplevel_class,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def Object.foo arg1, arg2\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :object,
            s(:send,
              s(:ivar, :@store), :find_class_named,
              s(:str, "Object"))),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :object), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Object::foo"),
            s(:send,
              s(:lvar, :foo), :full_name)))),
      s(:def, :test_parse_method_true,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "def true.foo() :bar end")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@store), :find_class_named,
              s(:str, "TrueClass"))),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)))),
      s(:def, :test_parse_method_utf8,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:lvasgn, :method,
            s(:str, "def () end")),
          s(:if,
            s(:send,
              s(:const, nil, :Object), :const_defined?,
              s(:sym, :Encoding)),
            s(:send, nil, :assert_equal,
              s(:const,
                s(:const, nil, :Encoding), :UTF_8),
              s(:send,
                s(:lvar, :method), :encoding)), nil),
          s(:send, nil, :util_parser,
            s(:lvar, :method)),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :omega,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "def "),
            s(:send,
              s(:lvar, :omega), :text)))),
      s(:def, :test_parse_method_dummy,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, ".method() end")),
          s(:send,
            s(:ivar, :@parser), :parse_method_dummy,
            s(:ivar, :@top_level)),
          s(:send, nil, :assert_nil,
            s(:send,
              s(:ivar, :@parser), :get_tk)))),
      s(:def, :test_parse_method_or_yield_parameters_hash,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "({})\n")),
          s(:lvasgn, :m,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "m"))),
          s(:lvasgn, :result,
            s(:send,
              s(:ivar, :@parser), :parse_method_or_yield_parameters,
              s(:lvar, :m))),
          s(:send, nil, :assert_equal,
            s(:str, "({})"),
            s(:lvar, :result)))),
      s(:def, :test_parse_statements_class_if,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "module Foo\n"),
              s(:str, "  X = if TRUE then\n"),
              s(:str, "        ''\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "  def blah\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:nil)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :modules), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name),
            s(:str, "module Foo")),
          s(:lvasgn, :methods,
            s(:send,
              s(:lvar, :foo), :method_list)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :methods), :length)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#blah"),
            s(:send,
              s(:send,
                s(:lvar, :methods), :first), :full_name)))),
      s(:def, :test_parse_statements_class_nested,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "##\n# my method\n"),
              s(:ivar, :@top_level))),
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "module Foo\n"),
              s(:begin,
                s(:send,
                  s(:lvar, :comment), :text)),
              s(:str, "class Bar\nend\nend"))),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :modules), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name),
            s(:str, "module Foo")),
          s(:lvasgn, :bar,
            s(:send,
              s(:send,
                s(:lvar, :foo), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo::Bar"),
            s(:send,
              s(:lvar, :bar), :full_name),
            s(:str, "class Foo::Bar")),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :bar), :comment), :text)))),
      s(:def, :test_parse_statements_def_percent_string_pound,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "class C\ndef a\n%r{#}\nend\ndef b() end\nend")),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL)),
          s(:lvasgn, :x,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:send,
                s(:lvar, :x), :method_list), :length)),
          s(:lvasgn, :a,
            s(:send,
              s(:send,
                s(:lvar, :x), :method_list), :first)),
          s(:lvasgn, :expected,
            s(:array,
              s(:send, nil, :tk,
                s(:sym, :COMMENT),
                s(:int, 0),
                s(:int, 2),
                s(:int, 1),
                s(:nil),
                s(:dstr,
                  s(:str, "# File "),
                  s(:begin,
                    s(:ivar, :@filename)),
                  s(:str, ", line 2"))),
              s(:send, nil, :tk,
                s(:sym, :NL),
                s(:int, 0),
                s(:int, 0),
                s(:int, 0),
                s(:nil),
                s(:str, "\n")),
              s(:send, nil, :tk,
                s(:sym, :SPACE),
                s(:int, 0),
                s(:int, 1),
                s(:int, 1),
                s(:nil),
                s(:str, "")),
              s(:send, nil, :tk,
                s(:sym, :DEF),
                s(:int, 8),
                s(:int, 2),
                s(:int, 0),
                s(:str, "def"),
                s(:str, "def")),
              s(:send, nil, :tk,
                s(:sym, :SPACE),
                s(:int, 11),
                s(:int, 2),
                s(:int, 3),
                s(:nil),
                s(:str, " ")),
              s(:send, nil, :tk,
                s(:sym, :IDENTIFIER),
                s(:int, 12),
                s(:int, 2),
                s(:int, 4),
                s(:str, "a"),
                s(:str, "a")),
              s(:send, nil, :tk,
                s(:sym, :NL),
                s(:int, 13),
                s(:int, 2),
                s(:int, 5),
                s(:nil),
                s(:str, "\n")),
              s(:send, nil, :tk,
                s(:sym, :DREGEXP),
                s(:int, 14),
                s(:int, 3),
                s(:int, 0),
                s(:nil),
                s(:str, "%r{#}")),
              s(:send, nil, :tk,
                s(:sym, :NL),
                s(:int, 19),
                s(:int, 3),
                s(:int, 5),
                s(:nil),
                s(:str, "\n")),
              s(:send, nil, :tk,
                s(:sym, :END),
                s(:int, 20),
                s(:int, 4),
                s(:int, 0),
                s(:str, "end"),
                s(:str, "end")))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:lvar, :a), :token_stream)))),
      s(:def, :test_parse_statements_encoding,
        s(:args),
        s(:begin,
          s(:if,
            s(:send,
              s(:const, nil, :Object), :const_defined?,
              s(:sym, :Encoding)), nil,
            s(:send, nil, :skip,
              s(:str, "Encoding not implemented"))),
          s(:send,
            s(:ivar, :@options), :encoding=,
            s(:const,
              s(:const, nil, :Encoding), :CP852)),
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class Foo\n"),
              s(:str, "  ##\n"),
              s(:str, "  # this is my method\n"),
              s(:str, "  add_my_method :foo\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "this is my method"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:const,
              s(:const, nil, :Encoding), :CP852),
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :foo), :comment), :text), :encoding)))),
      s(:def, :test_parse_statements_enddoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send, nil, :util_parser,
            s(:str, "\n# :enddoc:")),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:nil)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :klass), :done_documenting)))),
      s(:def, :test_parse_statements_enddoc_top_level,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "\n# :enddoc:")),
          s(:block,
            s(:send, nil, :assert_throws,
              s(:sym, :eof)),
            s(:args),
            s(:send,
              s(:ivar, :@parser), :parse_statements,
              s(:ivar, :@top_level),
              s(:const,
                s(:const,
                  s(:const,
                    s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
              s(:nil))))),
      s(:def, :test_parse_statements_identifier_meta_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class Foo\n"),
              s(:str, "  ##\n"),
              s(:str, "  # this is my method\n"),
              s(:str, "  add_my_method :foo\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)))),
      s(:def, :test_parse_statements_identifier_alias_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class Foo\n"),
              s(:str, "  def foo() end\n"),
              s(:str, "  alias_method :foo2, :foo\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :method_list), :[],
              s(:int, 0))),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:lvasgn, :foo2,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :method_list), :last)),
          s(:send, nil, :assert_equal,
            s(:str, "foo2"),
            s(:send,
              s(:lvar, :foo2), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:send,
                s(:lvar, :foo2), :is_alias_for), :name)),
          s(:send, nil, :assert,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :aliases), :empty?)))),
      s(:def, :test_parse_statements_identifier_alias_method_before_original_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class Foo\n"),
              s(:str, "  alias_method :foo2, :foo\n"),
              s(:str, "\n"),
              s(:str, "  alias_method :foo3, :foo\n"),
              s(:str, "\n"),
              s(:str, "  def foo()\n"),
              s(:str, "  end\n"),
              s(:str, "\n"),
              s(:str, "  alias_method :foo4, :foo\n"),
              s(:str, "\n"),
              s(:str, "  alias_method :foo5, :unknown\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :method_list), :[],
              s(:int, 0))),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:lvasgn, :foo2,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :method_list), :[],
              s(:int, 1))),
          s(:send, nil, :assert_equal,
            s(:str, "foo2"),
            s(:send,
              s(:lvar, :foo2), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:send,
                s(:lvar, :foo2), :is_alias_for), :name)),
          s(:lvasgn, :foo3,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :method_list), :[],
              s(:int, 2))),
          s(:send, nil, :assert_equal,
            s(:str, "foo3"),
            s(:send,
              s(:lvar, :foo3), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:send,
                s(:lvar, :foo3), :is_alias_for), :name)),
          s(:lvasgn, :foo4,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :method_list), :last)),
          s(:send, nil, :assert_equal,
            s(:str, "foo4"),
            s(:send,
              s(:lvar, :foo4), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:send,
                s(:lvar, :foo4), :is_alias_for), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "unknown"),
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:send,
                      s(:ivar, :@top_level), :classes), :first), :external_aliases), :[],
                s(:int, 0)), :old_name)))),
      s(:def, :test_parse_statements_identifier_args,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:str, "##\n# :args: x\n# :method: b\n# my method\n")),
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "module M\n"),
              s(:begin,
                s(:lvar, :comment)),
              s(:str, "def_delegator :a, :b, :b\nend"))),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL)),
          s(:lvasgn, :m,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :modules), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "M"),
            s(:send,
              s(:lvar, :m), :full_name)),
          s(:lvasgn, :b,
            s(:send,
              s(:send,
                s(:lvar, :m), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "M#b"),
            s(:send,
              s(:lvar, :b), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "x"),
            s(:send,
              s(:lvar, :b), :params)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :b), :comment), :text)),
          s(:send, nil, :assert_nil,
            s(:send,
              s(:lvar, :m), :params),
            s(:str, "Module parameter not removed")))),
      s(:def, :test_parse_statements_identifier_constant,
        s(:args),
        s(:begin,
          s(:lvasgn, :sixth_constant,
            s(:dstr,
              s(:str, "Class.new do\n"),
              s(:str, "  rule :file do\n"),
              s(:str, "    all(x, y, z) {\n"),
              s(:str, "      def value\n"),
              s(:str, "        find(:require).each {|r| require r.value }\n"),
              s(:str, "        find(:grammar).map {|g| g.value }\n"),
              s(:str, "      end\n"),
              s(:str, "      def min; end\n"),
              s(:str, "    }\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class Foo\n"),
              s(:str, "  FIRST_CONSTANT = 5\n"),
              s(:str, "\n"),
              s(:str, "  SECOND_CONSTANT = [\n"),
              s(:str, "     1,\n"),
              s(:str, "     2,\n"),
              s(:str, "     3\n"),
              s(:str, "  ]\n"),
              s(:str, "\n"),
              s(:str, "  THIRD_CONSTANT = {\n"),
              s(:str, "     :foo => 'bar',\n"),
              s(:str, "     :x => 'y'\n"),
              s(:str, "  }\n"),
              s(:str, "\n"),
              s(:str, "  FOURTH_CONSTANT = SECOND_CONSTANT.map do |element|\n"),
              s(:str, "    element + 1\n"),
              s(:str, "    element + 2\n"),
              s(:str, "  end\n"),
              s(:str, "\n"),
              s(:str, "  FIFTH_CONSTANT = SECOND_CONSTANT.map { |element| element + 1 }\n"),
              s(:str, "\n"),
              s(:str, "  SIXTH_CONSTANT = "),
              s(:begin,
                s(:lvar, :sixth_constant)),
              s(:str, "\n"),
              s(:str, "\n"),
              s(:str, "  SEVENTH_CONSTANT = proc { |i| begin i end }\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :constants,
            s(:send,
              s(:send,
                s(:send,
                  s(:ivar, :@top_level), :classes), :first), :constants)),
          s(:lvasgn, :constant,
            s(:send,
              s(:lvar, :constants), :[],
              s(:int, 0))),
          s(:send, nil, :assert_equal,
            s(:str, "FIRST_CONSTANT"),
            s(:send,
              s(:lvar, :constant), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "5"),
            s(:send,
              s(:lvar, :constant), :value)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :constant), :file)),
          s(:lvasgn, :constant,
            s(:send,
              s(:lvar, :constants), :[],
              s(:int, 1))),
          s(:send, nil, :assert_equal,
            s(:str, "SECOND_CONSTANT"),
            s(:send,
              s(:lvar, :constant), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "[\n1,\n2,\n3\n]"),
            s(:send,
              s(:lvar, :constant), :value)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :constant), :file)),
          s(:lvasgn, :constant,
            s(:send,
              s(:lvar, :constants), :[],
              s(:int, 2))),
          s(:send, nil, :assert_equal,
            s(:str, "THIRD_CONSTANT"),
            s(:send,
              s(:lvar, :constant), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "{\n:foo => 'bar',\n:x => 'y'\n}"),
            s(:send,
              s(:lvar, :constant), :value)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :constant), :file)),
          s(:lvasgn, :constant,
            s(:send,
              s(:lvar, :constants), :[],
              s(:int, 3))),
          s(:send, nil, :assert_equal,
            s(:str, "FOURTH_CONSTANT"),
            s(:send,
              s(:lvar, :constant), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "SECOND_CONSTANT.map do |element|\nelement + 1\nelement + 2\nend"),
            s(:send,
              s(:lvar, :constant), :value)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :constant), :file)),
          s(:lvasgn, :constant,
            s(:send,
              s(:lvar, :constants), :[],
              s(:int, 4))),
          s(:send, nil, :assert_equal,
            s(:str, "FIFTH_CONSTANT"),
            s(:send,
              s(:lvar, :constant), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "SECOND_CONSTANT.map { |element| element + 1 }"),
            s(:send,
              s(:lvar, :constant), :value)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :constant), :file)),
          s(:lvasgn, :constant,
            s(:send,
              s(:lvar, :constants), :[],
              s(:int, 5))),
          s(:send, nil, :assert_equal,
            s(:str, "SIXTH_CONSTANT"),
            s(:send,
              s(:lvar, :constant), :name)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :sixth_constant), :lines), :map,
                s(:block_pass,
                  s(:sym, :strip))), :join,
              s(:str, "\n")),
            s(:send,
              s(:lvar, :constant), :value)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :constant), :file)),
          s(:lvasgn, :constant,
            s(:send,
              s(:lvar, :constants), :[],
              s(:int, 6))),
          s(:send, nil, :assert_equal,
            s(:str, "SEVENTH_CONSTANT"),
            s(:send,
              s(:lvar, :constant), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "proc { |i| begin i end }"),
            s(:send,
              s(:lvar, :constant), :value)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :constant), :file)))),
      s(:def, :test_parse_statements_identifier_attr,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:str, "class Foo\nattr :foo\nend")),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :attributes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "R"),
            s(:send,
              s(:lvar, :foo), :rw)))),
      s(:def, :test_parse_statements_identifier_attr_accessor,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:str, "class Foo\nattr_accessor :foo\nend")),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :attributes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "RW"),
            s(:send,
              s(:lvar, :foo), :rw)))),
      s(:def, :test_parse_statements_identifier_define_method,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "class C\n"),
              s(:str, "  ##\n"),
              s(:str, "  # :method: a\n"),
              s(:str, "  define_method :a do end\n"),
              s(:str, "  ##\n"),
              s(:str, "  # :method: b\n"),
              s(:str, "  define_method :b do end\n"),
              s(:str, "end\n"))),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :c,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "a"),
              s(:str, "b")),
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :c), :method_list), :map),
              s(:args,
                s(:arg, :m)),
              s(:send,
                s(:lvar, :m), :name))))),
      s(:def, :test_parse_statements_identifier_include,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:str, "class Foo\ninclude Bar\nend")),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :foo), :includes), :length)))),
      s(:def, :test_parse_statements_identifier_module_function,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:str, "module Foo\ndef foo() end\nmodule_function :foo\nend")),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :foo),
              s(:lvasgn, :s_foo)),
            s(:send,
              s(:send,
                s(:send,
                  s(:ivar, :@top_level), :modules), :first), :method_list)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name),
            s(:str, "instance method name")),
          s(:send, nil, :assert_equal,
            s(:sym, :private),
            s(:send,
              s(:lvar, :foo), :visibility),
            s(:str, "instance method visibility")),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :foo), :singleton),
            s(:str, "instance method singleton")),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :s_foo), :name),
            s(:str, "module function name")),
          s(:send, nil, :assert_equal,
            s(:sym, :public),
            s(:send,
              s(:lvar, :s_foo), :visibility),
            s(:str, "module function visibility")),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:lvar, :s_foo), :singleton),
            s(:str, "module function singleton")))),
      s(:def, :test_parse_statements_identifier_private,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:str, "class Foo\nprivate\ndef foo() end\nend")),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:sym, :private),
            s(:send,
              s(:lvar, :foo), :visibility)))),
      s(:def, :test_parse_statements_identifier_public_class_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class Date\n"),
              s(:str, "  def self.now; end\n"),
              s(:str, "  private_class_method :now\n"),
              s(:str, "end\n"),
              s(:str, "\n"),
              s(:str, "class DateTime < Date\n"),
              s(:str, "  public_class_method :now\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :date),
              s(:lvasgn, :date_time)),
            s(:block,
              s(:send,
                s(:send,
                  s(:ivar, :@top_level), :classes), :sort_by),
              s(:args,
                s(:arg, :c)),
              s(:send,
                s(:lvar, :c), :full_name))),
          s(:lvasgn, :date_now,
            s(:send,
              s(:send,
                s(:lvar, :date), :method_list), :first)),
          s(:lvasgn, :date_time_now,
            s(:send,
              s(:block,
                s(:send,
                  s(:send,
                    s(:lvar, :date_time), :method_list), :sort_by),
                s(:args,
                  s(:arg, :m)),
                s(:send,
                  s(:lvar, :m), :full_name)), :first)),
          s(:send, nil, :assert_equal,
            s(:sym, :private),
            s(:send,
              s(:lvar, :date_now), :visibility)),
          s(:send, nil, :assert_equal,
            s(:sym, :public),
            s(:send,
              s(:lvar, :date_time_now), :visibility)))),
      s(:def, :test_parse_statements_identifier_private_class_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class Date\n"),
              s(:str, "  def self.now; end\n"),
              s(:str, "  public_class_method :now\n"),
              s(:str, "end\n"),
              s(:str, "\n"),
              s(:str, "class DateTime < Date\n"),
              s(:str, "  private_class_method :now\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :date),
              s(:lvasgn, :date_time)),
            s(:block,
              s(:send,
                s(:send,
                  s(:ivar, :@top_level), :classes), :sort_by),
              s(:args,
                s(:arg, :c)),
              s(:send,
                s(:lvar, :c), :full_name))),
          s(:lvasgn, :date_now,
            s(:send,
              s(:send,
                s(:lvar, :date), :method_list), :first)),
          s(:lvasgn, :date_time_now,
            s(:send,
              s(:block,
                s(:send,
                  s(:send,
                    s(:lvar, :date_time), :method_list), :sort_by),
                s(:args,
                  s(:arg, :m)),
                s(:send,
                  s(:lvar, :m), :full_name)), :first)),
          s(:send, nil, :assert_equal,
            s(:sym, :public),
            s(:send,
              s(:lvar, :date_now), :visibility),
            s(:send,
              s(:lvar, :date_now), :full_name)),
          s(:send, nil, :assert_equal,
            s(:sym, :private),
            s(:send,
              s(:lvar, :date_time_now), :visibility),
            s(:send,
              s(:lvar, :date_time_now), :full_name)))),
      s(:def, :test_parse_statements_identifier_require,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:str, "require 'bar'")),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :requires), :length)))),
      s(:def, :test_parse_statements_identifier_yields,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:str, "##\n# :yields: x\n# :method: b\n# my method\n")),
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "module M\n"),
              s(:begin,
                s(:lvar, :comment)),
              s(:str, "def_delegator :a, :b, :b\nend"))),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL)),
          s(:lvasgn, :m,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :modules), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "M"),
            s(:send,
              s(:lvar, :m), :full_name)),
          s(:lvasgn, :b,
            s(:send,
              s(:send,
                s(:lvar, :m), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "M#b"),
            s(:send,
              s(:lvar, :b), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "x"),
            s(:send,
              s(:lvar, :b), :block_params)),
          s(:send, nil, :assert_equal,
            s(:str, "my method"),
            s(:send,
              s(:send,
                s(:lvar, :b), :comment), :text)),
          s(:send, nil, :assert_nil,
            s(:send,
              s(:lvar, :m), :params),
            s(:str, "Module parameter not removed")))),
      s(:def, :test_parse_statements_stopdoc_TkALIAS,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send, nil, :util_parser,
            s(:str, "\n# :stopdoc:\nalias old new")),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:nil)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :aliases)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :unmatched_alias_lists)))),
      s(:def, :test_parse_statements_stopdoc_TkIDENTIFIER_alias_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send, nil, :util_parser,
            s(:str, "\n# :stopdoc:\nalias_method :old :new")),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:nil)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :aliases)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :unmatched_alias_lists)))),
      s(:def, :test_parse_statements_stopdoc_TkIDENTIFIER_metaprogrammed,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send, nil, :util_parser,
            s(:str, "\n# :stopdoc:\n# attr :meta")),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:nil)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :method_list)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :attributes)))),
      s(:def, :test_parse_statements_stopdoc_TkCONSTANT,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send, nil, :util_parser,
            s(:str, "\n# :stopdoc:\nA = v")),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:nil)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :constants)))),
      s(:def, :test_parse_statements_stopdoc_TkDEF,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "Foo"))),
          s(:send, nil, :util_parser,
            s(:str, "\n# :stopdoc:\ndef m\n end")),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:nil)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :klass), :method_list)))),
      s(:def, :test_parse_statements_super,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:str, ""),
              s(:str, "m"))),
          s(:send, nil, :util_parser,
            s(:str, "super")),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :m)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :m), :calls_super)))),
      s(:def, :test_parse_statements_super_no_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:str, "super")),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:send, nil, :assert_nil,
            s(:send,
              s(:ivar, :@parser), :get_tk)))),
      s(:def, :test_parse_statements_while_begin,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "class A\n"),
              s(:str, "  def a\n"),
              s(:str, "    while begin a; b end\n"),
              s(:str, "    end\n"),
              s(:str, "  end\n"),
              s(:str, "\n"),
              s(:str, "  def b\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :c_a,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "A"),
            s(:send,
              s(:lvar, :c_a), :full_name)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :length)),
          s(:lvasgn, :m_a,
            s(:send,
              s(:send,
                s(:lvar, :c_a), :method_list), :first)),
          s(:lvasgn, :m_b,
            s(:send,
              s(:send,
                s(:lvar, :c_a), :method_list), :last)),
          s(:send, nil, :assert_equal,
            s(:str, "A#a"),
            s(:send,
              s(:lvar, :m_a), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "A#b"),
            s(:send,
              s(:lvar, :m_b), :full_name)))),
      s(:def, :test_parse_symbol_in_arg,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, ":blah \"blah\" \"\#{blah}\" blah")),
          s(:send, nil, :assert_equal,
            s(:str, "blah"),
            s(:send,
              s(:ivar, :@parser), :parse_symbol_in_arg)),
          s(:send,
            s(:ivar, :@parser), :skip_tkspace),
          s(:send, nil, :assert_equal,
            s(:str, "blah"),
            s(:send,
              s(:ivar, :@parser), :parse_symbol_in_arg)),
          s(:send,
            s(:ivar, :@parser), :skip_tkspace),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:ivar, :@parser), :parse_symbol_in_arg)),
          s(:send,
            s(:ivar, :@parser), :skip_tkspace),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:ivar, :@parser), :parse_symbol_in_arg)))),
      s(:def, :test_parse_statements_alias_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class A\n"),
              s(:str, "  alias_method :a, :[] unless c\n"),
              s(:str, "end\n"),
              s(:str, "\n"),
              s(:str, "B = A\n"),
              s(:str, "\n"),
              s(:str, "class C\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)))),
      s(:def, :test_parse_top_level_statements_enddoc,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "# :enddoc:\n")),
          s(:block,
            s(:send, nil, :assert_throws,
              s(:sym, :eof)),
            s(:args),
            s(:send,
              s(:ivar, :@parser), :parse_top_level_statements,
              s(:ivar, :@top_level))))),
      s(:def, :test_parse_top_level_statements_stopdoc,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@top_level), :stop_doc),
          s(:lvasgn, :content,
            s(:str, "# this is the top-level comment")),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_top_level_statements,
            s(:ivar, :@top_level)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:ivar, :@top_level), :comment)))),
      s(:def, :test_parse_top_level_statements_stopdoc_integration,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "# :stopdoc:\n"),
              s(:str, "\n"),
              s(:str, "class Example\n"),
              s(:str, "  def method_name\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_top_level_statements,
            s(:ivar, :@top_level)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :length)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:ivar, :@top_level), :modules)),
          s(:send, nil, :assert,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :find_module_named,
                s(:str, "Example")), :ignored?)))),
      s(:def, :test_parse_top_level_statements_constant_nodoc_integration,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class A\n"),
              s(:str, "  C = A # :nodoc:\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :parse_top_level_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :klass,
            s(:send,
              s(:ivar, :@top_level), :find_module_named,
              s(:str, "A"))),
          s(:lvasgn, :c,
            s(:send,
              s(:send,
                s(:lvar, :klass), :constants), :first)),
          s(:send, nil, :assert_nil,
            s(:send,
              s(:lvar, :c), :document_self),
            s(:str, "C should not be documented")))),
      s(:def, :test_parse_yield_in_braces_with_parens,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass), :new,
              s(:str, "Foo"))),
          s(:send,
            s(:lvar, :klass), :parent=,
            s(:ivar, :@top_level)),
          s(:send, nil, :util_parser,
            s(:str, "def foo\nn.times { |i| yield nth(i) }\nend")),
          s(:lvasgn, :tk,
            s(:send,
              s(:ivar, :@parser), :get_tk)),
          s(:send,
            s(:ivar, :@parser), :parse_method,
            s(:lvar, :klass),
            s(:const,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :NORMAL),
            s(:lvar, :tk),
            s(:ivar, :@comment)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "nth(i)"),
            s(:send,
              s(:lvar, :foo), :block_params)))),
      s(:def, :test_read_directive,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "# :category: test"))),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :directive),
              s(:lvasgn, :value)),
            s(:send,
              s(:lvar, :parser), :read_directive,
              s(:array,
                s(:str, "category")))),
          s(:send, nil, :assert_equal,
            s(:str, "category"),
            s(:lvar, :directive)),
          s(:send, nil, :assert_equal,
            s(:str, "test"),
            s(:lvar, :value)),
          s(:send, nil, :assert_kind_of,
            s(:const,
              s(:const,
                s(:const, nil, :RDoc), :RubyToken), :TkNL),
            s(:send,
              s(:lvar, :parser), :get_tk)))),
      s(:def, :test_read_directive_allow,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "# :category: test"))),
          s(:lvasgn, :directive,
            s(:send,
              s(:lvar, :parser), :read_directive,
              s(:array))),
          s(:send, nil, :assert_nil,
            s(:lvar, :directive)),
          s(:send, nil, :assert_kind_of,
            s(:const,
              s(:const,
                s(:const, nil, :RDoc), :RubyToken), :TkNL),
            s(:send,
              s(:lvar, :parser), :get_tk)))),
      s(:def, :test_read_directive_empty,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "# test"))),
          s(:lvasgn, :directive,
            s(:send,
              s(:lvar, :parser), :read_directive,
              s(:array,
                s(:str, "category")))),
          s(:send, nil, :assert_nil,
            s(:lvar, :directive)),
          s(:send, nil, :assert_kind_of,
            s(:const,
              s(:const,
                s(:const, nil, :RDoc), :RubyToken), :TkNL),
            s(:send,
              s(:lvar, :parser), :get_tk)))),
      s(:def, :test_read_directive_no_comment,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, ""))),
          s(:lvasgn, :directive,
            s(:send,
              s(:lvar, :parser), :read_directive,
              s(:array,
                s(:str, "category")))),
          s(:send, nil, :assert_nil,
            s(:lvar, :directive)),
          s(:send, nil, :assert_kind_of,
            s(:const,
              s(:const,
                s(:const, nil, :RDoc), :RubyToken), :TkNL),
            s(:send,
              s(:lvar, :parser), :get_tk)))),
      s(:def, :test_read_directive_one_liner,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "; end # :category: test"))),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :directive),
              s(:lvasgn, :value)),
            s(:send,
              s(:lvar, :parser), :read_directive,
              s(:array,
                s(:str, "category")))),
          s(:send, nil, :assert_equal,
            s(:str, "category"),
            s(:lvar, :directive)),
          s(:send, nil, :assert_equal,
            s(:str, "test"),
            s(:lvar, :value)),
          s(:send, nil, :assert_kind_of,
            s(:const,
              s(:const,
                s(:const, nil, :RDoc), :RubyToken), :TkSEMICOLON),
            s(:send,
              s(:lvar, :parser), :get_tk)))),
      s(:def, :test_read_documentation_modifiers,
        s(:args),
        s(:begin,
          s(:lvasgn, :c,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Context), :new)),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "# :category: test"))),
          s(:send,
            s(:lvar, :parser), :read_documentation_modifiers,
            s(:lvar, :c),
            s(:array,
              s(:str, "category"))),
          s(:send, nil, :assert_equal,
            s(:str, "test"),
            s(:send,
              s(:send,
                s(:lvar, :c), :current_section), :title)))),
      s(:def, :test_read_documentation_modifiers_notnew,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "initialize"))),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "# :notnew: test"))),
          s(:send,
            s(:lvar, :parser), :read_documentation_modifiers,
            s(:lvar, :m),
            s(:array,
              s(:str, "notnew"))),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :m), :dont_rename_initialize)))),
      s(:def, :test_read_documentation_modifiers_not_dash_new,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "initialize"))),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "# :not-new: test"))),
          s(:send,
            s(:lvar, :parser), :read_documentation_modifiers,
            s(:lvar, :m),
            s(:array,
              s(:str, "not-new"))),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :m), :dont_rename_initialize)))),
      s(:def, :test_read_documentation_modifiers_not_new,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "initialize"))),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "# :not_new: test"))),
          s(:send,
            s(:lvar, :parser), :read_documentation_modifiers,
            s(:lvar, :m),
            s(:array,
              s(:str, "not_new"))),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :m), :dont_rename_initialize)))),
      s(:def, :test_sanity_integer,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "1")),
          s(:send, nil, :assert_equal,
            s(:str, "1"),
            s(:send,
              s(:send,
                s(:ivar, :@parser), :get_tk), :text)),
          s(:send, nil, :util_parser,
            s(:str, "1.0")),
          s(:send, nil, :assert_equal,
            s(:str, "1.0"),
            s(:send,
              s(:send,
                s(:ivar, :@parser), :get_tk), :text)))),
      s(:def, :test_sanity_interpolation,
        s(:args),
        s(:begin,
          s(:lvasgn, :last_tk,
            s(:nil)),
          s(:send, nil, :util_parser,
            s(:str, "class A; B = \"\#{c}\"; end")),
          s(:while,
            s(:lvasgn, :tk,
              s(:send,
                s(:ivar, :@parser), :get_tk)),
            s(:lvasgn, :last_tk,
              s(:lvar, :tk))),
          s(:send, nil, :assert_equal,
            s(:str, "\n"),
            s(:send,
              s(:lvar, :last_tk), :text)))),
      s(:def, :test_sanity_interpolation_crazy,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "\"\#{\"\#{\"a\")}\" if b}\"")),
          s(:send, nil, :assert_equal,
            s(:str, "\"\#{\"\#{\"a\")}\" if b}\""),
            s(:send,
              s(:send,
                s(:ivar, :@parser), :get_tk), :text)),
          s(:send, nil, :assert_equal,
            s(:const,
              s(:const,
                s(:const, nil, :RDoc), :RubyToken), :TkNL),
            s(:send,
              s(:send,
                s(:ivar, :@parser), :get_tk), :class)))),
      s(:def, :test_sanity_interpolation_curly,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "%{ \#{} }")),
          s(:send, nil, :assert_equal,
            s(:str, "%Q{ \#{} }"),
            s(:send,
              s(:send,
                s(:ivar, :@parser), :get_tk), :text)),
          s(:send, nil, :assert_equal,
            s(:const,
              s(:const,
                s(:const, nil, :RDoc), :RubyToken), :TkNL),
            s(:send,
              s(:send,
                s(:ivar, :@parser), :get_tk), :class)))),
      s(:def, :test_sanity_interpolation_format,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, "\"\#{stftime(\"%m-%d\")}\"")),
          s(:while,
            s(:send,
              s(:ivar, :@parser), :get_tk), nil))),
      s(:def, :test_sanity_symbol_interpolation,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:str, ":\"\#{bar}=\"")),
          s(:while,
            s(:send,
              s(:ivar, :@parser), :get_tk), nil))),
      s(:def, :test_scan_cr,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class C\r\n"),
              s(:str, "  def m\r\n"),
              s(:str, "    a=\\\r\n"),
              s(:str, "      123\r\n"),
              s(:str, "  end\r\n"),
              s(:str, "end\r\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :c,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :c), :method_list), :length)))),
      s(:def, :test_scan_block_comment,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "=begin rdoc\n"),
              s(:str, "Foo comment\n"),
              s(:str, "=end\n"),
              s(:str, "\n"),
              s(:str, "class Foo\n"),
              s(:str, "\n"),
              s(:str, "=begin\n"),
              s(:str, "m comment\n"),
              s(:str, "=end\n"),
              s(:str, "\n"),
              s(:str, "  def m() end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo comment"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:lvasgn, :m,
            s(:send,
              s(:send,
                s(:lvar, :foo), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "m comment"),
            s(:send,
              s(:send,
                s(:lvar, :m), :comment), :text)))),
      s(:def, :test_scan_block_comment_nested,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "require 'something'\n"),
              s(:str, "=begin rdoc\n"),
              s(:str, "findmeindoc\n"),
              s(:str, "=end\n"),
              s(:str, "module Foo\n"),
              s(:str, "    class Bar\n"),
              s(:str, "    end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :modules), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "findmeindoc"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:lvasgn, :bar,
            s(:send,
              s(:send,
                s(:lvar, :foo), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo::Bar"),
            s(:send,
              s(:lvar, :bar), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, ""),
            s(:send,
              s(:send,
                s(:lvar, :bar), :comment), :text)))),
      s(:def, :test_scan_block_comment_notflush,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "=begin rdoc\n"),
              s(:str, "\n"),
              s(:str, "= DESCRIPTION\n"),
              s(:str, "\n"),
              s(:str, "This is a simple test class\n"),
              s(:str, "\n"),
              s(:str, "= RUMPUS\n"),
              s(:str, "\n"),
              s(:str, "Is a silly word\n"),
              s(:str, "\n"),
              s(:str, "=end\n"),
              s(:str, "class StevenSimpleClass\n"),
              s(:str, "  # A band on my iPhone as I wrote this test\n"),
              s(:str, "  FRUIT_BATS=\"Make nice music\"\n"),
              s(:str, "\n"),
              s(:str, "=begin rdoc\n"),
              s(:str, "A nice girl\n"),
              s(:str, "=end\n"),
              s(:str, "\n"),
              s(:str, "  def lauren\n"),
              s(:str, "    puts \"Summoning Lauren!\"\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "= DESCRIPTION\n\nThis is a simple test class\n\n= RUMPUS\n\nIs a silly word"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:lvasgn, :m,
            s(:send,
              s(:send,
                s(:lvar, :foo), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "A nice girl"),
            s(:send,
              s(:send,
                s(:lvar, :m), :comment), :text)))),
      s(:def, :test_scan_class_nested_nodoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class A::B # :nodoc:\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :visible,
            s(:block,
              s(:send,
                s(:send,
                  s(:ivar, :@store), :all_classes_and_modules), :select),
              s(:args,
                s(:arg, :mod)),
              s(:send,
                s(:lvar, :mod), :display?))),
          s(:send, nil, :assert_empty,
            s(:block,
              s(:send,
                s(:lvar, :visible), :map),
              s(:args,
                s(:arg, :mod)),
              s(:send,
                s(:lvar, :mod), :full_name))))),
      s(:def, :test_scan_constant_in_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "module M\n"),
              s(:str, "  def m\n"),
              s(:str, "    A\n"),
              s(:str, "    B::C\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :m,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :modules), :first)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :m), :constants)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:send,
                s(:ivar, :@store), :classes_hash), :keys)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "M")),
            s(:send,
              s(:send,
                s(:ivar, :@store), :modules_hash), :keys)))),
      s(:def, :test_scan_constant_in_rescue,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "module M\n"),
              s(:str, "  def m\n"),
              s(:str, "  rescue A::B\n"),
              s(:str, "  rescue A::C => e\n"),
              s(:str, "  rescue A::D, A::E\n"),
              s(:str, "  rescue A::F,\n"),
              s(:str, "         A::G\n"),
              s(:str, "  rescue H\n"),
              s(:str, "  rescue I => e\n"),
              s(:str, "  rescue J, K\n"),
              s(:str, "  rescue L =>\n"),
              s(:str, "    e\n"),
              s(:str, "  rescue M;\n"),
              s(:str, "  rescue N,\n"),
              s(:str, "         O => e\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :m,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :modules), :first)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:lvar, :m), :constants)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:send,
                s(:ivar, :@store), :classes_hash), :keys)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "M")),
            s(:send,
              s(:send,
                s(:ivar, :@store), :modules_hash), :keys)))),
      s(:def, :test_scan_constant_nodoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "module M\n"),
              s(:str, "\n"),
              s(:str, "  C = v # :nodoc:\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :c,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :modules), :first), :constants), :first)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :c), :documented?)))),
      s(:def, :test_scan_constant_nodoc_block,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "module M\n"),
              s(:str, "\n"),
              s(:str, "  C = v do # :nodoc:\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :c,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :modules), :first), :constants), :first)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :c), :documented?)))),
      s(:def, :test_scan_duplicate_module,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "# comment a\n"),
              s(:str, "module Foo\n"),
              s(:str, "end\n"),
              s(:str, "\n"),
              s(:str, "# comment b\n"),
              s(:str, "module Foo\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :modules), :first)),
          s(:lvasgn, :expected,
            s(:array,
              s(:send,
                s(:const,
                  s(:const, nil, :RDoc), :Comment), :new,
                s(:str, "comment b"),
                s(:ivar, :@top_level)))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :foo), :comment_location), :map),
              s(:args,
                s(:arg, :c),
                s(:arg, :l)),
              s(:lvar, :c))))),
      s(:def, :test_scan_meta_method_block,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class C\n"),
              s(:str, "\n"),
              s(:str, "  ##\n"),
              s(:str, "  #  my method\n"),
              s(:str, "\n"),
              s(:str, "  inline(:my_method) do |*args|\n"),
              s(:str, "    \"this method used to cause z to disappear\"\n"),
              s(:str, "  end\n"),
              s(:str, "\n"),
              s(:str, "  def z\n"),
              s(:str, "  end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :classes), :first), :method_list), :length)))),
      s(:def, :test_scan_method_semi_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "class A\n"),
              s(:str, "  def self.m() end; def self.m=() end\n"),
              s(:str, "end\n"),
              s(:str, "\n"),
              s(:str, "class B\n"),
              s(:str, "  def self.m() end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :a,
            s(:send,
              s(:ivar, :@store), :find_class_named,
              s(:str, "A"))),
          s(:send, nil, :assert,
            s(:lvar, :a),
            s(:str, "missing A")),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:send,
                s(:lvar, :a), :method_list), :length)),
          s(:lvasgn, :b,
            s(:send,
              s(:ivar, :@store), :find_class_named,
              s(:str, "B"))),
          s(:send, nil, :assert,
            s(:lvar, :b),
            s(:str, "missing B")),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :b), :method_list), :length)))),
      s(:def, :test_scan_markup_override,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "# *awesome*\n"),
              s(:str, "class C\n"),
              s(:str, "  # :markup: rd\n"),
              s(:str, "  # ((*radical*))\n"),
              s(:str, "  def m\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :c,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "rdoc"),
            s(:send,
              s(:send,
                s(:lvar, :c), :comment), :format)),
          s(:send, nil, :assert_equal,
            s(:str, "rd"),
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:lvar, :c), :method_list), :first), :comment), :format)))),
      s(:def, :test_scan_markup_first_comment,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "# :markup: rd\n"),
              s(:str, "\n"),
              s(:str, "# ((*awesome*))\n"),
              s(:str, "class C\n"),
              s(:str, "  # ((*radical*))\n"),
              s(:str, "  def m\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send, nil, :util_parser,
            s(:lvar, :content)),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :c,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "rd"),
            s(:send,
              s(:send,
                s(:lvar, :c), :comment), :format)),
          s(:send, nil, :assert_equal,
            s(:str, "rd"),
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:lvar, :c), :method_list), :first), :comment), :format)))),
      s(:def, :test_scan_rails_routes,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "namespace :api do\n"),
              s(:str, "  scope module: :v1 do\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:ivar, :@top_level), :classes)),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:ivar, :@top_level), :modules)))),
      s(:def, :test_scan_tomdoc_meta,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "# :markup: tomdoc\n"),
              s(:str, "\n"),
              s(:str, "class C\n"),
              s(:str, "\n"),
              s(:str, "  # Signature\n"),
              s(:str, "  #\n"),
              s(:str, "  #   find_by_<field>[_and_<field>...](args)\n"),
              s(:str, "  #\n"),
              s(:str, "  # field - A field name.\n"),
              s(:str, "\n"),
              s(:str, "end\n"),
              s(:str, "\n"))),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :c,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:lvasgn, :m,
            s(:send,
              s(:send,
                s(:lvar, :c), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "find_by_<field>[_and_<field>...]"),
            s(:send,
              s(:lvar, :m), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "find_by_<field>[_and_<field>...](args)\n"),
            s(:send,
              s(:lvar, :m), :call_seq)),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :head,
                s(:int, 3),
                s(:str, "Signature")),
              s(:send, nil, :list,
                s(:sym, :NOTE),
                s(:send, nil, :item,
                  s(:array,
                    s(:str, "field")),
                  s(:send, nil, :para,
                    s(:str, "A field name.")))))),
          s(:send,
            s(:lvar, :expected), :file=,
            s(:ivar, :@top_level)),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:send,
                s(:lvar, :m), :comment), :parse)))),
      s(:def, :test_scan_stopdoc,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "class C\n"),
              s(:str, "  # :stopdoc:\n"),
              s(:str, "  class Hidden\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :c,
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :classes), :first)),
          s(:lvasgn, :hidden,
            s(:send,
              s(:send,
                s(:lvar, :c), :classes), :first)),
          s(:send, nil, :refute,
            s(:send,
              s(:lvar, :hidden), :document_self)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :hidden), :ignored?)))),
      s(:def, :test_scan_stopdoc_class_alias,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "# :stopdoc:\n"),
              s(:str, "module A\n"),
              s(:str, "  B = C\n"),
              s(:str, "end\n"))),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:send, nil, :assert_empty,
            s(:send,
              s(:ivar, :@store), :all_classes)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:ivar, :@store), :all_modules), :length)),
          s(:lvasgn, :m,
            s(:send,
              s(:send,
                s(:ivar, :@store), :all_modules), :first)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :m), :ignored?)))),
      s(:def, :test_scan_stopdoc_nested,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "# :stopdoc:\n"),
              s(:str, "class A::B\n"),
              s(:str, "end\n"))),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :a,
            s(:send,
              s(:send,
                s(:ivar, :@store), :modules_hash), :[],
              s(:str, "A"))),
          s(:lvasgn, :a_b,
            s(:send,
              s(:send,
                s(:ivar, :@store), :classes_hash), :[],
              s(:str, "A::B"))),
          s(:send, nil, :refute,
            s(:send,
              s(:lvar, :a), :document_self),
            s(:str, "A is inside stopdoc")),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :a), :ignored?),
            s(:str, "A is inside stopdoc")),
          s(:send, nil, :refute,
            s(:send,
              s(:lvar, :a_b), :document_self),
            s(:str, "A::B is inside stopdoc")),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :a_b), :ignored?),
            s(:str, "A::B is inside stopdoc")))),
      s(:def, :test_scan_struct_self_brackets,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "class C < M.m\n"),
              s(:str, "  def self.[]\n"),
              s(:str, "  end\n"),
              s(:str, "end\n"))),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :c,
            s(:send,
              s(:ivar, :@store), :find_class_named,
              s(:str, "C"))),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "C::[]")),
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :c), :method_list), :map),
              s(:args,
                s(:arg, :m)),
              s(:send,
                s(:lvar, :m), :full_name))))),
      s(:def, :test_scan_visibility,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "class C\n"),
              s(:str, "   def a() end\n"),
              s(:str, "\n"),
              s(:str, "   private :a\n"),
              s(:str, "\n"),
              s(:str, "   class << self\n"),
              s(:str, "     def b() end\n"),
              s(:str, "     private :b\n"),
              s(:str, "   end\n"),
              s(:str, "end\n"))),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :c,
            s(:send,
              s(:ivar, :@store), :find_class_named,
              s(:str, "C"))),
          s(:lvasgn, :c_a,
            s(:send,
              s(:lvar, :c), :find_method_named,
              s(:str, "a"))),
          s(:send, nil, :assert_equal,
            s(:sym, :private),
            s(:send,
              s(:lvar, :c_a), :visibility)),
          s(:send, nil, :refute,
            s(:send,
              s(:lvar, :c_a), :singleton)),
          s(:lvasgn, :c_b,
            s(:send,
              s(:lvar, :c), :find_method_named,
              s(:str, "b"))),
          s(:send, nil, :assert_equal,
            s(:sym, :private),
            s(:send,
              s(:lvar, :c_b), :visibility)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :c_b), :singleton)))),
      s(:def, :test_singleton_method_via_eigenclass,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "class C\n"),
              s(:str, "   class << self\n"),
              s(:str, "     def a() end\n"),
              s(:str, "   end\n"),
              s(:str, "end\n"))),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:lvasgn, :c,
            s(:send,
              s(:ivar, :@store), :find_class_named,
              s(:str, "C"))),
          s(:lvasgn, :c_a,
            s(:send,
              s(:lvar, :c), :find_method_named,
              s(:str, "a"))),
          s(:send, nil, :assert_equal,
            s(:sym, :public),
            s(:send,
              s(:lvar, :c_a), :visibility)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :c_a), :singleton)))),
      s(:def, :test_stopdoc_after_comment,
        s(:args),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:dstr,
              s(:str, "      module Bar\n"),
              s(:str, "        # hello\n"),
              s(:str, "        module Foo\n"),
              s(:str, "          # :stopdoc:\n"),
              s(:str, "        end\n"),
              s(:str, "        # there\n"),
              s(:str, "        class Baz\n"),
              s(:str, "          # :stopdoc:\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"))),
          s(:send,
            s(:ivar, :@parser), :parse_statements,
            s(:ivar, :@top_level)),
          s(:lvasgn, :foo,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :modules), :first), :modules), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:lvar, :foo), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "hello"),
            s(:send,
              s(:send,
                s(:lvar, :foo), :comment), :text)),
          s(:lvasgn, :baz,
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@top_level), :modules), :first), :classes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Baz"),
            s(:send,
              s(:lvar, :baz), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "there"),
            s(:send,
              s(:send,
                s(:lvar, :baz), :comment), :text)))),
      s(:def, :tk,
        s(:args,
          s(:arg, :klass),
          s(:arg, :scan),
          s(:arg, :line),
          s(:arg, :char),
          s(:arg, :name),
          s(:arg, :text)),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :RubyToken), :const_get,
              s(:dstr,
                s(:str, "Tk"),
                s(:begin,
                  s(:send,
                    s(:send,
                      s(:lvar, :klass), :to_s), :upcase))))),
          s(:lvasgn, :token,
            s(:if,
              s(:send,
                s(:send,
                  s(:send,
                    s(:lvar, :klass), :instance_method,
                    s(:sym, :initialize)), :arity), :==,
                s(:int, 3)),
              s(:begin,
                s(:if,
                  s(:lvar, :name),
                  s(:send, nil, :raise,
                    s(:const, nil, :ArgumentError),
                    s(:dstr,
                      s(:str, "name not used for "),
                      s(:begin,
                        s(:lvar, :klass)))), nil),
                s(:send,
                  s(:lvar, :klass), :new,
                  s(:lvar, :scan),
                  s(:lvar, :line),
                  s(:lvar, :char))),
              s(:send,
                s(:lvar, :klass), :new,
                s(:lvar, :scan),
                s(:lvar, :line),
                s(:lvar, :char),
                s(:lvar, :name)))),
          s(:send,
            s(:lvar, :token), :set_text,
            s(:lvar, :text)),
          s(:lvar, :token))),
      s(:def, :util_parser,
        s(:args,
          s(:arg, :content)),
        s(:ivasgn, :@parser,
          s(:send,
            s(:const,
              s(:const,
                s(:const, nil, :RDoc), :Parser), :Ruby), :new,
            s(:ivar, :@top_level),
            s(:ivar, :@filename),
            s(:lvar, :content),
            s(:ivar, :@options),
            s(:ivar, :@stats)))),
      s(:def, :util_two_parsers,
        s(:args,
          s(:arg, :first_file_content),
          s(:arg, :second_file_content)),
        s(:begin,
          s(:send, nil, :util_parser,
            s(:lvar, :first_file_content)),
          s(:ivasgn, :@parser2,
            s(:send,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby), :new,
              s(:ivar, :@top_level2),
              s(:ivar, :@filename),
              s(:lvar, :second_file_content),
              s(:ivar, :@options),
              s(:ivar, :@stats))))))))
