s(:begin,
  s(:send, nil, :require,
    s(:str, "rdoc/test_case")),
  s(:class,
    s(:const, nil, :TestRDocRdBlockParser),
    s(:const,
      s(:const, nil, :RDoc), :TestCase),
    s(:begin,
      s(:def, :setup,
        s(:args),
        s(:begin,
          s(:zsuper),
          s(:ivasgn, :@block_parser,
            s(:send,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :RD), :BlockParser), :new)))),
      s(:def, :test_add_footnote,
        s(:args),
        s(:begin,
          s(:lvasgn, :index,
            s(:send,
              s(:ivar, :@block_parser), :add_footnote,
              s(:str, "context"))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:lvar, :index)),
          s(:lvasgn, :expected,
            s(:array,
              s(:send, nil, :para,
                s(:str, "{^1}[rdoc-label:footmark-1:foottext-1]"),
                s(:str, " "),
                s(:str, "context")),
              s(:send, nil, :blank_line))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:ivar, :@block_parser), :footnotes)),
          s(:lvasgn, :index,
            s(:send,
              s(:ivar, :@block_parser), :add_footnote,
              s(:str, "other"))),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:lvar, :index)))),
      s(:def, :test_parse_desclist,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, ":one\n"),
              s(:str, "  desc one\n"),
              s(:str, ":two\n"),
              s(:str, "  desc two\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :NOTE),
                s(:send, nil, :item,
                  s(:str, "one"),
                  s(:send, nil, :para,
                    s(:str, "desc one"))),
                s(:send, nil, :item,
                  s(:str, "two"),
                  s(:send, nil, :para,
                    s(:str, "desc two")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_enumlist,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "(1) one\n"),
              s(:str, "(1) two\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :NUMBER),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "one"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "two")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_enumlist_paragraphs,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "(1) one\n"),
              s(:str, "\n"),
              s(:str, "    two\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :NUMBER),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "one")),
                  s(:send, nil, :para,
                    s(:str, "two")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_enumlist_multiline,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "(1) one\n"),
              s(:str, "    two\n"))),
          s(:lvasgn, :contents,
            s(:str, "one\n     two")),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :NUMBER),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:splat,
                      s(:lvar, :contents))))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_enumlist_verbatim,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "(1) item\n"),
              s(:str, "      verbatim\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :NUMBER),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "item")),
                  s(:send, nil, :verb,
                    s(:str, "verbatim\n")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_enumlist_verbatim_continue,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "(1) one\n"),
              s(:str, "      verbatim\n"),
              s(:str, "    two\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :NUMBER),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "one")),
                  s(:send, nil, :verb,
                    s(:str, "verbatim\n")),
                  s(:send, nil, :para,
                    s(:str, "two")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_footnote,
        s(:args),
        s(:begin,
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :para,
                s(:str, "{*1}[rdoc-label:foottext-1:footmark-1]")),
              s(:send, nil, :rule,
                s(:int, 1)),
              s(:send, nil, :para,
                s(:str, "{^1}[rdoc-label:footmark-1:foottext-1]"),
                s(:str, " "),
                s(:str, "text")),
              s(:send, nil, :blank_line))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:str, "((-text-))"))))),
      s(:def, :test_parse_include,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@block_parser), :include_path=,
            s(:array,
              s(:send,
                s(:const, nil, :Dir), :tmpdir))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send,
                s(:const,
                  s(:ivar, :@RM), :Include), :new,
                s(:str, "parse_include"),
                s(:array,
                  s(:send,
                    s(:const, nil, :Dir), :tmpdir))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:str, "<<< parse_include"))))),
      s(:def, :test_parse_include_subtree,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@block_parser), :include_path=,
            s(:array,
              s(:send,
                s(:const, nil, :Dir), :tmpdir))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :blank_line),
              s(:send, nil, :para,
                s(:str, "include <em>worked</em>")),
              s(:send, nil, :blank_line),
              s(:send, nil, :blank_line))),
          s(:lvasgn, :tf,
            s(:block,
              s(:send,
                s(:const, nil, :Tempfile), :open,
                s(:array,
                  s(:str, "parse_include"),
                  s(:str, ".rd"))),
              s(:args,
                s(:arg, :io)),
              s(:begin,
                s(:send,
                  s(:lvar, :io), :puts,
                  s(:str, "=begin\ninclude ((*worked*))\n=end")),
                s(:send,
                  s(:lvar, :io), :flush),
                s(:lvasgn, :str,
                  s(:dstr,
                    s(:str, "<<< "),
                    s(:begin,
                      s(:send,
                        s(:const, nil, :File), :basename,
                        s(:send,
                          s(:lvar, :io), :path))),
                    s(:str, "\n"))),
                s(:send, nil, :assert_equal,
                  s(:lvar, :expected),
                  s(:send, nil, :parse,
                    s(:lvar, :str))),
                s(:lvar, :io)))),
          s(:if,
            s(:send,
              s(:lvar, :tf), :respond_to?,
              s(:sym, :close!)),
            s(:send,
              s(:lvar, :tf), :close!), nil))),
      s(:def, :test_parse_heading,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:send, nil, :doc,
              s(:send, nil, :head,
                s(:int, 1),
                s(:str, "H"))),
            s(:send, nil, :parse,
              s(:str, "= H"))),
          s(:send, nil, :assert_equal,
            s(:send, nil, :doc,
              s(:send, nil, :head,
                s(:int, 2),
                s(:str, "H"))),
            s(:send, nil, :parse,
              s(:str, "== H"))),
          s(:send, nil, :assert_equal,
            s(:send, nil, :doc,
              s(:send, nil, :head,
                s(:int, 3),
                s(:str, "H"))),
            s(:send, nil, :parse,
              s(:str, "=== H"))),
          s(:send, nil, :assert_equal,
            s(:send, nil, :doc,
              s(:send, nil, :head,
                s(:int, 4),
                s(:str, "H"))),
            s(:send, nil, :parse,
              s(:str, "==== H"))),
          s(:send, nil, :assert_equal,
            s(:send, nil, :doc,
              s(:send, nil, :head,
                s(:int, 5),
                s(:str, "H"))),
            s(:send, nil, :parse,
              s(:str, "+ H"))),
          s(:send, nil, :assert_equal,
            s(:send, nil, :doc,
              s(:send, nil, :head,
                s(:int, 6),
                s(:str, "H"))),
            s(:send, nil, :parse,
              s(:str, "++ H"))))),
      s(:def, :test_parse_itemlist,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "* one\n"),
              s(:str, "* two\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :BULLET),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "one"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "two")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_itemlist_multiline,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "* one\n"),
              s(:str, "  two\n"))),
          s(:lvasgn, :contents,
            s(:str, "one\n   two")),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :BULLET),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:splat,
                      s(:lvar, :contents))))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_itemlist_nest,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "* one\n"),
              s(:str, "  * inner\n"),
              s(:str, "* two\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :BULLET),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "one")),
                  s(:send, nil, :list,
                    s(:sym, :BULLET),
                    s(:send, nil, :item,
                      s(:nil),
                      s(:send, nil, :para,
                        s(:str, "inner"))))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "two")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_itemlist_paragraphs,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "* one\n"),
              s(:str, "\n"),
              s(:str, "  two\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :BULLET),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "one")),
                  s(:send, nil, :para,
                    s(:str, "two")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_itemlist_verbatim,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "* item\n"),
              s(:str, "    verbatim\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :BULLET),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "item")),
                  s(:send, nil, :verb,
                    s(:str, "verbatim\n")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_itemlist_verbatim_continue,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "* one\n"),
              s(:str, "    verbatim\n"),
              s(:str, "  two\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :BULLET),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "one")),
                  s(:send, nil, :verb,
                    s(:str, "verbatim\n")),
                  s(:send, nil, :para,
                    s(:str, "two")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_lists,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "(1) one\n"),
              s(:str, "(1) two\n"),
              s(:str, "* three\n"),
              s(:str, "* four\n"),
              s(:str, "(1) five\n"),
              s(:str, "(1) six\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :NUMBER),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "one"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "two")))),
              s(:send, nil, :list,
                s(:sym, :BULLET),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "three"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "four")))),
              s(:send, nil, :list,
                s(:sym, :NUMBER),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "five"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "six")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_lists_nest,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "(1) one\n"),
              s(:str, "(1) two\n"),
              s(:str, "      * three\n"),
              s(:str, "      * four\n"),
              s(:str, "(1) five\n"),
              s(:str, "(1) six\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :NUMBER),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "one"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "two")),
                  s(:send, nil, :list,
                    s(:sym, :BULLET),
                    s(:send, nil, :item,
                      s(:nil),
                      s(:send, nil, :para,
                        s(:str, "three"))),
                    s(:send, nil, :item,
                      s(:nil),
                      s(:send, nil, :para,
                        s(:str, "four"))))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "five"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "six")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_lists_nest_verbatim,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "(1) one\n"),
              s(:str, "(1) two\n"),
              s(:str, "      * three\n"),
              s(:str, "      * four\n"),
              s(:str, "     verbatim\n"),
              s(:str, "(1) five\n"),
              s(:str, "(1) six\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :NUMBER),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "one"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "two")),
                  s(:send, nil, :list,
                    s(:sym, :BULLET),
                    s(:send, nil, :item,
                      s(:nil),
                      s(:send, nil, :para,
                        s(:str, "three"))),
                    s(:send, nil, :item,
                      s(:nil),
                      s(:send, nil, :para,
                        s(:str, "four")))),
                  s(:send, nil, :verb,
                    s(:str, "verbatim\n"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "five"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "six")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_lists_nest_verbatim2,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "(1) one\n"),
              s(:str, "(1) two\n"),
              s(:str, "      * three\n"),
              s(:str, "      * four\n"),
              s(:str, "      verbatim\n"),
              s(:str, "(1) five\n"),
              s(:str, "(1) six\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :NUMBER),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "one"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "two")),
                  s(:send, nil, :list,
                    s(:sym, :BULLET),
                    s(:send, nil, :item,
                      s(:nil),
                      s(:send, nil, :para,
                        s(:str, "three"))),
                    s(:send, nil, :item,
                      s(:nil),
                      s(:send, nil, :para,
                        s(:str, "four")))),
                  s(:send, nil, :verb,
                    s(:str, "verbatim\n"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "five"))),
                s(:send, nil, :item,
                  s(:nil),
                  s(:send, nil, :para,
                    s(:str, "six")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_methodlist,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "--- Array#each {|i| ... }\n"),
              s(:str, "      yield block for each item.\n"),
              s(:str, "--- Array#index(val)\n"),
              s(:str, "      return index of first item which equals with val. if it hasn't\n"),
              s(:str, "      same item, return nil.\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :LABEL),
                s(:send, nil, :item,
                  s(:str, "<tt>Array#each {|i| ... }</tt>"),
                  s(:send, nil, :para,
                    s(:str, "yield block for each item."))),
                s(:send, nil, :item,
                  s(:str, "<tt>Array#index(val)</tt>"),
                  s(:send, nil, :para,
                    s(:str, "return index of first item which equals with val. if it hasn't same item, return nil.")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_methodlist_empty,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "--- A#b\n"),
              s(:str, "\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :LABEL),
                s(:send, nil, :item,
                  s(:str, "<tt>A#b</tt>"))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_methodlist_paragraph,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:dstr,
              s(:str, "--- A#b\n"),
              s(:str, "\n"),
              s(:str, "    one\n"))),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :LABEL),
                s(:send, nil, :item,
                  s(:str, "<tt>A#b</tt>"),
                  s(:send, nil, :para,
                    s(:str, "one")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_methodlist_paragraph2,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:send,
              s(:dstr,
                s(:str, "--- A#b\n"),
                s(:str, "\n"),
                s(:str, "    one\n"),
                s(:str, "two\n")), :chomp)),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :LABEL),
                s(:send, nil, :item,
                  s(:str, "<tt>A#b</tt>"),
                  s(:send, nil, :para,
                    s(:str, "one")))),
              s(:send, nil, :para,
                s(:str, "two")))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_methodlist_paragraph_verbatim,
        s(:args),
        s(:begin,
          s(:lvasgn, :list,
            s(:send,
              s(:dstr,
                s(:str, "--- A#b\n"),
                s(:str, "\n"),
                s(:str, "    text\n"),
                s(:str, "      verbatim\n")), :chomp)),
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :list,
                s(:sym, :LABEL),
                s(:send, nil, :item,
                  s(:str, "<tt>A#b</tt>"),
                  s(:send, nil, :para,
                    s(:str, "text")),
                  s(:send, nil, :verb,
                    s(:str, "verbatim\n")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :list))))),
      s(:def, :test_parse_verbatim,
        s(:args),
        s(:send, nil, :assert_equal,
          s(:send, nil, :doc,
            s(:send, nil, :verb,
              s(:str, "verbatim\n"))),
          s(:send, nil, :parse,
            s(:str, "  verbatim")))),
      s(:def, :test_parse_verbatim_blankline,
        s(:args),
        s(:begin,
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :verb,
                s(:str, "one\n"),
                s(:str, "\n"),
                s(:str, "two\n")))),
          s(:lvasgn, :verbatim,
            s(:dstr,
              s(:str, "  one\n"),
              s(:str, "\n"),
              s(:str, "  two\n"))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :verbatim))))),
      s(:def, :test_parse_verbatim_indent,
        s(:args),
        s(:begin,
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :verb,
                s(:str, "one\n"),
                s(:str, " two\n")))),
          s(:lvasgn, :verbatim,
            s(:dstr,
              s(:str, "  one\n"),
              s(:str, "   two\n"))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :verbatim))))),
      s(:def, :test_parse_verbatim_multi,
        s(:args),
        s(:begin,
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :verb,
                s(:str, "one\n"),
                s(:str, "two\n")))),
          s(:lvasgn, :verbatim,
            s(:dstr,
              s(:str, "  one\n"),
              s(:str, "  two\n"))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:lvar, :verbatim))))),
      s(:def, :test_parse_textblock,
        s(:args),
        s(:send, nil, :assert_equal,
          s(:send, nil, :doc,
            s(:send, nil, :para,
              s(:str, "text"))),
          s(:send, nil, :parse,
            s(:str, "text")))),
      s(:def, :test_parse_textblock_multi,
        s(:args),
        s(:begin,
          s(:lvasgn, :expected,
            s(:send, nil, :doc,
              s(:send, nil, :para,
                s(:str, "one two")))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send, nil, :parse,
              s(:str, "one\ntwo"))))),
      s(:def, :parse,
        s(:args,
          s(:arg, :text)),
        s(:begin,
          s(:lvasgn, :text,
            s(:send,
              s(:array,
                s(:str, "=begin"),
                s(:lvar, :text),
                s(:str, "=end")), :join,
              s(:str, "\n"))),
          s(:lvasgn, :doc,
            s(:send,
              s(:ivar, :@block_parser), :parse,
              s(:send,
                s(:send,
                  s(:lvar, :text), :lines), :to_a))),
          s(:send, nil, :assert_equal,
            s(:send, nil, :blank_line),
            s(:send,
              s(:send,
                s(:lvar, :doc), :parts), :shift),
            s(:str, "=begin blankline")),
          s(:send, nil, :assert_equal,
            s(:send, nil, :blank_line),
            s(:send,
              s(:send,
                s(:lvar, :doc), :parts), :pop),
            s(:str, "=end blankline")),
          s(:lvar, :doc))))))
