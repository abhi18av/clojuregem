s(:begin,
  s(:send, nil, :require,
    s(:str, "rdoc/test_case")),
  s(:class,
    s(:const, nil, :TestRDocParserC),
    s(:const,
      s(:const, nil, :RDoc), :TestCase),
    s(:begin,
      s(:def, :setup,
        s(:args),
        s(:begin,
          s(:zsuper),
          s(:ivasgn, :@tempfile,
            s(:send,
              s(:const, nil, :Tempfile), :new,
              s(:send,
                s(:send,
                  s(:self), :class), :name))),
          s(:lvasgn, :filename,
            s(:send,
              s(:ivar, :@tempfile), :path)),
          s(:ivasgn, :@top_level,
            s(:send,
              s(:ivar, :@store), :add_file,
              s(:lvar, :filename))),
          s(:ivasgn, :@fn,
            s(:lvar, :filename)),
          s(:ivasgn, :@options,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Options), :new)),
          s(:send,
            s(:ivar, :@options), :verbosity=,
            s(:int, 2)),
          s(:ivasgn, :@stats,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Stats), :new,
              s(:ivar, :@store),
              s(:int, 0))))),
      s(:def, :teardown,
        s(:args),
        s(:begin,
          s(:zsuper),
          s(:send,
            s(:ivar, :@tempfile), :close!))),
      s(:def, :test_class_can_parse,
        s(:args),
        s(:begin,
          s(:lvasgn, :c_parser,
            s(:const,
              s(:const,
                s(:const, nil, :RDoc), :Parser), :C)),
          s(:block,
            s(:send, nil, :temp_dir),
            s(:args),
            s(:begin,
              s(:send,
                s(:const, nil, :FileUtils), :touch,
                s(:str, "file.C")),
              s(:send, nil, :assert_equal,
                s(:lvar, :c_parser),
                s(:send,
                  s(:lvar, :c_parser), :can_parse,
                  s(:str, "file.C"))),
              s(:send,
                s(:const, nil, :FileUtils), :touch,
                s(:str, "file.CC")),
              s(:send, nil, :assert_equal,
                s(:lvar, :c_parser),
                s(:send,
                  s(:lvar, :c_parser), :can_parse,
                  s(:str, "file.CC"))),
              s(:send,
                s(:const, nil, :FileUtils), :touch,
                s(:str, "file.H")),
              s(:send, nil, :assert_equal,
                s(:lvar, :c_parser),
                s(:send,
                  s(:lvar, :c_parser), :can_parse,
                  s(:str, "file.H"))),
              s(:send,
                s(:const, nil, :FileUtils), :touch,
                s(:str, "file.HH")),
              s(:send, nil, :assert_equal,
                s(:lvar, :c_parser),
                s(:send,
                  s(:lvar, :c_parser), :can_parse,
                  s(:str, "file.HH"))),
              s(:send,
                s(:const, nil, :FileUtils), :touch,
                s(:str, "file.c")),
              s(:send, nil, :assert_equal,
                s(:lvar, :c_parser),
                s(:send,
                  s(:lvar, :c_parser), :can_parse,
                  s(:str, "file.c"))),
              s(:send,
                s(:const, nil, :FileUtils), :touch,
                s(:str, "file.cc")),
              s(:send, nil, :assert_equal,
                s(:lvar, :c_parser),
                s(:send,
                  s(:lvar, :c_parser), :can_parse,
                  s(:str, "file.cc"))),
              s(:send,
                s(:const, nil, :FileUtils), :touch,
                s(:str, "file.cpp")),
              s(:send, nil, :assert_equal,
                s(:lvar, :c_parser),
                s(:send,
                  s(:lvar, :c_parser), :can_parse,
                  s(:str, "file.cpp"))),
              s(:send,
                s(:const, nil, :FileUtils), :touch,
                s(:str, "file.cxx")),
              s(:send, nil, :assert_equal,
                s(:lvar, :c_parser),
                s(:send,
                  s(:lvar, :c_parser), :can_parse,
                  s(:str, "file.cxx"))),
              s(:send,
                s(:const, nil, :FileUtils), :touch,
                s(:str, "file.h")),
              s(:send, nil, :assert_equal,
                s(:lvar, :c_parser),
                s(:send,
                  s(:lvar, :c_parser), :can_parse,
                  s(:str, "file.h"))),
              s(:send,
                s(:const, nil, :FileUtils), :touch,
                s(:str, "file.hh")),
              s(:send, nil, :assert_equal,
                s(:lvar, :c_parser),
                s(:send,
                  s(:lvar, :c_parser), :can_parse,
                  s(:str, "file.hh"))),
              s(:send,
                s(:const, nil, :FileUtils), :touch,
                s(:str, "file.y")),
              s(:send, nil, :assert_equal,
                s(:lvar, :c_parser),
                s(:send,
                  s(:lvar, :c_parser), :can_parse,
                  s(:str, "file.y"))))))),
      s(:def, :test_initialize,
        s(:args),
        s(:begin,
          s(:lvasgn, :some_ext,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "SomeExt"))),
          s(:send,
            s(:ivar, :@top_level), :add_class,
            s(:const,
              s(:const, nil, :RDoc), :SingleClass),
            s(:str, "SomeExtSingle")),
          s(:send,
            s(:send,
              s(:ivar, :@store), :cache), :[]=,
            s(:sym, :c_class_variables),
            s(:hash,
              s(:pair,
                s(:ivar, :@fn),
                s(:hash,
                  s(:pair,
                    s(:str, "cSomeExt"),
                    s(:str, "SomeExt")))))),
          s(:send,
            s(:send,
              s(:ivar, :@store), :cache), :[]=,
            s(:sym, :c_singleton_class_variables),
            s(:hash,
              s(:pair,
                s(:ivar, :@fn),
                s(:hash,
                  s(:pair,
                    s(:str, "cSomeExtSingle"),
                    s(:str, "SomeExtSingle")))))),
          s(:lvasgn, :parser,
            s(:send,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :C), :new,
              s(:ivar, :@top_level),
              s(:ivar, :@fn),
              s(:str, ""),
              s(:ivar, :@options),
              s(:ivar, :@stats))),
          s(:lvasgn, :expected,
            s(:hash,
              s(:pair,
                s(:str, "cSomeExt"),
                s(:lvar, :some_ext)))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:lvar, :parser), :classes)),
          s(:lvasgn, :expected,
            s(:hash,
              s(:pair,
                s(:str, "cSomeExtSingle"),
                s(:str, "SomeExtSingle")))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:lvar, :parser), :singleton_classes)),
          s(:lvasgn, :expected,
            s(:hash,
              s(:pair,
                s(:str, "cSomeExt"),
                s(:str, "SomeExt")),
              s(:pair,
                s(:str, "cSomeExtSingle"),
                s(:str, "SomeExtSingle")))),
          s(:lvasgn, :known_classes,
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :parser), :known_classes), :delete_if),
              s(:args,
                s(:arg, :key),
                s(:arg, :_)),
              s(:send,
                s(:send,
                  s(:const,
                    s(:const, nil, :RDoc), :KNOWN_CLASSES), :keys), :include?,
                s(:lvar, :key)))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:lvar, :known_classes)))),
      s(:def, :test_do_attr_rb_attr,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "void Init_Blah(void) {\n"),
              s(:str, "  cBlah = rb_define_class(\"Blah\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "  /*\n"),
              s(:str, "   * This is an accessor\n"),
              s(:str, "   */\n"),
              s(:str, "  rb_attr(cBlah, rb_intern(\"accessor\"), 1, 1, Qfalse);\n"),
              s(:str, "\n"),
              s(:str, "  /*\n"),
              s(:str, "   * This is a reader\n"),
              s(:str, "   */\n"),
              s(:str, "  rb_attr(cBlah, rb_intern(\"reader\"), 1, 0, Qfalse);\n"),
              s(:str, "\n"),
              s(:str, "  /*\n"),
              s(:str, "   * This is a writer\n"),
              s(:str, "   */\n"),
              s(:str, "  rb_attr(cBlah, rb_intern(\"writer\"), 0, 1, Qfalse);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cBlah"))),
          s(:lvasgn, :attrs,
            s(:send,
              s(:lvar, :klass), :attributes)),
          s(:send, nil, :assert_equal,
            s(:int, 3),
            s(:send,
              s(:lvar, :attrs), :length),
            s(:send,
              s(:lvar, :attrs), :inspect)),
          s(:lvasgn, :accessor,
            s(:send,
              s(:lvar, :attrs), :shift)),
          s(:send, nil, :assert_equal,
            s(:str, "accessor"),
            s(:send,
              s(:lvar, :accessor), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "RW"),
            s(:send,
              s(:lvar, :accessor), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "This is an accessor"),
            s(:send,
              s(:send,
                s(:lvar, :accessor), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :accessor), :file)),
          s(:lvasgn, :reader,
            s(:send,
              s(:lvar, :attrs), :shift)),
          s(:send, nil, :assert_equal,
            s(:str, "reader"),
            s(:send,
              s(:lvar, :reader), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "R"),
            s(:send,
              s(:lvar, :reader), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "This is a reader"),
            s(:send,
              s(:send,
                s(:lvar, :reader), :comment), :text)),
          s(:lvasgn, :writer,
            s(:send,
              s(:lvar, :attrs), :shift)),
          s(:send, nil, :assert_equal,
            s(:str, "writer"),
            s(:send,
              s(:lvar, :writer), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "W"),
            s(:send,
              s(:lvar, :writer), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "This is a writer"),
            s(:send,
              s(:send,
                s(:lvar, :writer), :comment), :text)))),
      s(:def, :test_do_attr_rb_define_attr,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "void Init_Blah(void) {\n"),
              s(:str, "  cBlah = rb_define_class(\"Blah\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "  /*\n"),
              s(:str, "   * This is an accessor\n"),
              s(:str, "   */\n"),
              s(:str, "  rb_define_attr(cBlah, \"accessor\", 1, 1);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cBlah"))),
          s(:lvasgn, :attrs,
            s(:send,
              s(:lvar, :klass), :attributes)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :attrs), :length),
            s(:send,
              s(:lvar, :attrs), :inspect)),
          s(:lvasgn, :accessor,
            s(:send,
              s(:lvar, :attrs), :shift)),
          s(:send, nil, :assert_equal,
            s(:str, "accessor"),
            s(:send,
              s(:lvar, :accessor), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "RW"),
            s(:send,
              s(:lvar, :accessor), :rw)),
          s(:send, nil, :assert_equal,
            s(:str, "This is an accessor"),
            s(:send,
              s(:send,
                s(:lvar, :accessor), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :accessor), :file)))),
      s(:def, :test_do_aliases,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * This should show up as an alias with documentation\n"),
              s(:str, " */\n"),
              s(:str, "VALUE blah(VALUE klass, VALUE year) {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void Init_Blah(void) {\n"),
              s(:str, "  cDate = rb_define_class(\"Date\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "  rb_define_method(cDate, \"blah\", blah, 1);\n"),
              s(:str, "\n"),
              s(:str, "  rb_define_alias(cDate, \"bleh\", \"blah\");\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cDate"))),
          s(:lvasgn, :methods,
            s(:send,
              s(:lvar, :klass), :method_list)),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:lvar, :methods), :length)),
          s(:send, nil, :assert_equal,
            s(:str, "bleh"),
            s(:send,
              s(:send,
                s(:lvar, :methods), :last), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "blah"),
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :methods), :last), :is_alias_for), :name)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :methods), :last), :is_alias_for), :file)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:send,
                s(:lvar, :methods), :last), :file)))),
      s(:def, :test_do_aliases_singleton,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * This should show up as a method with documentation\n"),
              s(:str, " */\n"),
              s(:str, "VALUE blah(VALUE klass, VALUE year) {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void Init_Blah(void) {\n"),
              s(:str, "  cDate = rb_define_class(\"Date\", rb_cObject);\n"),
              s(:str, "  sDate = rb_singleton_class(cDate);\n"),
              s(:str, "\n"),
              s(:str, "  rb_define_method(sDate, \"blah\", blah, 1);\n"),
              s(:str, "\n"),
              s(:str, "  /*\n"),
              s(:str, "   * This should show up as an alias\n"),
              s(:str, "   */\n"),
              s(:str, "  rb_define_alias(sDate, \"bleh\", \"blah\");\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cDate"))),
          s(:lvasgn, :methods,
            s(:send,
              s(:lvar, :klass), :method_list)),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:lvar, :methods), :length)),
          s(:send, nil, :assert_equal,
            s(:str, "bleh"),
            s(:send,
              s(:send,
                s(:lvar, :methods), :last), :name)),
          s(:send, nil, :assert,
            s(:send,
              s(:send,
                s(:lvar, :methods), :last), :singleton)),
          s(:send, nil, :assert_equal,
            s(:str, "blah"),
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :methods), :last), :is_alias_for), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "This should show up as an alias"),
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :methods), :last), :comment), :text)))),
      s(:def, :test_do_classes_boot_class,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/* Document-class: Foo\n"),
              s(:str, " * this is the Foo boot class\n"),
              s(:str, " */\n"),
              s(:str, "VALUE cFoo = boot_defclass(\"Foo\", rb_cObject);\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cFoo"))),
          s(:send, nil, :assert_equal,
            s(:str, "this is the Foo boot class"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "Object"),
            s(:send,
              s(:lvar, :klass), :superclass)))),
      s(:def, :test_do_classes_boot_class_nil,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/* Document-class: Foo\n"),
              s(:str, " * this is the Foo boot class\n"),
              s(:str, " */\n"),
              s(:str, "VALUE cFoo = boot_defclass(\"Foo\", 0);\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cFoo"))),
          s(:send, nil, :assert_equal,
            s(:str, "this is the Foo boot class"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :klass), :superclass)))),
      s(:def, :test_do_aliases_missing_class,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "void Init_Blah(void) {\n"),
              s(:str, "  rb_define_alias(cDate, \"b\", \"a\");\n"),
              s(:str, "}\n"))),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :_),
              s(:lvasgn, :err)),
            s(:block,
              s(:send, nil, :verbose_capture_io),
              s(:args),
              s(:send, nil, :refute,
                s(:send, nil, :util_get_class,
                  s(:lvar, :content),
                  s(:str, "cDate"))))),
          s(:send, nil, :assert_equal,
            s(:str, "Enclosing class or module \"cDate\" for alias b a is not known\n"),
            s(:lvar, :err)))),
      s(:def, :test_do_classes_class,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/* Document-class: Foo\n"),
              s(:str, " * this is the Foo class\n"),
              s(:str, " */\n"),
              s(:str, "VALUE cFoo = rb_define_class(\"Foo\", rb_cObject);\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cFoo"))),
          s(:send, nil, :assert_equal,
            s(:str, "this is the Foo class"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_do_classes_struct,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/* Document-class: Foo\n"),
              s(:str, " * this is the Foo class\n"),
              s(:str, " */\n"),
              s(:str, "VALUE cFoo = rb_struct_define_without_accessor(\n"),
              s(:str, "        \"Foo\", rb_cObject, foo_alloc,\n"),
              s(:str, "        \"some\", \"various\", \"fields\", NULL);\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cFoo"))),
          s(:send, nil, :assert_equal,
            s(:str, "this is the Foo class"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_do_classes_class_under,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/* Document-class: Kernel::Foo\n"),
              s(:str, " * this is the Foo class under Kernel\n"),
              s(:str, " */\n"),
              s(:str, "VALUE cFoo = rb_define_class_under(rb_mKernel, \"Foo\", rb_cObject);\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cFoo"))),
          s(:send, nil, :assert_equal,
            s(:str, "Kernel::Foo"),
            s(:send,
              s(:lvar, :klass), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "this is the Foo class under Kernel"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_do_classes_class_under_rb_path2class,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/* Document-class: Kernel::Foo\n"),
              s(:str, " * this is Kernel::Foo < A::B\n"),
              s(:str, " */\n"),
              s(:str, "VALUE cFoo = rb_define_class_under(rb_mKernel, \"Foo\", rb_path2class(\"A::B\"));\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cFoo"))),
          s(:send, nil, :assert_equal,
            s(:str, "Kernel::Foo"),
            s(:send,
              s(:lvar, :klass), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "A::B"),
            s(:send,
              s(:lvar, :klass), :superclass)),
          s(:send, nil, :assert_equal,
            s(:str, "this is Kernel::Foo < A::B"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_do_classes_singleton,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "VALUE cFoo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "VALUE cFooS = rb_singleton_class(cFoo);\n"))),
          s(:send, nil, :util_get_class,
            s(:lvar, :content),
            s(:str, "cFooS")),
          s(:send, nil, :assert_equal,
            s(:str, "Foo"),
            s(:send,
              s(:send,
                s(:ivar, :@parser), :singleton_classes), :[],
              s(:str, "cFooS"))))),
      s(:def, :test_do_classes_module,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/* Document-module: Foo\n"),
              s(:str, " * this is the Foo module\n"),
              s(:str, " */\n"),
              s(:str, "VALUE mFoo = rb_define_module(\"Foo\");\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "mFoo"))),
          s(:send, nil, :assert_equal,
            s(:str, "this is the Foo module"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_do_classes_module_under,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/* Document-module: Kernel::Foo\n"),
              s(:str, " * this is the Foo module under Kernel\n"),
              s(:str, " */\n"),
              s(:str, "VALUE mFoo = rb_define_module_under(rb_mKernel, \"Foo\");\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "mFoo"))),
          s(:send, nil, :assert_equal,
            s(:str, "this is the Foo module under Kernel"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_do_constants,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "#include <ruby.h>\n"),
              s(:str, "\n"),
              s(:str, "void Init_foo(){\n"),
              s(:str, "   VALUE cFoo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "   /* 300: The highest possible score in bowling */\n"),
              s(:str, "   rb_define_const(cFoo, \"PERFECT\", INT2FIX(300));\n"),
              s(:str, "\n"),
              s(:str, "   /* Huzzah!: What you cheer when you roll a perfect game */\n"),
              s(:str, "   rb_define_const(cFoo, \"CHEER\", rb_str_new2(\"Huzzah!\"));\n"),
              s(:str, "\n"),
              s(:str, "   /* TEST:TEST: Checking to see if escaped colon works */\n"),
              s(:str, "   rb_define_const(cFoo, \"TEST\", rb_str_new2(\"TEST:TEST\"));\n"),
              s(:str, "\n"),
              s(:str, "   /* \\: The file separator on MS Windows */\n"),
              s(:str, "   rb_define_const(cFoo, \"MSEPARATOR\", rb_str_new2(\"\\\"));\n"),
              s(:str, "\n"),
              s(:str, "   /* /: The file separator on Unix */\n"),
              s(:str, "   rb_define_const(cFoo, \"SEPARATOR\", rb_str_new2(\"/\"));\n"),
              s(:str, "\n"),
              s(:str, "   /* C:\\Program Files\\Stuff: A directory on MS Windows */\n"),
              s(:str, "   rb_define_const(cFoo, \"STUFF\", rb_str_new2(\"C:\\Program Files\\Stuff\"));\n"),
              s(:str, "\n"),
              s(:str, "   /* Default definition */\n"),
              s(:str, "   rb_define_const(cFoo, \"NOSEMI\", INT2FIX(99));\n"),
              s(:str, "\n"),
              s(:str, "   rb_define_const(cFoo, \"NOCOMMENT\", rb_str_new2(\"No comment\"));\n"),
              s(:str, "\n"),
              s(:str, "   /*\n"),
              s(:str, "    * Multiline comment goes here because this comment spans multiple lines.\n"),
              s(:str, "    * Multiline comment goes here because this comment spans multiple lines.\n"),
              s(:str, "    */\n"),
              s(:str, "   rb_define_const(cFoo, \"MULTILINE\", INT2FIX(1));\n"),
              s(:str, "\n"),
              s(:str, "   /*\n"),
              s(:str, "    * 1: Multiline comment goes here because this comment spans multiple lines.\n"),
              s(:str, "    * Multiline comment goes here because this comment spans multiple lines.\n"),
              s(:str, "    */\n"),
              s(:str, "   rb_define_const(cFoo, \"MULTILINE_VALUE\", INT2FIX(1));\n"),
              s(:str, "\n"),
              s(:str, "   /* Multiline comment goes here because this comment spans multiple lines.\n"),
              s(:str, "    * Multiline comment goes here because this comment spans multiple lines.\n"),
              s(:str, "    */\n"),
              s(:str, "   rb_define_const(cFoo, \"MULTILINE_NOT_EMPTY\", INT2FIX(1));\n"),
              s(:str, "\n"),
              s(:str, "   /*\n"),
              s(:str, "    * Multiline comment goes here because this comment spans multiple lines.\n"),
              s(:str, "    * 1: However, the value extraction should only happen for the first line\n"),
              s(:str, "    */\n"),
              s(:str, "   rb_define_const(cFoo, \"MULTILINE_COLON_ON_SECOND_LINE\", INT2FIX(1));\n"),
              s(:str, "\n"),
              s(:str, "}\n"))),
          s(:ivasgn, :@parser,
            s(:send, nil, :util_parser,
              s(:lvar, :content))),
          s(:send,
            s(:ivar, :@parser), :do_classes),
          s(:send,
            s(:ivar, :@parser), :do_constants),
          s(:lvasgn, :klass,
            s(:send,
              s(:send,
                s(:ivar, :@parser), :classes), :[],
              s(:str, "cFoo"))),
          s(:send, nil, :assert,
            s(:lvar, :klass)),
          s(:lvasgn, :constants,
            s(:send,
              s(:lvar, :klass), :constants)),
          s(:send, nil, :assert,
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :klass), :constants), :empty?), :!)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:send,
                s(:lvar, :constants), :first), :file)),
          s(:lvasgn, :constants,
            s(:block,
              s(:send,
                s(:lvar, :constants), :map),
              s(:args,
                s(:arg, :c)),
              s(:array,
                s(:send,
                  s(:lvar, :c), :name),
                s(:send,
                  s(:lvar, :c), :value),
                s(:send,
                  s(:send,
                    s(:lvar, :c), :comment), :text)))),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "PERFECT"),
              s(:str, "300"),
              s(:str, "The highest possible score in bowling   ")),
            s(:send,
              s(:lvar, :constants), :shift)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "CHEER"),
              s(:str, "Huzzah!"),
              s(:str, "What you cheer when you roll a perfect game   ")),
            s(:send,
              s(:lvar, :constants), :shift)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "TEST"),
              s(:str, "TEST:TEST"),
              s(:str, "Checking to see if escaped colon works   ")),
            s(:send,
              s(:lvar, :constants), :shift)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "MSEPARATOR"),
              s(:str, "\\"),
              s(:str, "The file separator on MS Windows   ")),
            s(:send,
              s(:lvar, :constants), :shift)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "SEPARATOR"),
              s(:str, "/"),
              s(:str, "The file separator on Unix   ")),
            s(:send,
              s(:lvar, :constants), :shift)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "STUFF"),
              s(:str, "C:\\Program Files\\Stuff"),
              s(:str, "A directory on MS Windows   ")),
            s(:send,
              s(:lvar, :constants), :shift)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "NOSEMI"),
              s(:str, "INT2FIX(99)"),
              s(:str, "Default definition   ")),
            s(:send,
              s(:lvar, :constants), :shift)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "NOCOMMENT"),
              s(:str, "rb_str_new2(\"No comment\")"),
              s(:str, "")),
            s(:send,
              s(:lvar, :constants), :shift)),
          s(:lvasgn, :comment,
            s(:send,
              s(:dstr,
                s(:str, "Multiline comment goes here because this comment spans multiple lines.\n"),
                s(:str, "Multiline comment goes here because this comment spans multiple lines.\n")), :chomp)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "MULTILINE"),
              s(:str, "INT2FIX(1)"),
              s(:lvar, :comment)),
            s(:send,
              s(:lvar, :constants), :shift)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "MULTILINE_VALUE"),
              s(:str, "1"),
              s(:lvar, :comment)),
            s(:send,
              s(:lvar, :constants), :shift)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "MULTILINE_NOT_EMPTY"),
              s(:str, "INT2FIX(1)"),
              s(:lvar, :comment)),
            s(:send,
              s(:lvar, :constants), :shift)),
          s(:lvasgn, :comment,
            s(:send,
              s(:dstr,
                s(:str, "Multiline comment goes here because this comment spans multiple lines.\n"),
                s(:str, "1: However, the value extraction should only happen for the first line\n")), :chomp)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "MULTILINE_COLON_ON_SECOND_LINE"),
              s(:str, "INT2FIX(1)"),
              s(:lvar, :comment)),
            s(:send,
              s(:lvar, :constants), :shift)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :constants), :empty?),
            s(:send,
              s(:lvar, :constants), :inspect)))),
      s(:def, :test_do_constants_curses,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "void Init_curses(){\n"),
              s(:str, "  mCurses = rb_define_module(\"Curses\");\n"),
              s(:str, "\n"),
              s(:str, "  /*\n"),
              s(:str, "   * Document-const: Curses::COLOR_BLACK\n"),
              s(:str, "   *\n"),
              s(:str, "   * Value of the color black\n"),
              s(:str, "   */\n"),
              s(:str, "  rb_curses_define_const(COLOR_BLACK);\n"),
              s(:str, "}\n"))),
          s(:ivasgn, :@parser,
            s(:send, nil, :util_parser,
              s(:lvar, :content))),
          s(:send,
            s(:ivar, :@parser), :do_modules),
          s(:send,
            s(:ivar, :@parser), :do_classes),
          s(:send,
            s(:ivar, :@parser), :do_constants),
          s(:lvasgn, :klass,
            s(:send,
              s(:send,
                s(:ivar, :@parser), :classes), :[],
              s(:str, "mCurses"))),
          s(:lvasgn, :constants,
            s(:send,
              s(:lvar, :klass), :constants)),
          s(:send, nil, :refute_empty,
            s(:send,
              s(:lvar, :klass), :constants)),
          s(:send, nil, :assert_equal,
            s(:str, "COLOR_BLACK"),
            s(:send,
              s(:send,
                s(:lvar, :constants), :first), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "UINT2NUM(COLOR_BLACK)"),
            s(:send,
              s(:send,
                s(:lvar, :constants), :first), :value)),
          s(:send, nil, :assert_equal,
            s(:str, "Value of the color black"),
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :constants), :first), :comment), :text)))),
      s(:def, :test_do_constants_file,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "void Init_File(void) {\n"),
              s(:str, "  /*  Document-const: LOCK_SH\n"),
              s(:str, "   *\n"),
              s(:str, "   *  Shared lock\n"),
              s(:str, "   */\n"),
              s(:str, "  rb_file_const(\"LOCK_SH\", INT2FIX(LOCK_SH));\n"),
              s(:str, "}\n"))),
          s(:ivasgn, :@parser,
            s(:send, nil, :util_parser,
              s(:lvar, :content))),
          s(:send,
            s(:ivar, :@parser), :do_modules),
          s(:send,
            s(:ivar, :@parser), :do_classes),
          s(:send,
            s(:ivar, :@parser), :do_constants),
          s(:lvasgn, :klass,
            s(:send,
              s(:send,
                s(:ivar, :@parser), :classes), :[],
              s(:str, "rb_mFConst"))),
          s(:lvasgn, :constants,
            s(:send,
              s(:lvar, :klass), :constants)),
          s(:send, nil, :refute_empty,
            s(:send,
              s(:lvar, :klass), :constants)),
          s(:lvasgn, :constant,
            s(:send,
              s(:lvar, :constants), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "LOCK_SH"),
            s(:send,
              s(:lvar, :constant), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "INT2FIX(LOCK_SH)"),
            s(:send,
              s(:lvar, :constant), :value)),
          s(:send, nil, :assert_equal,
            s(:str, "Shared lock"),
            s(:send,
              s(:send,
                s(:lvar, :constant), :comment), :text)))),
      s(:def, :test_do_includes,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "Init_foo() {\n"),
              s(:str, "   VALUE cFoo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "   VALUE mInc = rb_define_module(\"Inc\");\n"),
              s(:str, "\n"),
              s(:str, "   rb_include_module(cFoo, mInc);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cFoo"))),
          s(:lvasgn, :incl,
            s(:send,
              s(:send,
                s(:lvar, :klass), :includes), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Inc"),
            s(:send,
              s(:lvar, :incl), :name)),
          s(:send, nil, :assert_equal,
            s(:str, ""),
            s(:send,
              s(:send,
                s(:lvar, :incl), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :incl), :file)))),
      s(:def, :test_do_methods_in_c,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "VALUE blah(VALUE klass, VALUE year) {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void Init_Blah(void) {\n"),
              s(:str, "  cDate = rb_define_class(\"Date\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "  rb_define_method(cDate, \"blah\", blah, 1); /* in blah.c */\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:nil)),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :_),
              s(:lvasgn, :err)),
            s(:block,
              s(:send, nil, :verbose_capture_io),
              s(:args),
              s(:lvasgn, :klass,
                s(:send, nil, :util_get_class,
                  s(:lvar, :content),
                  s(:str, "cDate"))))),
          s(:send, nil, :assert_match,
            s(:str, " blah.c "),
            s(:lvar, :err)))),
      s(:def, :test_do_methods_in_cpp,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "VALUE blah(VALUE klass, VALUE year) {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void Init_Blah(void) {\n"),
              s(:str, "  cDate = rb_define_class(\"Date\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "  rb_define_method(cDate, \"blah\", blah, 1); /* in blah.cpp */\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:nil)),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :_),
              s(:lvasgn, :err)),
            s(:block,
              s(:send, nil, :verbose_capture_io),
              s(:args),
              s(:lvasgn, :klass,
                s(:send, nil, :util_get_class,
                  s(:lvar, :content),
                  s(:str, "cDate"))))),
          s(:send, nil, :assert_match,
            s(:str, " blah.cpp "),
            s(:lvar, :err)))),
      s(:def, :test_do_methods_in_y,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "VALUE blah(VALUE klass, VALUE year) {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void Init_Blah(void) {\n"),
              s(:str, "  cDate = rb_define_class(\"Date\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "  rb_define_method(cDate, \"blah\", blah, 1); /* in blah.y */\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:nil)),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :_),
              s(:lvasgn, :err)),
            s(:block,
              s(:send, nil, :verbose_capture_io),
              s(:args),
              s(:lvasgn, :klass,
                s(:send, nil, :util_get_class,
                  s(:lvar, :content),
                  s(:str, "cDate"))))),
          s(:send, nil, :assert_match,
            s(:str, " blah.y "),
            s(:lvar, :err)))),
      s(:def, :test_do_methods_singleton_class,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "VALUE blah(VALUE klass, VALUE year) {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void Init_Blah(void) {\n"),
              s(:str, "  cDate = rb_define_class(\"Date\", rb_cObject);\n"),
              s(:str, "  sDate = rb_singleton_class(cDate);\n"),
              s(:str, "\n"),
              s(:str, "  rb_define_method(sDate, \"blah\", blah, 1);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cDate"))),
          s(:lvasgn, :methods,
            s(:send,
              s(:lvar, :klass), :method_list)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :methods), :length)),
          s(:send, nil, :assert_equal,
            s(:str, "blah"),
            s(:send,
              s(:send,
                s(:lvar, :methods), :first), :name)),
          s(:send, nil, :assert,
            s(:send,
              s(:send,
                s(:lvar, :methods), :first), :singleton)))),
      s(:def, :test_do_missing,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:lvasgn, :klass_a,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :ClassModule),
              s(:str, "A"))),
          s(:send,
            s(:send,
              s(:lvar, :parser), :classes), :[]=,
            s(:str, "a"),
            s(:lvar, :klass_a)),
          s(:send,
            s(:send,
              s(:send,
                s(:lvar, :parser), :enclosure_dependencies), :[],
              s(:str, "c")), :<<,
            s(:str, "b")),
          s(:send,
            s(:send,
              s(:send,
                s(:lvar, :parser), :enclosure_dependencies), :[],
              s(:str, "b")), :<<,
            s(:str, "a")),
          s(:send,
            s(:send,
              s(:send,
                s(:lvar, :parser), :enclosure_dependencies), :[],
              s(:str, "d")), :<<,
            s(:str, "a")),
          s(:send,
            s(:send,
              s(:lvar, :parser), :missing_dependencies), :[]=,
            s(:str, "d"),
            s(:array,
              s(:str, "d"),
              s(:sym, :class),
              s(:str, "D"),
              s(:str, "Object"),
              s(:str, "a"))),
          s(:send,
            s(:send,
              s(:lvar, :parser), :missing_dependencies), :[]=,
            s(:str, "c"),
            s(:array,
              s(:str, "c"),
              s(:sym, :class),
              s(:str, "C"),
              s(:str, "Object"),
              s(:str, "b"))),
          s(:send,
            s(:send,
              s(:lvar, :parser), :missing_dependencies), :[]=,
            s(:str, "b"),
            s(:array,
              s(:str, "b"),
              s(:sym, :class),
              s(:str, "B"),
              s(:str, "Object"),
              s(:str, "a"))),
          s(:send,
            s(:lvar, :parser), :do_missing),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "A"),
              s(:str, "A::B"),
              s(:str, "A::B::C"),
              s(:str, "A::D")),
            s(:send,
              s(:block,
                s(:send,
                  s(:send,
                    s(:ivar, :@store), :all_classes_and_modules), :map),
                s(:args,
                  s(:arg, :m)),
                s(:send,
                  s(:lvar, :m), :full_name)), :sort)))),
      s(:def, :test_do_missing_cycle,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:lvasgn, :klass_a,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :ClassModule),
              s(:str, "A"))),
          s(:send,
            s(:send,
              s(:lvar, :parser), :classes), :[]=,
            s(:str, "a"),
            s(:lvar, :klass_a)),
          s(:send,
            s(:send,
              s(:send,
                s(:lvar, :parser), :enclosure_dependencies), :[],
              s(:str, "c")), :<<,
            s(:str, "b")),
          s(:send,
            s(:send,
              s(:send,
                s(:lvar, :parser), :enclosure_dependencies), :[],
              s(:str, "b")), :<<,
            s(:str, "a")),
          s(:send,
            s(:send,
              s(:lvar, :parser), :missing_dependencies), :[]=,
            s(:str, "c"),
            s(:array,
              s(:str, "c"),
              s(:sym, :class),
              s(:str, "C"),
              s(:str, "Object"),
              s(:str, "b"))),
          s(:send,
            s(:send,
              s(:lvar, :parser), :missing_dependencies), :[]=,
            s(:str, "b"),
            s(:array,
              s(:str, "b"),
              s(:sym, :class),
              s(:str, "B"),
              s(:str, "Object"),
              s(:str, "a"))),
          s(:send,
            s(:send,
              s(:send,
                s(:lvar, :parser), :enclosure_dependencies), :[],
              s(:str, "y")), :<<,
            s(:str, "z")),
          s(:send,
            s(:send,
              s(:send,
                s(:lvar, :parser), :enclosure_dependencies), :[],
              s(:str, "z")), :<<,
            s(:str, "y")),
          s(:send,
            s(:send,
              s(:lvar, :parser), :missing_dependencies), :[]=,
            s(:str, "y"),
            s(:array,
              s(:str, "y"),
              s(:sym, :class),
              s(:str, "Y"),
              s(:str, "Object"),
              s(:str, "z"))),
          s(:send,
            s(:send,
              s(:lvar, :parser), :missing_dependencies), :[]=,
            s(:str, "z"),
            s(:array,
              s(:str, "z"),
              s(:sym, :class),
              s(:str, "Z"),
              s(:str, "Object"),
              s(:str, "y"))),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :_),
              s(:lvasgn, :err)),
            s(:block,
              s(:send, nil, :verbose_capture_io),
              s(:args),
              s(:send,
                s(:lvar, :parser), :do_missing))),
          s(:lvasgn, :expected,
            s(:send,
              s(:str, "Unable to create class Y (y), class Z (z) "), :+,
              s(:str, "due to a cyclic class or module creation"))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:lvar, :err), :chomp)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "A"),
              s(:str, "A::B"),
              s(:str, "A::B::C")),
            s(:send,
              s(:block,
                s(:send,
                  s(:send,
                    s(:ivar, :@store), :all_classes_and_modules), :map),
                s(:args,
                  s(:arg, :m)),
                s(:send,
                  s(:lvar, :m), :full_name)), :sort)))),
      s(:def, :test_find_alias_comment,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:lvasgn, :comment,
            s(:send,
              s(:lvar, :parser), :find_alias_comment,
              s(:str, "C"),
              s(:str, "[]"),
              s(:str, "index"))),
          s(:send, nil, :assert_equal,
            s(:str, ""),
            s(:send,
              s(:lvar, :comment), :text)),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:dstr,
                s(:str, "/*\n"),
                s(:str, " * comment\n"),
                s(:str, " */\n"),
                s(:str, "\n"),
                s(:str, "rb_define_alias(C, \"[]\", \"index\");\n")))),
          s(:lvasgn, :comment,
            s(:send,
              s(:lvar, :parser), :find_alias_comment,
              s(:str, "C"),
              s(:str, "[]"),
              s(:str, "index"))),
          s(:send, nil, :assert_equal,
            s(:str, "/*\n * comment\n */\n\n"),
            s(:send,
              s(:lvar, :comment), :text)))),
      s(:def, :test_find_attr_comment_document_attr,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:dstr,
                s(:str, "/*\n"),
                s(:str, " * Document-attr: y\n"),
                s(:str, " * comment\n"),
                s(:str, " */\n")))),
          s(:lvasgn, :comment,
            s(:send,
              s(:lvar, :parser), :find_attr_comment,
              s(:nil),
              s(:str, "y"))),
          s(:send, nil, :assert_equal,
            s(:str, "/*\n * \n * comment\n */"),
            s(:send,
              s(:lvar, :comment), :text)))),
      s(:def, :test_find_attr_comment_document_attr_oneline,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:dstr,
                s(:str, "/* Document-attr: y\n"),
                s(:str, " * comment\n"),
                s(:str, " */\n")))),
          s(:lvasgn, :comment,
            s(:send,
              s(:lvar, :parser), :find_attr_comment,
              s(:nil),
              s(:str, "y"))),
          s(:send, nil, :assert_equal,
            s(:str, "/* \n * comment\n */"),
            s(:send,
              s(:lvar, :comment), :text)))),
      s(:def, :test_find_attr_comment_document_attr_overlap,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:dstr,
                s(:str, "/* Document-attr: x\n"),
                s(:str, " * comment\n"),
                s(:str, " */\n"),
                s(:str, "\n"),
                s(:str, "/* Document-attr: y\n"),
                s(:str, " * comment\n"),
                s(:str, " */\n")))),
          s(:lvasgn, :comment,
            s(:send,
              s(:lvar, :parser), :find_attr_comment,
              s(:nil),
              s(:str, "y"))),
          s(:send, nil, :assert_equal,
            s(:str, "/* \n * comment\n */"),
            s(:send,
              s(:lvar, :comment), :text)))),
      s(:def, :test_find_class_comment,
        s(:args),
        s(:begin,
          s(:send,
            s(:send,
              s(:ivar, :@options), :rdoc_include), :<<,
            s(:send,
              s(:const, nil, :File), :dirname,
              s(:str, "(string)"))),
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * Comment 1\n"),
              s(:str, " */\n"),
              s(:str, "foo = rb_define_class(\"MyClassName1\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "/*\n"),
              s(:str, " * Comment 2\n"),
              s(:str, " */\n"),
              s(:str, "bar = rb_define_class(\"MyClassName2\", rb_cObject);\n"))),
          s(:send, nil, :util_get_class,
            s(:lvar, :content)),
          s(:send, nil, :assert_equal,
            s(:str, "Comment 1"),
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@parser), :classes), :[],
                  s(:str, "foo")), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "Comment 2"),
            s(:send,
              s(:send,
                s(:send,
                  s(:send,
                    s(:ivar, :@parser), :classes), :[],
                  s(:str, "bar")), :comment), :text)))),
      s(:def, :test_find_class_comment_init,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * a comment for class Foo\n"),
              s(:str, " */\n"),
              s(:str, "void\n"),
              s(:str, "Init_Foo(void) {\n"),
              s(:str, "  VALUE foo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for class Foo"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_find_class_comment_define_class,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * a comment for class Foo\n"),
              s(:str, " */\n"),
              s(:str, "VALUE foo = rb_define_class(\"Foo\", rb_cObject);\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for class Foo"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_find_class_comment_define_class_Init_Foo,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * a comment for class Foo on Init\n"),
              s(:str, " */\n"),
              s(:str, "void\n"),
              s(:str, "Init_Foo(void) {\n"),
              s(:str, "    /*\n"),
              s(:str, "     * a comment for class Foo on rb_define_class\n"),
              s(:str, "     */\n"),
              s(:str, "    VALUE foo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for class Foo on Init"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_find_class_comment_define_class_Init_Foo_no_void,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * a comment for class Foo on Init\n"),
              s(:str, " */\n"),
              s(:str, "void\n"),
              s(:str, "Init_Foo() {\n"),
              s(:str, "    /*\n"),
              s(:str, "     * a comment for class Foo on rb_define_class\n"),
              s(:str, "     */\n"),
              s(:str, "    VALUE foo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for class Foo on Init"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_find_class_comment_define_class_bogus_comment,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * a comment for other_function\n"),
              s(:str, " */\n"),
              s(:str, "void\n"),
              s(:str, "other_function() {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_Foo(void) {\n"),
              s(:str, "    VALUE foo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:send, nil, :assert_equal,
            s(:str, ""),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_find_class_comment_define_class_under,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * a comment for class Foo\n"),
              s(:str, " */\n"),
              s(:str, "VALUE foo = rb_define_class_under(rb_cObject, \"Foo\", rb_cObject);\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for class Foo"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_find_class_comment_define_class_under_Init,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * a comment for class Foo on Init\n"),
              s(:str, " */\n"),
              s(:str, "void\n"),
              s(:str, "Init_Foo(void) {\n"),
              s(:str, "    /*\n"),
              s(:str, "     * a comment for class Foo on rb_define_class\n"),
              s(:str, "     */\n"),
              s(:str, "    VALUE foo = rb_define_class_under(rb_cObject, \"Foo\", rb_cObject);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for class Foo on rb_define_class"),
            s(:send,
              s(:send,
                s(:lvar, :klass), :comment), :text)))),
      s(:def, :test_find_const_comment_rb_define,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * A comment\n"),
              s(:str, " */\n"),
              s(:str, "rb_define_const(cFoo, \"CONST\", value);\n"))),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:lvar, :content))),
          s(:lvasgn, :comment,
            s(:send,
              s(:lvar, :parser), :find_const_comment,
              s(:str, "const"),
              s(:str, "CONST"))),
          s(:send, nil, :assert_equal,
            s(:str, "/*\n * A comment\n */\n"),
            s(:send,
              s(:lvar, :comment), :text)))),
      s(:def, :test_find_const_comment_document_const,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * Document-const: CONST\n"),
              s(:str, " *\n"),
              s(:str, " * A comment\n"),
              s(:str, " */\n"))),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:lvar, :content))),
          s(:lvasgn, :comment,
            s(:send,
              s(:lvar, :parser), :find_const_comment,
              s(:nil),
              s(:str, "CONST"))),
          s(:send, nil, :assert_equal,
            s(:str, "/*\n *\n * A comment\n */"),
            s(:send,
              s(:lvar, :comment), :text)))),
      s(:def, :test_find_const_comment_document_const_full_name,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * Document-const: Foo::CONST\n"),
              s(:str, " *\n"),
              s(:str, " * A comment\n"),
              s(:str, " */\n"))),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:lvar, :content))),
          s(:lvasgn, :comment,
            s(:send,
              s(:lvar, :parser), :find_const_comment,
              s(:nil),
              s(:str, "CONST"),
              s(:str, "Foo"))),
          s(:send, nil, :assert_equal,
            s(:str, "/*\n *\n * A comment\n */"),
            s(:send,
              s(:lvar, :comment), :text)))),
      s(:def, :test_find_body,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * a comment for other_function\n"),
              s(:str, " */\n"),
              s(:str, "VALUE\n"),
              s(:str, "other_function() {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_Foo(void) {\n"),
              s(:str, "    VALUE foo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "    rb_define_method(foo, \"my_method\", other_function, 0);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:lvasgn, :other_function,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "my_method"),
            s(:send,
              s(:lvar, :other_function), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for other_function"),
            s(:send,
              s(:send,
                s(:lvar, :other_function), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "()"),
            s(:send,
              s(:lvar, :other_function), :params)),
          s(:lvasgn, :code,
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :other_function), :token_stream), :first), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "VALUE\nother_function() {\n}"),
            s(:lvar, :code)))),
      s(:def, :test_find_body_2,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/* Copyright (C) 2010  Sven Herzberg\n"),
              s(:str, " *\n"),
              s(:str, " * This file is free software; the author(s) gives unlimited\n"),
              s(:str, " * permission to copy and/or distribute it, with or without\n"),
              s(:str, " * modifications, as long as this notice is preserved.\n"),
              s(:str, " */\n"),
              s(:str, "\n"),
              s(:str, "#include <ruby.h>\n"),
              s(:str, "\n"),
              s(:str, "static VALUE\n"),
              s(:str, "wrap_initialize (VALUE  self)\n"),
              s(:str, "{\n"),
              s(:str, "  return self;\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "/* */\n"),
              s(:str, "static VALUE\n"),
              s(:str, "wrap_shift (VALUE self,\n"),
              s(:str, "            VALUE arg)\n"),
              s(:str, "{\n"),
              s(:str, "  return self;\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "init_gi_repository (void)\n"),
              s(:str, "{\n"),
              s(:str, "  VALUE mTest = rb_define_module (\"Test\");\n"),
              s(:str, "  VALUE cTest = rb_define_class_under (mTest, \"Test\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "  rb_define_method (cTest, \"initialize\", wrap_initialize, 0);\n"),
              s(:str, "  rb_define_method (cTest, \"shift\", wrap_shift, 0);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cTest"))),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :length)))),
      s(:def, :test_find_body_cast,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * a comment for other_function\n"),
              s(:str, " */\n"),
              s(:str, "VALUE\n"),
              s(:str, "other_function() {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_Foo(void) {\n"),
              s(:str, "    VALUE foo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "    rb_define_method(foo, \"my_method\", (METHOD)other_function, 0);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:lvasgn, :other_function,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "my_method"),
            s(:send,
              s(:lvar, :other_function), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for other_function"),
            s(:send,
              s(:send,
                s(:lvar, :other_function), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "()"),
            s(:send,
              s(:lvar, :other_function), :params)),
          s(:lvasgn, :code,
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :other_function), :token_stream), :first), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "VALUE\nother_function() {\n}"),
            s(:lvar, :code)))),
      s(:def, :test_find_body_define,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "#define something something_else\n"),
              s(:str, "\n"),
              s(:str, "#define other_function rb_other_function\n"),
              s(:str, "\n"),
              s(:str, "/*\n"),
              s(:str, " * a comment for rb_other_function\n"),
              s(:str, " */\n"),
              s(:str, "VALUE\n"),
              s(:str, "rb_other_function() {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_Foo(void) {\n"),
              s(:str, "    VALUE foo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "    rb_define_method(foo, \"my_method\", other_function, 0);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:lvasgn, :other_function,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "my_method"),
            s(:send,
              s(:lvar, :other_function), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for rb_other_function"),
            s(:send,
              s(:send,
                s(:lvar, :other_function), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "()"),
            s(:send,
              s(:lvar, :other_function), :params)),
          s(:send, nil, :assert_equal,
            s(:int, 118),
            s(:send,
              s(:lvar, :other_function), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 8),
            s(:send,
              s(:lvar, :other_function), :line)),
          s(:lvasgn, :code,
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :other_function), :token_stream), :first), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "VALUE\nrb_other_function() {\n}"),
            s(:lvar, :code)))),
      s(:def, :test_find_body_define_comment,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * a comment for other_function\n"),
              s(:str, " */\n"),
              s(:str, "#define other_function rb_other_function\n"),
              s(:str, "\n"),
              s(:str, "/* */\n"),
              s(:str, "VALUE\n"),
              s(:str, "rb_other_function() {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_Foo(void) {\n"),
              s(:str, "    VALUE foo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "    rb_define_method(foo, \"my_method\", other_function, 0);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:lvasgn, :other_function,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "my_method"),
            s(:send,
              s(:lvar, :other_function), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for other_function"),
            s(:send,
              s(:send,
                s(:lvar, :other_function), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "()"),
            s(:send,
              s(:lvar, :other_function), :params)),
          s(:send, nil, :assert_equal,
            s(:int, 39),
            s(:send,
              s(:lvar, :other_function), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 4),
            s(:send,
              s(:lvar, :other_function), :line)),
          s(:lvasgn, :code,
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :other_function), :token_stream), :first), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "#define other_function rb_other_function"),
            s(:lvar, :code)))),
      s(:def, :test_find_body_document_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * Document-method: bar\n"),
              s(:str, " * Document-method: baz\n"),
              s(:str, " *\n"),
              s(:str, " * a comment for bar\n"),
              s(:str, " */\n"),
              s(:str, "VALUE\n"),
              s(:str, "bar() {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_Foo(void) {\n"),
              s(:str, "    VALUE foo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "    rb_define_method(foo, \"bar\", bar, 0);\n"),
              s(:str, "    rb_define_method(foo, \"baz\", bar, 0);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :length)),
          s(:lvasgn, :methods,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :sort)),
          s(:lvasgn, :bar,
            s(:send,
              s(:lvar, :methods), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#bar"),
            s(:send,
              s(:lvar, :bar), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for bar"),
            s(:send,
              s(:send,
                s(:lvar, :bar), :comment), :text)),
          s(:lvasgn, :baz,
            s(:send,
              s(:lvar, :methods), :last)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#baz"),
            s(:send,
              s(:lvar, :baz), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for bar"),
            s(:send,
              s(:send,
                s(:lvar, :baz), :comment), :text)))),
      s(:def, :test_find_body_document_method_equals,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * Document-method: Zlib::GzipFile#mtime=\n"),
              s(:str, " *\n"),
              s(:str, " * A comment\n"),
              s(:str, " */\n"),
              s(:str, "static VALUE\n"),
              s(:str, "rb_gzfile_set_mtime(VALUE obj, VALUE mtime)\n"),
              s(:str, "{\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_zlib() {\n"),
              s(:str, "    mZlib = rb_define_module(\"Zlib\");\n"),
              s(:str, "    cGzipFile = rb_define_class_under(mZlib, \"GzipFile\", rb_cObject);\n"),
              s(:str, "    cGzipWriter = rb_define_class_under(mZlib, \"GzipWriter\", cGzipFile);\n"),
              s(:str, "    rb_define_method(cGzipWriter, \"mtime=\", rb_gzfile_set_mtime, 1);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "cGzipWriter"))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :length)),
          s(:lvasgn, :methods,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :sort)),
          s(:lvasgn, :bar,
            s(:send,
              s(:lvar, :methods), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Zlib::GzipWriter#mtime="),
            s(:send,
              s(:lvar, :bar), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "A comment"),
            s(:send,
              s(:send,
                s(:lvar, :bar), :comment), :text)))),
      s(:def, :test_find_body_document_method_same,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "VALUE\n"),
              s(:str, "s_bar() {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "VALUE\n"),
              s(:str, "bar() {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "/*\n"),
              s(:str, " * Document-method: Foo::bar\n"),
              s(:str, " *\n"),
              s(:str, " * a comment for Foo::bar\n"),
              s(:str, " */\n"),
              s(:str, "\n"),
              s(:str, "/*\n"),
              s(:str, " * Document-method: Foo#bar\n"),
              s(:str, " *\n"),
              s(:str, " * a comment for Foo#bar\n"),
              s(:str, " */\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_Foo(void) {\n"),
              s(:str, "    VALUE foo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "    rb_define_singleton_method(foo, \"bar\", s_bar, 0);\n"),
              s(:str, "    rb_define_method(foo, \"bar\", bar, 0);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:send, nil, :assert_equal,
            s(:int, 2),
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :length)),
          s(:lvasgn, :methods,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :sort)),
          s(:lvasgn, :s_bar,
            s(:send,
              s(:lvar, :methods), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo::bar"),
            s(:send,
              s(:lvar, :s_bar), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for Foo::bar"),
            s(:send,
              s(:send,
                s(:lvar, :s_bar), :comment), :text)),
          s(:lvasgn, :bar,
            s(:send,
              s(:lvar, :methods), :last)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#bar"),
            s(:send,
              s(:lvar, :bar), :full_name)),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for Foo#bar"),
            s(:send,
              s(:send,
                s(:lvar, :bar), :comment), :text)))),
      s(:def, :test_find_body_macro,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " * a comment for other_function\n"),
              s(:str, " */\n"),
              s(:str, "DLL_LOCAL VALUE\n"),
              s(:str, "other_function() {\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_Foo(void) {\n"),
              s(:str, "    VALUE foo = rb_define_class(\"Foo\", rb_cObject);\n"),
              s(:str, "\n"),
              s(:str, "    rb_define_method(foo, \"my_method\", other_function, 0);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "foo"))),
          s(:lvasgn, :other_function,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "my_method"),
            s(:send,
              s(:lvar, :other_function), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "a comment for other_function"),
            s(:send,
              s(:send,
                s(:lvar, :other_function), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "()"),
            s(:send,
              s(:lvar, :other_function), :params)),
          s(:lvasgn, :code,
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :other_function), :token_stream), :first), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "DLL_LOCAL VALUE\nother_function() {\n}"),
            s(:lvar, :code)))),
      s(:def, :test_find_modifiers_call_seq,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "call-seq:\n"),
                s(:str, "  commercial() -> Date <br />\n"),
                s(:str, "\n"),
                s(:str, "If no arguments are given:\n"),
                s(:str, "\n")))),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:lvasgn, :method_obj,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "blah"))),
          s(:send,
            s(:lvar, :parser), :find_modifiers,
            s(:lvar, :comment),
            s(:lvar, :method_obj)),
          s(:lvasgn, :expected,
            s(:send,
              s(:dstr,
                s(:str, "commercial() -> Date <br />\n"),
                s(:str, "\n")), :chomp)),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:lvar, :method_obj), :call_seq)))),
      s(:def, :test_find_modifiers_nodoc,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "/* :nodoc:\n"),
                s(:str, " *\n"),
                s(:str, " * Blah\n"),
                s(:str, " */\n"),
                s(:str, "\n")))),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:lvasgn, :method_obj,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "blah"))),
          s(:send,
            s(:lvar, :parser), :find_modifiers,
            s(:lvar, :comment),
            s(:lvar, :method_obj)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :method_obj), :document_self)))),
      s(:def, :test_find_modifiers_yields,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "/* :yields: a, b\n"),
                s(:str, " *\n"),
                s(:str, " * Blah\n"),
                s(:str, " */\n"),
                s(:str, "\n")))),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:lvasgn, :method_obj,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "blah"))),
          s(:send,
            s(:lvar, :parser), :find_modifiers,
            s(:lvar, :comment),
            s(:lvar, :method_obj)),
          s(:send, nil, :assert_equal,
            s(:str, "a, b"),
            s(:send,
              s(:lvar, :method_obj), :block_params)),
          s(:send, nil, :assert_equal,
            s(:str, "\n\nBlah"),
            s(:send,
              s(:lvar, :comment), :text)))),
      s(:def, :test_handle_method_args_minus_1,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "Document-method: Object#m\n blah */"))),
          s(:send,
            s(:lvar, :parser), :content=,
            s(:dstr,
              s(:str, "VALUE\n"),
              s(:str, "rb_other(VALUE obj) {\n"),
              s(:str, "  rb_funcall(obj, rb_intern(\"other\"), 0);\n"),
              s(:str, "  return rb_str_new2(\"blah, blah, blah\");\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "VALUE\n"),
              s(:str, "rb_m(int argc, VALUE *argv, VALUE obj) {\n"),
              s(:str, "  VALUE o1, o2;\n"),
              s(:str, "  rb_scan_args(argc, argv, \"1\", &o1, &o2);\n"),
              s(:str, "}\n"))),
          s(:send,
            s(:lvar, :parser), :handle_method,
            s(:str, "method"),
            s(:str, "rb_cObject"),
            s(:str, "m"),
            s(:str, "rb_m"),
            s(:int, -1)),
          s(:lvasgn, :m,
            s(:send,
              s(:send,
                s(:send,
                  s(:ivar, :@top_level), :find_module_named,
                  s(:str, "Object")), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "m"),
            s(:send,
              s(:lvar, :m), :name)),
          s(:send, nil, :assert_equal,
            s(:ivar, :@top_level),
            s(:send,
              s(:lvar, :m), :file)),
          s(:send, nil, :assert_equal,
            s(:int, 115),
            s(:send,
              s(:lvar, :m), :offset)),
          s(:send, nil, :assert_equal,
            s(:int, 7),
            s(:send,
              s(:lvar, :m), :line)),
          s(:send, nil, :assert_equal,
            s(:str, "(p1)"),
            s(:send,
              s(:lvar, :m), :params)))),
      s(:def, :test_handle_method_args_0,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "Document-method: BasicObject#==\n blah */"))),
          s(:send,
            s(:lvar, :parser), :handle_method,
            s(:str, "method"),
            s(:str, "rb_cBasicObject"),
            s(:str, "=="),
            s(:str, "rb_obj_equal"),
            s(:int, 0)),
          s(:lvasgn, :bo,
            s(:send,
              s(:ivar, :@top_level), :find_module_named,
              s(:str, "BasicObject"))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :bo), :method_list), :length)),
          s(:lvasgn, :equals2,
            s(:send,
              s(:send,
                s(:lvar, :bo), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "()"),
            s(:send,
              s(:lvar, :equals2), :params)))),
      s(:def, :test_handle_method_args_1,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "Document-method: BasicObject#==\n blah */"))),
          s(:send,
            s(:lvar, :parser), :handle_method,
            s(:str, "method"),
            s(:str, "rb_cBasicObject"),
            s(:str, "=="),
            s(:str, "rb_obj_equal"),
            s(:int, 1)),
          s(:lvasgn, :bo,
            s(:send,
              s(:ivar, :@top_level), :find_module_named,
              s(:str, "BasicObject"))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :bo), :method_list), :length)),
          s(:lvasgn, :equals2,
            s(:send,
              s(:send,
                s(:lvar, :bo), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "(p1)"),
            s(:send,
              s(:lvar, :equals2), :params)))),
      s(:def, :test_handle_method_args_2,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "Document-method: BasicObject#==\n blah */"))),
          s(:send,
            s(:lvar, :parser), :handle_method,
            s(:str, "method"),
            s(:str, "rb_cBasicObject"),
            s(:str, "=="),
            s(:str, "rb_obj_equal"),
            s(:int, 2)),
          s(:lvasgn, :bo,
            s(:send,
              s(:ivar, :@top_level), :find_module_named,
              s(:str, "BasicObject"))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :bo), :method_list), :length)),
          s(:lvasgn, :equals2,
            s(:send,
              s(:send,
                s(:lvar, :bo), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, p2)"),
            s(:send,
              s(:lvar, :equals2), :params)))),
      s(:def, :test_handle_method_args_minus_2,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "Document-method: BasicObject#==\n blah */"))),
          s(:send,
            s(:lvar, :parser), :handle_method,
            s(:str, "method"),
            s(:str, "rb_cBasicObject"),
            s(:str, "=="),
            s(:str, "rb_obj_equal"),
            s(:int, -2)),
          s(:lvasgn, :bo,
            s(:send,
              s(:ivar, :@top_level), :find_module_named,
              s(:str, "BasicObject"))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :bo), :method_list), :length)),
          s(:lvasgn, :equals2,
            s(:send,
              s(:send,
                s(:lvar, :bo), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "(*args)"),
            s(:send,
              s(:lvar, :equals2), :params)))),
      s(:def, :test_handle_method_initialize,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:str, "Document-method: BasicObject::new\n blah */"))),
          s(:send,
            s(:lvar, :parser), :handle_method,
            s(:str, "private_method"),
            s(:str, "rb_cBasicObject"),
            s(:str, "initialize"),
            s(:str, "rb_obj_dummy"),
            s(:int, -1)),
          s(:lvasgn, :bo,
            s(:send,
              s(:ivar, :@top_level), :find_module_named,
              s(:str, "BasicObject"))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :bo), :method_list), :length)),
          s(:lvasgn, :new,
            s(:send,
              s(:send,
                s(:lvar, :bo), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "new"),
            s(:send,
              s(:lvar, :new), :name)),
          s(:send, nil, :assert_equal,
            s(:sym, :public),
            s(:send,
              s(:lvar, :new), :visibility)))),
      s(:def, :test_handle_singleton,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:dstr,
                s(:str, "void Init_Blah(void) {\n"),
                s(:str, "  cDate = rb_define_class(\"Date\", rb_cObject);\n"),
                s(:str, "  sDate = rb_singleton_class(cDate);\n"),
                s(:str, "}\n")))),
          s(:send,
            s(:lvar, :parser), :scan),
          s(:send, nil, :assert_equal,
            s(:str, "Date"),
            s(:send,
              s(:send,
                s(:lvar, :parser), :known_classes), :[],
              s(:str, "sDate"))),
          s(:send, nil, :assert_equal,
            s(:str, "Date"),
            s(:send,
              s(:send,
                s(:lvar, :parser), :singleton_classes), :[],
              s(:str, "sDate"))))),
      s(:def, :test_look_for_directives_in,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "# :other: not_handled\n"))),
          s(:send,
            s(:lvar, :parser), :look_for_directives_in,
            s(:ivar, :@top_level),
            s(:lvar, :comment)),
          s(:send, nil, :assert_equal,
            s(:str, "# :other: not_handled\n"),
            s(:send,
              s(:lvar, :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "not_handled"),
            s(:send,
              s(:send,
                s(:ivar, :@top_level), :metadata), :[],
              s(:str, "other"))))),
      s(:def, :test_load_variable_map,
        s(:args),
        s(:begin,
          s(:lvasgn, :some_ext,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "SomeExt"))),
          s(:send,
            s(:ivar, :@top_level), :add_class,
            s(:const,
              s(:const, nil, :RDoc), :NormalClass),
            s(:str, "OtherExt")),
          s(:send,
            s(:send,
              s(:send,
                s(:ivar, :@store), :cache), :[],
              s(:sym, :c_class_variables)), :[]=,
            s(:ivar, :@fn),
            s(:hash,
              s(:pair,
                s(:str, "cSomeExt"),
                s(:str, "SomeExt")))),
          s(:send,
            s(:send,
              s(:send,
                s(:ivar, :@store), :cache), :[],
              s(:sym, :c_class_variables)), :[]=,
            s(:str, "other.c"),
            s(:hash,
              s(:pair,
                s(:str, "cOtherExt"),
                s(:str, "OtherExt")))),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:lvasgn, :map,
            s(:send,
              s(:lvar, :parser), :load_variable_map,
              s(:sym, :c_class_variables))),
          s(:lvasgn, :expected,
            s(:hash,
              s(:pair,
                s(:str, "cSomeExt"),
                s(:lvar, :some_ext)))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:lvar, :map)),
          s(:send, nil, :assert_equal,
            s(:str, "SomeExt"),
            s(:send,
              s(:send,
                s(:lvar, :parser), :known_classes), :[],
              s(:str, "cSomeExt"))),
          s(:send, nil, :assert_nil,
            s(:send,
              s(:send,
                s(:lvar, :parser), :known_classes), :[],
              s(:str, "cOtherExt"))))),
      s(:def, :test_load_variable_map_empty,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:lvasgn, :map,
            s(:send,
              s(:lvar, :parser), :load_variable_map,
              s(:sym, :c_class_variables))),
          s(:send, nil, :assert_empty,
            s(:lvar, :map)))),
      s(:def, :test_load_variable_map_legacy,
        s(:args),
        s(:begin,
          s(:send,
            s(:send,
              s(:ivar, :@store), :cache), :[]=,
            s(:sym, :c_class_variables),
            s(:nil)),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:lvasgn, :map,
            s(:send,
              s(:lvar, :parser), :load_variable_map,
              s(:sym, :c_class_variables))),
          s(:send, nil, :assert_empty,
            s(:lvar, :map)))),
      s(:def, :test_load_variable_map_singleton,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@top_level), :add_class,
            s(:const,
              s(:const, nil, :RDoc), :NormalClass),
            s(:str, "SomeExt")),
          s(:send,
            s(:ivar, :@top_level), :add_class,
            s(:const,
              s(:const, nil, :RDoc), :NormalClass),
            s(:str, "OtherExt")),
          s(:send,
            s(:send,
              s(:send,
                s(:ivar, :@store), :cache), :[],
              s(:sym, :c_singleton_class_variables)), :[]=,
            s(:ivar, :@fn),
            s(:hash,
              s(:pair,
                s(:str, "cSomeExt"),
                s(:str, "SomeExt")))),
          s(:send,
            s(:send,
              s(:send,
                s(:ivar, :@store), :cache), :[],
              s(:sym, :c_singleton_class_variables)), :[]=,
            s(:str, "other.c"),
            s(:hash,
              s(:pair,
                s(:str, "cOtherExt"),
                s(:str, "OtherExt")))),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:lvasgn, :map,
            s(:send,
              s(:lvar, :parser), :load_variable_map,
              s(:sym, :c_singleton_class_variables))),
          s(:lvasgn, :expected,
            s(:hash,
              s(:pair,
                s(:str, "cSomeExt"),
                s(:str, "SomeExt")))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:lvar, :map)),
          s(:send, nil, :assert_equal,
            s(:str, "SomeExt"),
            s(:send,
              s(:send,
                s(:lvar, :parser), :known_classes), :[],
              s(:str, "cSomeExt"))),
          s(:send, nil, :assert_nil,
            s(:send,
              s(:send,
                s(:lvar, :parser), :known_classes), :[],
              s(:str, "cOtherExt"))))),
      s(:def, :test_load_variable_map_trim,
        s(:args),
        s(:begin,
          s(:lvasgn, :a,
            s(:send,
              s(:ivar, :@top_level), :add_class,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:str, "A"))),
          s(:send,
            s(:send,
              s(:send,
                s(:ivar, :@store), :cache), :[],
              s(:sym, :c_class_variables)), :[]=,
            s(:ivar, :@fn),
            s(:hash,
              s(:pair,
                s(:str, "cA"),
                s(:str, "A")),
              s(:pair,
                s(:str, "cB"),
                s(:str, "B")))),
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:lvasgn, :map,
            s(:send,
              s(:lvar, :parser), :load_variable_map,
              s(:sym, :c_class_variables))),
          s(:lvasgn, :expected,
            s(:hash,
              s(:pair,
                s(:str, "cA"),
                s(:lvar, :a)))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:lvar, :map)))),
      s(:def, :test_define_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*Method Comment! */\n"),
              s(:str, "static VALUE\n"),
              s(:str, "rb_io_s_read(argc, argv, io)\n"),
              s(:str, "    int argc;\n"),
              s(:str, "    VALUE *argv;\n"),
              s(:str, "    VALUE io;\n"),
              s(:str, "{\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_IO(void) {\n"),
              s(:str, "    /*\n"),
              s(:str, "     * a comment for class Foo on rb_define_class\n"),
              s(:str, "     */\n"),
              s(:str, "    VALUE rb_cIO = rb_define_class(\"IO\", rb_cObject);\n"),
              s(:str, "    rb_define_singleton_method(rb_cIO, \"read\", rb_io_s_read, -1);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "rb_cIO"))),
          s(:lvasgn, :read_method,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "read"),
            s(:send,
              s(:lvar, :read_method), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "Method Comment!   "),
            s(:send,
              s(:send,
                s(:lvar, :read_method), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "rb_io_s_read"),
            s(:send,
              s(:lvar, :read_method), :c_function)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :read_method), :singleton)))),
      s(:def, :test_define_method_with_prototype,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "static VALUE rb_io_s_read(int, VALUE*, VALUE);\n"),
              s(:str, "\n"),
              s(:str, "/* Method Comment! */\n"),
              s(:str, "static VALUE\n"),
              s(:str, "rb_io_s_read(argc, argv, io)\n"),
              s(:str, "    int argc;\n"),
              s(:str, "    VALUE *argv;\n"),
              s(:str, "    VALUE io;\n"),
              s(:str, "{\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_IO(void) {\n"),
              s(:str, "    /*\n"),
              s(:str, "     * a comment for class Foo on rb_define_class\n"),
              s(:str, "     */\n"),
              s(:str, "    VALUE rb_cIO = rb_define_class(\"IO\", rb_cObject);\n"),
              s(:str, "    rb_define_singleton_method(rb_cIO, \"read\", rb_io_s_read, -1);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "rb_cIO"))),
          s(:lvasgn, :read_method,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "read"),
            s(:send,
              s(:lvar, :read_method), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "Method Comment!   "),
            s(:send,
              s(:send,
                s(:lvar, :read_method), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:str, "rb_io_s_read"),
            s(:send,
              s(:lvar, :read_method), :c_function)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :read_method), :singleton)))),
      s(:def, :test_define_method_private,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*Method Comment! */\n"),
              s(:str, "static VALUE\n"),
              s(:str, "rb_io_s_read(argc, argv, io)\n"),
              s(:str, "    int argc;\n"),
              s(:str, "    VALUE *argv;\n"),
              s(:str, "    VALUE io;\n"),
              s(:str, "{\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_IO(void) {\n"),
              s(:str, "    /*\n"),
              s(:str, "     * a comment for class Foo on rb_define_class\n"),
              s(:str, "     */\n"),
              s(:str, "    VALUE rb_cIO = rb_define_class(\"IO\", rb_cObject);\n"),
              s(:str, "    rb_define_private_method(rb_cIO, \"read\", rb_io_s_read, -1);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "rb_cIO"))),
          s(:lvasgn, :read_method,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "IO#read"),
            s(:send,
              s(:lvar, :read_method), :full_name)),
          s(:send, nil, :assert_equal,
            s(:sym, :private),
            s(:send,
              s(:lvar, :read_method), :visibility)),
          s(:send, nil, :assert_equal,
            s(:str, "Method Comment!   "),
            s(:send,
              s(:send,
                s(:lvar, :read_method), :comment), :text)))),
      s(:def, :test_define_method_private_singleton,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*Method Comment! */\n"),
              s(:str, "static VALUE\n"),
              s(:str, "rb_io_s_read(argc, argv, io)\n"),
              s(:str, "    int argc;\n"),
              s(:str, "    VALUE *argv;\n"),
              s(:str, "    VALUE io;\n"),
              s(:str, "{\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_IO(void) {\n"),
              s(:str, "    /*\n"),
              s(:str, "     * a comment for class Foo on rb_define_class\n"),
              s(:str, "     */\n"),
              s(:str, "    VALUE rb_cIO = rb_define_class(\"IO\", rb_cObject);\n"),
              s(:str, "    VALUE rb_cIO_s = rb_singleton_class(rb_cIO);\n"),
              s(:str, "    rb_define_private_method(rb_cIO_s, \"read\", rb_io_s_read, -1);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "rb_cIO"))),
          s(:lvasgn, :read_method,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "read"),
            s(:send,
              s(:lvar, :read_method), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "Method Comment!   "),
            s(:send,
              s(:send,
                s(:lvar, :read_method), :comment), :text)),
          s(:send, nil, :assert_equal,
            s(:sym, :private),
            s(:send,
              s(:lvar, :read_method), :visibility)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :read_method), :singleton)))),
      s(:def, :test_define_method_singleton,
        s(:args),
        s(:begin,
          s(:lvasgn, :content,
            s(:dstr,
              s(:str, "/*Method Comment! */\n"),
              s(:str, "static VALUE\n"),
              s(:str, "rb_io_s_read(argc, argv, io)\n"),
              s(:str, "    int argc;\n"),
              s(:str, "    VALUE *argv;\n"),
              s(:str, "    VALUE io;\n"),
              s(:str, "{\n"),
              s(:str, "}\n"),
              s(:str, "\n"),
              s(:str, "void\n"),
              s(:str, "Init_IO(void) {\n"),
              s(:str, "    /*\n"),
              s(:str, "     * a comment for class Foo on rb_define_class\n"),
              s(:str, "     */\n"),
              s(:str, "    VALUE rb_cIO = rb_define_class(\"IO\", rb_cObject);\n"),
              s(:str, "    VALUE rb_cIO_s = rb_singleton_class(rb_cIO);\n"),
              s(:str, "    rb_define_method(rb_cIO_s, \"read\", rb_io_s_read, -1);\n"),
              s(:str, "}\n"))),
          s(:lvasgn, :klass,
            s(:send, nil, :util_get_class,
              s(:lvar, :content),
              s(:str, "rb_cIO"))),
          s(:lvasgn, :read_method,
            s(:send,
              s(:send,
                s(:lvar, :klass), :method_list), :first)),
          s(:send, nil, :assert_equal,
            s(:str, "read"),
            s(:send,
              s(:lvar, :read_method), :name)),
          s(:send, nil, :assert_equal,
            s(:str, "Method Comment!   "),
            s(:send,
              s(:send,
                s(:lvar, :read_method), :comment), :text)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :read_method), :singleton)))),
      s(:def, :test_rb_scan_args,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser)),
          s(:send, nil, :assert_equal,
            s(:str, "(p1)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"1\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, p2)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"2\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1 = v1)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"01\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1 = v1, p2 = v2)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"02\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, p2 = v2)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"11\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, *args)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"1*\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, p2 = {})"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"1:\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, &block)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"1&\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, p2)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"101\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, p2 = v2, p3)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"111\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, *args, p3)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"1*1\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, p2 = v2, *args)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"11*\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, p2 = v2, p3 = {})"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"11:\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, p2 = v2, &block)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"11&\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1, p2 = v2, *args, p4, p5 = {}, &block)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"11*1:&\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(*args)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"*\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1 = {})"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \":\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(&block)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"&\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(*args, p2 = {})"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"*:\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(p1 = {}, &block)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \":&\",)"))),
          s(:send, nil, :assert_equal,
            s(:str, "(*args, p2 = {}, &block)"),
            s(:send,
              s(:lvar, :parser), :rb_scan_args,
              s(:str, "rb_scan_args(a, b, \"*:&\",)"))))),
      s(:def, :test_scan,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:dstr,
                s(:str, "void Init(void) {\n"),
                s(:str, "    mM = rb_define_module(\"M\");\n"),
                s(:str, "    cC = rb_define_class(\"C\", rb_cObject);\n"),
                s(:str, "    sC = rb_singleton_class(cC);\n"),
                s(:str, "}\n")))),
          s(:send,
            s(:lvar, :parser), :scan),
          s(:lvasgn, :expected,
            s(:hash,
              s(:pair,
                s(:ivar, :@fn),
                s(:hash,
                  s(:pair,
                    s(:str, "mM"),
                    s(:str, "M")),
                  s(:pair,
                    s(:str, "cC"),
                    s(:str, "C")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:ivar, :@store), :c_class_variables)),
          s(:lvasgn, :expected,
            s(:hash,
              s(:pair,
                s(:ivar, :@fn),
                s(:hash,
                  s(:pair,
                    s(:str, "sC"),
                    s(:str, "C")))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:ivar, :@store), :c_singleton_class_variables)))),
      s(:def, :test_scan_method_copy,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:dstr,
                s(:str, "/*\n"),
                s(:str, " *  call-seq:\n"),
                s(:str, " *    pathname.to_s    -> string\n"),
                s(:str, " *    pathname.to_path -> string\n"),
                s(:str, " *\n"),
                s(:str, " *  Return the path as a String.\n"),
                s(:str, " *\n"),
                s(:str, " *  to_path is implemented so Pathname objects are usable with File.open, etc.\n"),
                s(:str, " */\n"),
                s(:str, "static VALUE\n"),
                s(:str, "path_to_s(VALUE self) { }\n"),
                s(:str, "\n"),
                s(:str, "/*\n"),
                s(:str, " *  call-seq:\n"),
                s(:str, " *     str[index]               -> new_str or nil\n"),
                s(:str, " *     str[start, length]       -> new_str or nil\n"),
                s(:str, " *     str.slice(index)         -> new_str or nil\n"),
                s(:str, " *     str.slice(start, length) -> new_str or nil\n"),
                s(:str, " */\n"),
                s(:str, "static VALUE\n"),
                s(:str, "path_aref_m(int argc, VALUE *argv, VALUE str) { }\n"),
                s(:str, "\n"),
                s(:str, "/*\n"),
                s(:str, " *  call-seq:\n"),
                s(:str, " *     string <=> other_string   -> -1, 0, +1 or nil\n"),
                s(:str, " */\n"),
                s(:str, "static VALUE\n"),
                s(:str, "path_cmp_m(VALUE str1, VALUE str2) { }\n"),
                s(:str, "\n"),
                s(:str, "/*\n"),
                s(:str, " *  call-seq:\n"),
                s(:str, " *     str == obj    -> true or false\n"),
                s(:str, " *     str === obj   -> true or false\n"),
                s(:str, " */\n"),
                s(:str, "VALUE\n"),
                s(:str, "rb_str_equal(VALUE str1, VALUE str2) { }\n"),
                s(:str, "\n"),
                s(:str, "Init_pathname()\n"),
                s(:str, "{\n"),
                s(:str, "    rb_cPathname = rb_define_class(\"Pathname\", rb_cObject);\n"),
                s(:str, "\n"),
                s(:str, "    rb_define_method(rb_cPathname, \"to_s\",    path_to_s, 0);\n"),
                s(:str, "    rb_define_method(rb_cPathname, \"to_path\", path_to_s, 0);\n"),
                s(:str, "    rb_define_method(rb_cPathname, \"[]\",      path_aref_m, -1);\n"),
                s(:str, "    rb_define_method(rb_cPathname, \"slice\",   path_aref_m, -1);\n"),
                s(:str, "    rb_define_method(rb_cPathname, \"<=>\",     path_cmp_m, 1);\n"),
                s(:str, "    rb_define_method(rb_cPathname, \"==\",      rb_str_equal), 2);\n"),
                s(:str, "    rb_define_method(rb_cPathname, \"===\",     rb_str_equal), 2);\n"),
                s(:str, "}\n")))),
          s(:send,
            s(:lvar, :parser), :scan),
          s(:lvasgn, :pathname,
            s(:send,
              s(:send,
                s(:ivar, :@store), :classes_hash), :[],
              s(:str, "Pathname"))),
          s(:lvasgn, :to_path,
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :pathname), :method_list), :find),
              s(:args,
                s(:arg, :m)),
              s(:send,
                s(:send,
                  s(:lvar, :m), :name), :==,
                s(:str, "to_path")))),
          s(:send, nil, :assert_equal,
            s(:str, "pathname.to_path -> string"),
            s(:send,
              s(:lvar, :to_path), :call_seq)),
          s(:lvasgn, :to_s,
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :pathname), :method_list), :find),
              s(:args,
                s(:arg, :m)),
              s(:send,
                s(:send,
                  s(:lvar, :m), :name), :==,
                s(:str, "to_s")))),
          s(:send, nil, :assert_equal,
            s(:str, "pathname.to_s    -> string"),
            s(:send,
              s(:lvar, :to_s), :call_seq)),
          s(:lvasgn, :index_expected,
            s(:send,
              s(:dstr,
                s(:str, "str[index]               -> new_str or nil\n"),
                s(:str, "str[start, length]       -> new_str or nil\n")), :chomp)),
          s(:lvasgn, :index,
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :pathname), :method_list), :find),
              s(:args,
                s(:arg, :m)),
              s(:send,
                s(:send,
                  s(:lvar, :m), :name), :==,
                s(:str, "[]")))),
          s(:send, nil, :assert_equal,
            s(:lvar, :index_expected),
            s(:send,
              s(:lvar, :index), :call_seq),
            s(:str, "[]")),
          s(:lvasgn, :slice_expected,
            s(:send,
              s(:dstr,
                s(:str, "str.slice(index)         -> new_str or nil\n"),
                s(:str, "str.slice(start, length) -> new_str or nil\n")), :chomp)),
          s(:lvasgn, :slice,
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :pathname), :method_list), :find),
              s(:args,
                s(:arg, :m)),
              s(:send,
                s(:send,
                  s(:lvar, :m), :name), :==,
                s(:str, "slice")))),
          s(:send, nil, :assert_equal,
            s(:lvar, :slice_expected),
            s(:send,
              s(:lvar, :slice), :call_seq)),
          s(:lvasgn, :spaceship,
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :pathname), :method_list), :find),
              s(:args,
                s(:arg, :m)),
              s(:send,
                s(:send,
                  s(:lvar, :m), :name), :==,
                s(:str, "<=>")))),
          s(:send, nil, :assert_equal,
            s(:str, "string <=> other_string   -> -1, 0, +1 or nil"),
            s(:send,
              s(:lvar, :spaceship), :call_seq)),
          s(:lvasgn, :equals2,
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :pathname), :method_list), :find),
              s(:args,
                s(:arg, :m)),
              s(:send,
                s(:send,
                  s(:lvar, :m), :name), :==,
                s(:str, "==")))),
          s(:send, nil, :assert_match,
            s(:str, "str == obj"),
            s(:send,
              s(:lvar, :equals2), :call_seq)),
          s(:lvasgn, :equals3,
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :pathname), :method_list), :find),
              s(:args,
                s(:arg, :m)),
              s(:send,
                s(:send,
                  s(:lvar, :m), :name), :==,
                s(:str, "===")))),
          s(:send, nil, :assert_match,
            s(:str, "str === obj"),
            s(:send,
              s(:lvar, :equals3), :call_seq)))),
      s(:def, :test_scan_order_dependent,
        s(:args),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :util_parser,
              s(:dstr,
                s(:str, "void a(void) {\n"),
                s(:str, "    mA = rb_define_module(\"A\");\n"),
                s(:str, "}\n"),
                s(:str, "\n"),
                s(:str, "void b(void) {\n"),
                s(:str, "    cB = rb_define_class_under(mA, \"B\", rb_cObject);\n"),
                s(:str, "}\n"),
                s(:str, "\n"),
                s(:str, "void c(void) {\n"),
                s(:str, "    mC = rb_define_module_under(cB, \"C\");\n"),
                s(:str, "}\n"),
                s(:str, "\n"),
                s(:str, "void d(void) {\n"),
                s(:str, "    mD = rb_define_class_under(mC, \"D\");\n"),
                s(:str, "}\n")))),
          s(:send,
            s(:lvar, :parser), :scan),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:str, "A"),
              s(:str, "A::B"),
              s(:str, "A::B::C")),
            s(:send,
              s(:block,
                s(:send,
                  s(:send,
                    s(:ivar, :@store), :all_classes_and_modules), :map),
                s(:args,
                  s(:arg, :m)),
                s(:send,
                  s(:lvar, :m), :full_name)), :sort)))),
      s(:def, :util_get_class,
        s(:args,
          s(:arg, :content),
          s(:optarg, :name,
            s(:nil))),
        s(:begin,
          s(:ivasgn, :@parser,
            s(:send, nil, :util_parser,
              s(:lvar, :content))),
          s(:send,
            s(:ivar, :@parser), :scan),
          s(:if,
            s(:lvar, :name),
            s(:send,
              s(:send,
                s(:ivar, :@parser), :classes), :[],
              s(:lvar, :name)), nil))),
      s(:def, :util_parser,
        s(:args,
          s(:optarg, :content,
            s(:str, ""))),
        s(:send,
          s(:const,
            s(:const,
              s(:const, nil, :RDoc), :Parser), :C), :new,
          s(:ivar, :@top_level),
          s(:ivar, :@fn),
          s(:lvar, :content),
          s(:ivar, :@options),
          s(:ivar, :@stats))))))
