s(:begin,
  s(:send, nil, :require,
    s(:str, "rdoc/test_case")),
  s(:class,
    s(:const, nil, :TestRDocComment),
    s(:const,
      s(:const, nil, :RDoc), :TestCase),
    s(:begin,
      s(:def, :setup,
        s(:args),
        s(:begin,
          s(:zsuper),
          s(:ivasgn, :@top_level,
            s(:send,
              s(:ivar, :@store), :add_file,
              s(:str, "file.rb"))),
          s(:ivasgn, :@comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new)),
          s(:send,
            s(:ivar, :@comment), :location=,
            s(:ivar, :@top_level)),
          s(:send,
            s(:ivar, :@comment), :text=,
            s(:str, "this is a comment")))),
      s(:def, :test_empty_eh,
        s(:args),
        s(:begin,
          s(:send, nil, :refute_empty,
            s(:ivar, :@comment)),
          s(:ivasgn, :@comment,
            s(:str, "")),
          s(:send, nil, :assert_empty,
            s(:ivar, :@comment)))),
      s(:def, :test_equals2,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:ivar, :@comment),
            s(:send,
              s(:ivar, :@comment), :dup)),
          s(:lvasgn, :c2,
            s(:send,
              s(:ivar, :@comment), :dup)),
          s(:send,
            s(:lvar, :c2), :text=,
            s(:nil)),
          s(:send, nil, :refute_equal,
            s(:ivar, :@comment),
            s(:lvar, :c2)),
          s(:lvasgn, :c3,
            s(:send,
              s(:ivar, :@comment), :dup)),
          s(:send,
            s(:lvar, :c3), :location=,
            s(:nil)),
          s(:send, nil, :refute_equal,
            s(:ivar, :@comment),
            s(:lvar, :c3)))),
      s(:def, :test_extract_call_seq,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "m"))),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "call-seq:\n"),
                s(:str, "  bla => true or false\n"),
                s(:str, "\n"),
                s(:str, "moar comment\n")),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :comment), :extract_call_seq,
            s(:lvar, :m)),
          s(:send, nil, :assert_equal,
            s(:str, "bla => true or false\n"),
            s(:send,
              s(:lvar, :m), :call_seq)))),
      s(:def, :test_extract_call_seq_blank,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "m"))),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "call-seq:\n"),
                s(:str, "  bla => true or false\n"),
                s(:str, "\n")),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :comment), :extract_call_seq,
            s(:lvar, :m)),
          s(:send, nil, :assert_equal,
            s(:str, "bla => true or false\n"),
            s(:send,
              s(:lvar, :m), :call_seq)))),
      s(:def, :test_extract_call_seq_commented,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "m"))),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "# call-seq:\n"),
                s(:str, "#   bla => true or false\n"),
                s(:str, "#\n"),
                s(:str, "# moar comment\n")),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :comment), :extract_call_seq,
            s(:lvar, :m)),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :m), :call_seq)))),
      s(:def, :test_extract_call_seq_no_blank,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "m"))),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "call-seq:\n"),
                s(:str, "  bla => true or false\n")),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :comment), :extract_call_seq,
            s(:lvar, :m)),
          s(:send, nil, :assert_equal,
            s(:str, "bla => true or false\n"),
            s(:send,
              s(:lvar, :m), :call_seq)))),
      s(:def, :test_extract_call_seq_undent,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "m"))),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "call-seq:\n"),
                s(:str, "  bla => true or false\n"),
                s(:str, "moar comment\n")),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :comment), :extract_call_seq,
            s(:lvar, :m)),
          s(:send, nil, :assert_equal,
            s(:str, "bla => true or false\nmoar comment\n"),
            s(:send,
              s(:lvar, :m), :call_seq)))),
      s(:def, :test_extract_call_seq_c,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "call-seq:\n"),
                s(:str, "  commercial() -> Date <br />\n"),
                s(:str, "  commercial(cwyear, cweek=41, cwday=5, sg=nil) -> Date [ruby 1.8] <br />\n"),
                s(:str, "  commercial(cwyear, cweek=1, cwday=1, sg=nil) -> Date [ruby 1.9]\n"),
                s(:str, "\n"),
                s(:str, "If no arguments are given:\n"),
                s(:str, "* ruby 1.8: returns a +Date+ for 1582-10-15 (the Day of Calendar Reform in\n"),
                s(:str, "  Italy)\n"),
                s(:str, "* ruby 1.9: returns a +Date+ for julian day 0\n"),
                s(:str, "\n"),
                s(:str, "Otherwise, returns a +Date+ for the commercial week year, commercial week,\n"),
                s(:str, "and commercial week day given. Ignores the 4th argument.\n")))),
          s(:lvasgn, :method_obj,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "blah"))),
          s(:send,
            s(:lvar, :comment), :extract_call_seq,
            s(:lvar, :method_obj)),
          s(:lvasgn, :expected,
            s(:send,
              s(:dstr,
                s(:str, "commercial() -> Date <br />\n"),
                s(:str, "commercial(cwyear, cweek=41, cwday=5, sg=nil) -> Date [ruby 1.8] <br />\n"),
                s(:str, "commercial(cwyear, cweek=1, cwday=1, sg=nil) -> Date [ruby 1.9]\n"),
                s(:str, "\n")), :chomp)),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:lvar, :method_obj), :call_seq)))),
      s(:def, :test_extract_call_seq_c_no_blank,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "call-seq:\n"),
                s(:str, "  commercial() -> Date <br />\n"),
                s(:str, "  commercial(cwyear, cweek=41, cwday=5, sg=nil) -> Date [ruby 1.8] <br />\n"),
                s(:str, "  commercial(cwyear, cweek=1, cwday=1, sg=nil) -> Date [ruby 1.9]\n")))),
          s(:lvasgn, :method_obj,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "blah"))),
          s(:send,
            s(:lvar, :comment), :extract_call_seq,
            s(:lvar, :method_obj)),
          s(:lvasgn, :expected,
            s(:send,
              s(:dstr,
                s(:str, "commercial() -> Date <br />\n"),
                s(:str, "commercial(cwyear, cweek=41, cwday=5, sg=nil) -> Date [ruby 1.8] <br />\n"),
                s(:str, "commercial(cwyear, cweek=1, cwday=1, sg=nil) -> Date [ruby 1.9]\n"),
                s(:str, "\n")), :chomp)),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:lvar, :method_obj), :call_seq)))),
      s(:def, :test_extract_call_seq_c_separator,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "call-seq:\n"),
                s(:str, "   ARGF.readlines(sep=$/)     -> array\n"),
                s(:str, "   ARGF.readlines(limit)      -> array\n"),
                s(:str, "   ARGF.readlines(sep, limit) -> array\n"),
                s(:str, "\n"),
                s(:str, "   ARGF.to_a(sep=$/)     -> array\n"),
                s(:str, "   ARGF.to_a(limit)      -> array\n"),
                s(:str, "   ARGF.to_a(sep, limit) -> array\n"),
                s(:str, "\n"),
                s(:str, "Reads +ARGF+'s current file in its entirety, returning an +Array+ of its\n"),
                s(:str, "lines, one line per element. Lines are assumed to be separated by _sep_.\n"),
                s(:str, "\n"),
                s(:str, "   lines = ARGF.readlines\n"),
                s(:str, "   lines[0]                #=> \"This is line one\\n\"\n"),
                s(:str, "\n")))),
          s(:lvasgn, :method_obj,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :AnyMethod), :new,
              s(:nil),
              s(:str, "blah"))),
          s(:send,
            s(:lvar, :comment), :extract_call_seq,
            s(:lvar, :method_obj)),
          s(:lvasgn, :expected,
            s(:dstr,
              s(:str, "ARGF.readlines(sep=$/)     -> array\n"),
              s(:str, "ARGF.readlines(limit)      -> array\n"),
              s(:str, "ARGF.readlines(sep, limit) -> array\n"),
              s(:str, "ARGF.to_a(sep=$/)     -> array\n"),
              s(:str, "ARGF.to_a(limit)      -> array\n"),
              s(:str, "ARGF.to_a(sep, limit) -> array\n"))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:lvar, :method_obj), :call_seq)),
          s(:lvasgn, :expected,
            s(:dstr,
              s(:str, "\n"),
              s(:str, "Reads +ARGF+'s current file in its entirety, returning an +Array+ of its\n"),
              s(:str, "lines, one line per element. Lines are assumed to be separated by _sep_.\n"),
              s(:str, "\n"),
              s(:str, "   lines = ARGF.readlines\n"),
              s(:str, "   lines[0]                #=> \"This is line one\\n\"\n"),
              s(:str, "\n"))),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:lvar, :comment), :text)))),
      s(:def, :test_force_encoding,
        s(:args),
        s(:begin,
          s(:if,
            s(:send,
              s(:const, nil, :Object), :const_defined?,
              s(:sym, :Encoding)), nil,
            s(:send, nil, :skip,
              s(:str, "Encoding not implemented"))),
          s(:send,
            s(:ivar, :@comment), :force_encoding,
            s(:const,
              s(:const, nil, :Encoding), :UTF_8)),
          s(:send, nil, :assert_equal,
            s(:const,
              s(:const, nil, :Encoding), :UTF_8),
            s(:send,
              s(:send,
                s(:ivar, :@comment), :text), :encoding)))),
      s(:def, :test_format,
        s(:args),
        s(:send, nil, :assert_equal,
          s(:str, "rdoc"),
          s(:send,
            s(:ivar, :@comment), :format))),
      s(:def, :test_format_equals,
        s(:args),
        s(:begin,
          s(:lvasgn, :c,
            s(:send, nil, :comment,
              s(:str, "content"))),
          s(:lvasgn, :document,
            s(:send,
              s(:lvar, :c), :parse)),
          s(:send,
            s(:lvar, :c), :format=,
            s(:const,
              s(:const, nil, :RDoc), :RD)),
          s(:send, nil, :assert_equal,
            s(:const,
              s(:const, nil, :RDoc), :RD),
            s(:send,
              s(:lvar, :c), :format)),
          s(:send, nil, :refute_same,
            s(:lvar, :document),
            s(:send,
              s(:lvar, :c), :parse)))),
      s(:def, :test_initialize_copy,
        s(:args),
        s(:begin,
          s(:lvasgn, :copy,
            s(:send,
              s(:ivar, :@comment), :dup)),
          s(:send, nil, :refute_same,
            s(:send,
              s(:ivar, :@comment), :text),
            s(:send,
              s(:lvar, :copy), :text)),
          s(:send, nil, :assert_same,
            s(:send,
              s(:ivar, :@comment), :location),
            s(:send,
              s(:lvar, :copy), :location)))),
      s(:def, :test_location,
        s(:args),
        s(:send, nil, :assert_equal,
          s(:ivar, :@top_level),
          s(:send,
            s(:ivar, :@comment), :location))),
      s(:def, :test_normalize,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@comment), :text=,
            s(:str, "  # comment\n")),
          s(:send, nil, :assert_same,
            s(:ivar, :@comment),
            s(:send,
              s(:ivar, :@comment), :normalize)),
          s(:send, nil, :assert_equal,
            s(:str, "comment"),
            s(:send,
              s(:ivar, :@comment), :text)))),
      s(:def, :test_normalize_twice,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@comment), :text=,
            s(:str, "  # comment\n")),
          s(:send,
            s(:ivar, :@comment), :normalize),
          s(:lvasgn, :text,
            s(:send,
              s(:ivar, :@comment), :text)),
          s(:send,
            s(:ivar, :@comment), :normalize),
          s(:send, nil, :assert_same,
            s(:lvar, :text),
            s(:send,
              s(:ivar, :@comment), :text),
            s(:str, "normalize not cached")))),
      s(:def, :test_normalize_document,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@comment), :text=,
            s(:nil)),
          s(:send,
            s(:ivar, :@comment), :document=,
            s(:send,
              s(:const,
                s(:ivar, :@RM), :Document), :new)),
          s(:send, nil, :assert_same,
            s(:ivar, :@comment),
            s(:send,
              s(:ivar, :@comment), :normalize)),
          s(:send, nil, :assert_nil,
            s(:send,
              s(:ivar, :@comment), :text)))),
      s(:def, :test_normalize_eh,
        s(:args),
        s(:begin,
          s(:send, nil, :refute,
            s(:send,
              s(:ivar, :@comment), :normalized?)),
          s(:send,
            s(:ivar, :@comment), :normalize),
          s(:send, nil, :assert,
            s(:send,
              s(:ivar, :@comment), :normalized?)))),
      s(:def, :test_text,
        s(:args),
        s(:send, nil, :assert_equal,
          s(:str, "this is a comment"),
          s(:send,
            s(:ivar, :@comment), :text))),
      s(:def, :test_text_equals,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@comment), :text=,
            s(:str, "other")),
          s(:send, nil, :assert_equal,
            s(:str, "other"),
            s(:send,
              s(:ivar, :@comment), :text)),
          s(:send, nil, :refute,
            s(:send,
              s(:ivar, :@comment), :normalized?)))),
      s(:def, :test_text_equals_no_text,
        s(:args),
        s(:begin,
          s(:lvasgn, :c,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:nil),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :c), :document=,
            s(:send,
              s(:const,
                s(:ivar, :@RM), :Document), :new)),
          s(:lvasgn, :e,
            s(:block,
              s(:send, nil, :assert_raises,
                s(:const,
                  s(:const, nil, :RDoc), :Error)),
              s(:args),
              s(:send,
                s(:lvar, :c), :text=,
                s(:str, "other")))),
          s(:send, nil, :assert_equal,
            s(:str, "replacing document-only comment is not allowed"),
            s(:send,
              s(:lvar, :e), :message)))),
      s(:def, :test_text_equals_parsed,
        s(:args),
        s(:begin,
          s(:lvasgn, :document,
            s(:send,
              s(:ivar, :@comment), :parse)),
          s(:send,
            s(:ivar, :@comment), :text=,
            s(:str, "other")),
          s(:send, nil, :refute_equal,
            s(:lvar, :document),
            s(:send,
              s(:ivar, :@comment), :parse)))),
      s(:def, :test_tomdoc_eh,
        s(:args),
        s(:begin,
          s(:send, nil, :refute,
            s(:send,
              s(:ivar, :@comment), :tomdoc?)),
          s(:send,
            s(:ivar, :@comment), :format=,
            s(:str, "tomdoc")),
          s(:send, nil, :assert,
            s(:send,
              s(:ivar, :@comment), :tomdoc?)))),
      s(:def, :test_parse,
        s(:args),
        s(:begin,
          s(:lvasgn, :parsed,
            s(:send,
              s(:ivar, :@comment), :parse)),
          s(:lvasgn, :expected,
            s(:send,
              s(:const,
                s(:ivar, :@RM), :Document), :new,
              s(:send,
                s(:const,
                  s(:ivar, :@RM), :Paragraph), :new,
                s(:str, "this is a comment")))),
          s(:send,
            s(:lvar, :expected), :file=,
            s(:ivar, :@top_level)),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:lvar, :parsed)),
          s(:send, nil, :assert_same,
            s(:lvar, :parsed),
            s(:send,
              s(:ivar, :@comment), :parse)))),
      s(:def, :test_parse_rd,
        s(:args),
        s(:begin,
          s(:lvasgn, :c,
            s(:send, nil, :comment,
              s(:str, "it ((*works*))"))),
          s(:send,
            s(:lvar, :c), :format=,
            s(:str, "rd")),
          s(:lvasgn, :expected,
            s(:send,
              s(:const,
                s(:ivar, :@RM), :Document), :new,
              s(:send,
                s(:const,
                  s(:ivar, :@RM), :Paragraph), :new,
                s(:str, "it <em>works</em>")))),
          s(:send,
            s(:lvar, :expected), :file=,
            s(:ivar, :@top_level)),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:send,
              s(:lvar, :c), :parse)))),
      s(:def, :test_remove_private_encoding,
        s(:args),
        s(:begin,
          s(:if,
            s(:send,
              s(:const, nil, :Object), :const_defined?,
              s(:sym, :Encoding)), nil,
            s(:send, nil, :skip,
              s(:str, "Encoding not implemented"))),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "# This is text\n"),
                s(:str, "#--\n"),
                s(:str, "# this is private\n")),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :comment), :force_encoding,
            s(:const,
              s(:const, nil, :Encoding), :IBM437)),
          s(:send,
            s(:lvar, :comment), :remove_private),
          s(:send, nil, :assert_equal,
            s(:const,
              s(:const, nil, :Encoding), :IBM437),
            s(:send,
              s(:send,
                s(:lvar, :comment), :text), :encoding)))),
      s(:def, :test_remove_private_hash,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@comment), :text=,
            s(:dstr,
              s(:str, "#--\n"),
              s(:str, "# private\n"),
              s(:str, "#++\n"),
              s(:str, "# public\n"))),
          s(:send,
            s(:ivar, :@comment), :remove_private),
          s(:send, nil, :assert_equal,
            s(:str, "# public\n"),
            s(:send,
              s(:ivar, :@comment), :text)))),
      s(:def, :test_remove_private_hash_trail,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "# This is text\n"),
                s(:str, "#--\n"),
                s(:str, "# this is private\n")),
              s(:ivar, :@top_level))),
          s(:lvasgn, :expected,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "# This is text\n"),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :comment), :remove_private),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:lvar, :comment)))),
      s(:def, :test_remove_private_long,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "#-----\n"),
                s(:str, "#++\n"),
                s(:str, "# this is text\n"),
                s(:str, "#-----\n")),
              s(:ivar, :@top_level))),
          s(:lvasgn, :expected,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:str, "# this is text\n"),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :comment), :remove_private),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:lvar, :comment)))),
      s(:def, :test_remove_private_rule,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "# This is text with a rule:\n"),
                s(:str, "# ---\n"),
                s(:str, "# this is also text\n")),
              s(:ivar, :@top_level))),
          s(:lvasgn, :expected,
            s(:send,
              s(:lvar, :comment), :dup)),
          s(:send,
            s(:lvar, :comment), :remove_private),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:lvar, :comment)))),
      s(:def, :test_remove_private_star,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@comment), :text=,
            s(:dstr,
              s(:str, "/*\n"),
              s(:str, " *--\n"),
              s(:str, " * private\n"),
              s(:str, " *++\n"),
              s(:str, " * public\n"),
              s(:str, " */\n"))),
          s(:send,
            s(:ivar, :@comment), :remove_private),
          s(:send, nil, :assert_equal,
            s(:str, "/*\n * public\n */\n"),
            s(:send,
              s(:ivar, :@comment), :text)))),
      s(:def, :test_remove_private_star2,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@comment), :text=,
            s(:dstr,
              s(:str, "/*--\n"),
              s(:str, " * private\n"),
              s(:str, " *++\n"),
              s(:str, " * public\n"),
              s(:str, " */\n"))),
          s(:send,
            s(:ivar, :@comment), :remove_private),
          s(:send, nil, :assert_equal,
            s(:str, "/*--\n * private\n *++\n * public\n */\n"),
            s(:send,
              s(:ivar, :@comment), :text)))),
      s(:def, :test_remove_private_toggle,
        s(:args),
        s(:begin,
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "# This is text\n"),
                s(:str, "#--\n"),
                s(:str, "# this is private\n"),
                s(:str, "#++\n"),
                s(:str, "# This is text again.\n")),
              s(:ivar, :@top_level))),
          s(:lvasgn, :expected,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "# This is text\n"),
                s(:str, "# This is text again.\n")),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :comment), :remove_private),
          s(:send, nil, :assert_equal,
            s(:lvar, :expected),
            s(:lvar, :comment)))),
      s(:def, :test_remove_private_toggle_encoding,
        s(:args),
        s(:begin,
          s(:if,
            s(:send,
              s(:const, nil, :Object), :const_defined?,
              s(:sym, :Encoding)), nil,
            s(:send, nil, :skip,
              s(:str, "Encoding not implemented"))),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "# This is text\n"),
                s(:str, "#--\n"),
                s(:str, "# this is private\n"),
                s(:str, "#++\n"),
                s(:str, "# This is text again.\n")),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :comment), :force_encoding,
            s(:const,
              s(:const, nil, :Encoding), :IBM437)),
          s(:send,
            s(:lvar, :comment), :remove_private),
          s(:send, nil, :assert_equal,
            s(:const,
              s(:const, nil, :Encoding), :IBM437),
            s(:send,
              s(:send,
                s(:lvar, :comment), :text), :encoding)))),
      s(:def, :test_remove_private_toggle_encoding_ruby_bug?,
        s(:args),
        s(:begin,
          s(:if,
            s(:send,
              s(:const, nil, :Object), :const_defined?,
              s(:sym, :Encoding)), nil,
            s(:send, nil, :skip,
              s(:str, "Encoding not implemented"))),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:dstr,
                s(:str, "#--\n"),
                s(:str, "# this is private\n"),
                s(:str, "#++\n"),
                s(:str, "# This is text again.\n")),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :comment), :force_encoding,
            s(:const,
              s(:const, nil, :Encoding), :IBM437)),
          s(:send,
            s(:lvar, :comment), :remove_private),
          s(:send, nil, :assert_equal,
            s(:const,
              s(:const, nil, :Encoding), :IBM437),
            s(:send,
              s(:send,
                s(:lvar, :comment), :text), :encoding)))))))
