s(:begin,
  s(:send, nil, :require,
    s(:str, "test/unit")),
  s(:send, nil, :require,
    s(:str, "tempfile")),
  s(:class,
    s(:const, nil, :TestISeq),
    s(:const,
      s(:const,
        s(:const, nil, :Test), :Unit), :TestCase),
    s(:begin,
      s(:casgn, nil, :ISeq,
        s(:const,
          s(:const, nil, :RubyVM), :InstructionSequence)),
      s(:def, :test_no_linenum,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug5894,
            s(:str, "[ruby-dev:45130]")),
          s(:send, nil, :assert_normal_exit,
            s(:str, "p RubyVM::InstructionSequence.compile(\"1\", \"mac\", \"\", 0).to_a"),
            s(:lvar, :bug5894)))),
      s(:def, :compile,
        s(:args,
          s(:arg, :src),
          s(:optarg, :line,
            s(:nil)),
          s(:optarg, :opt,
            s(:nil))),
        s(:send,
          s(:const,
            s(:const, nil, :RubyVM), :InstructionSequence), :new,
          s(:lvar, :src),
          s(:str, "(string)"),
          s(:str, "(string)"),
          s(:lvar, :line),
          s(:lvar, :opt))),
      s(:def, :lines,
        s(:args,
          s(:arg, :src)),
        s(:begin,
          s(:lvasgn, :body,
            s(:send,
              s(:send,
                s(:send, nil, :compile,
                  s(:lvar, :src)), :to_a), :[],
              s(:int, 13))),
          s(:block,
            s(:send,
              s(:lvar, :body), :find_all),
            s(:args,
              s(:arg, :e)),
            s(:send,
              s(:lvar, :e), :kind_of?,
              s(:const, nil, :Fixnum))))),
      s(:def, :test_to_a_lines,
        s(:args),
        s(:begin,
          s(:lvasgn, :src,
            s(:dstr,
              s(:str, "    p __LINE__ # 1\n"),
              s(:str, "    p __LINE__ # 2\n"),
              s(:str, "               # 3\n"),
              s(:str, "    p __LINE__ # 4\n"))),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:int, 1),
              s(:int, 2),
              s(:int, 4)),
            s(:send, nil, :lines,
              s(:lvar, :src))),
          s(:lvasgn, :src,
            s(:dstr,
              s(:str, "               # 1\n"),
              s(:str, "    p __LINE__ # 2\n"),
              s(:str, "               # 3\n"),
              s(:str, "    p __LINE__ # 4\n"),
              s(:str, "               # 5\n"))),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:int, 2),
              s(:int, 4)),
            s(:send, nil, :lines,
              s(:lvar, :src))),
          s(:lvasgn, :src,
            s(:dstr,
              s(:str, "    1 # should be optimized out\n"),
              s(:str, "    2 # should be optimized out\n"),
              s(:str, "    p __LINE__ # 3\n"),
              s(:str, "    p __LINE__ # 4\n"),
              s(:str, "    5 # should be optimized out\n"),
              s(:str, "    6 # should be optimized out\n"),
              s(:str, "    p __LINE__ # 7\n"),
              s(:str, "    8 # should be optimized out\n"),
              s(:str, "    9\n"))),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:int, 3),
              s(:int, 4),
              s(:int, 7),
              s(:int, 9)),
            s(:send, nil, :lines,
              s(:lvar, :src))))),
      s(:if,
        s(:defined?,
          s(:send,
            s(:const,
              s(:const, nil, :RubyVM), :InstructionSequence), :load)),
        s(:def, :test_unsupport_type,
          s(:args),
          s(:begin,
            s(:lvasgn, :ary,
              s(:send,
                s(:send,
                  s(:const,
                    s(:const, nil, :RubyVM), :InstructionSequence), :compile,
                  s(:str, "p")), :to_a)),
            s(:send,
              s(:lvar, :ary), :[]=,
              s(:int, 9),
              s(:sym, :foobar)),
            s(:block,
              s(:send, nil, :assert_raise_with_message,
                s(:const, nil, :TypeError),
                s(:regexp,
                  s(:str, ":foobar"),
                  s(:regopt))),
              s(:args),
              s(:send,
                s(:const,
                  s(:const, nil, :RubyVM), :InstructionSequence), :load,
                s(:lvar, :ary))))), nil),
      s(:if,
        s(:defined?,
          s(:send,
            s(:const,
              s(:const, nil, :RubyVM), :InstructionSequence), :load)),
        s(:def, :test_loaded_cdhash_mark,
          s(:args),
          s(:begin,
            s(:lvasgn, :iseq,
              s(:send, nil, :compile,
                s(:dstr,
                  s(:str, "      def bug(kw)\n"),
                  s(:str, "        case kw\n"),
                  s(:str, "        when \"false\" then false\n"),
                  s(:str, "        when \"true\"  then true\n"),
                  s(:str, "        when \"nil\"   then nil\n"),
                  s(:str, "        else raise(\"unhandled argument: \#{kw.inspect}\")\n"),
                  s(:str, "        end\n"),
                  s(:str, "      end\n")),
                s(:send,
                  s(:int, 60), :+,
                  s(:int, 1)))),
            s(:send, nil, :assert_separately,
              s(:array),
              s(:dstr,
                s(:str, "      iseq = "),
                s(:begin,
                  s(:send,
                    s(:send,
                      s(:lvar, :iseq), :to_a), :inspect)),
                s(:str, "\n"),
                s(:str, "      RubyVM::InstructionSequence.load(iseq).eval\n"),
                s(:str, "      assert_equal(false, bug(\"false\"))\n"),
                s(:str, "      GC.start\n"),
                s(:str, "      assert_equal(false, bug(\"false\"))\n"))))), nil),
      s(:def, :test_disasm_encoding,
        s(:args),
        s(:begin,
          s(:lvasgn, :src,
            s(:str, "あ = 1; あ; ぃ")),
          s(:lvasgn, :asm,
            s(:send,
              s(:send, nil, :compile,
                s(:lvar, :src)), :disasm)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:lvar, :src), :encoding),
            s(:send,
              s(:lvar, :asm), :encoding)),
          s(:send, nil, :assert_predicate,
            s(:lvar, :asm),
            s(:sym, :valid_encoding?)),
          s(:send,
            s(:lvar, :src), :encode!,
            s(:const,
              s(:const, nil, :Encoding), :Shift_JIS)),
          s(:lvasgn, :asm,
            s(:send,
              s(:send, nil, :compile,
                s(:lvar, :src)), :disasm)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:lvar, :src), :encoding),
            s(:send,
              s(:lvar, :asm), :encoding)),
          s(:send, nil, :assert_predicate,
            s(:lvar, :asm),
            s(:sym, :valid_encoding?)))),
      s(:casgn, nil, :LINE_BEFORE_METHOD,
        s(:int, 90)),
      s(:def, :method_test_line_trace,
        s(:args),
        s(:begin,
          s(:lvasgn, :a,
            s(:int, 1)),
          s(:lvasgn, :b,
            s(:int, 2)))),
      s(:if,
        s(:false),
        s(:def, :test_line_trace,
          s(:args),
          s(:begin,
            s(:lvasgn, :iseq,
              s(:send,
                s(:const, nil, :ISeq), :compile,
                s(:dstr,
                  s(:str, " a = 1\n"),
                  s(:str, "      b = 2\n"),
                  s(:str, "      c = 3\n"),
                  s(:str, "      # d = 4\n"),
                  s(:str, "      e = 5\n"),
                  s(:str, "      # f = 6\n"),
                  s(:str, "      g = 7\n"),
                  s(:str, "\n"),
                  s(:str, "    ")))),
            s(:send, nil, :assert_equal,
              s(:array,
                s(:int, 1),
                s(:int, 2),
                s(:int, 3),
                s(:int, 5),
                s(:int, 7)),
              s(:send,
                s(:lvar, :iseq), :line_trace_all)),
            s(:send,
              s(:lvar, :iseq), :line_trace_specify,
              s(:int, 1),
              s(:true)),
            s(:send,
              s(:lvar, :iseq), :line_trace_specify,
              s(:int, 3),
              s(:true)),
            s(:lvasgn, :result,
              s(:array)),
            s(:block,
              s(:send,
                s(:block,
                  s(:send,
                    s(:const, nil, :TracePoint), :new,
                    s(:sym, :specified_line)),
                  s(:args,
                    s(:arg, :tp)),
                  s(:send,
                    s(:lvar, :result), :<<,
                    s(:send,
                      s(:lvar, :tp), :lineno))), :enable),
              s(:args),
              s(:send,
                s(:lvar, :iseq), :eval)),
            s(:send, nil, :assert_equal,
              s(:array,
                s(:int, 2),
                s(:int, 5)),
              s(:lvar, :result)),
            s(:lvasgn, :iseq,
              s(:send,
                s(:const, nil, :ISeq), :of,
                s(:send,
                  s(:send,
                    s(:self), :class), :instance_method,
                  s(:sym, :method_test_line_trace)))),
            s(:send, nil, :assert_equal,
              s(:array,
                s(:send,
                  s(:const, nil, :LINE_BEFORE_METHOD), :+,
                  s(:int, 3)),
                s(:send,
                  s(:const, nil, :LINE_BEFORE_METHOD), :+,
                  s(:int, 5))),
              s(:send,
                s(:lvar, :iseq), :line_trace_all)))), nil),
      s(:casgn, nil, :LINE_OF_HERE,
        s(:int, 126)),
      s(:def, :test_location,
        s(:args),
        s(:begin,
          s(:lvasgn, :iseq,
            s(:send,
              s(:const, nil, :ISeq), :of,
              s(:send, nil, :method,
                s(:sym, :test_location)))),
          s(:send, nil, :assert_equal,
            s(:str, "(string)"),
            s(:send,
              s(:lvar, :iseq), :path)),
          s(:send, nil, :assert_match,
            s(:regexp,
              s(:begin,
                s(:str, "(string)")),
              s(:regopt)),
            s(:send,
              s(:lvar, :iseq), :absolute_path)),
          s(:send, nil, :assert_equal,
            s(:str, "test_location"),
            s(:send,
              s(:lvar, :iseq), :label)),
          s(:send, nil, :assert_equal,
            s(:str, "test_location"),
            s(:send,
              s(:lvar, :iseq), :base_label)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:const, nil, :LINE_OF_HERE), :+,
              s(:int, 1)),
            s(:send,
              s(:lvar, :iseq), :first_lineno)),
          s(:lvasgn, :line,
            s(:int, 136)),
          s(:lvasgn, :iseq,
            s(:send,
              s(:const, nil, :ISeq), :of,
              s(:block,
                s(:send,
                  s(:const, nil, :Proc), :new),
                s(:args), nil))),
          s(:send, nil, :assert_equal,
            s(:str, "(string)"),
            s(:send,
              s(:lvar, :iseq), :path)),
          s(:send, nil, :assert_match,
            s(:regexp,
              s(:begin,
                s(:str, "(string)")),
              s(:regopt)),
            s(:send,
              s(:lvar, :iseq), :absolute_path)),
          s(:send, nil, :assert_equal,
            s(:str, "test_location"),
            s(:send,
              s(:lvar, :iseq), :base_label)),
          s(:send, nil, :assert_equal,
            s(:str, "block in test_location"),
            s(:send,
              s(:lvar, :iseq), :label)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:lvar, :line), :+,
              s(:int, 1)),
            s(:send,
              s(:lvar, :iseq), :first_lineno)))),
      s(:def, :test_label_fstring,
        s(:args),
        s(:begin,
          s(:lvasgn, :c,
            s(:block,
              s(:send,
                s(:const, nil, :Class), :new),
              s(:args),
              s(:def, :foobar,
                s(:args), nil))),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :a),
              s(:lvasgn, :b)),
            s(:array,
              s(:send, nil, :eval,
                s(:str, "# encoding: us-ascii\n'foobar'.freeze")),
              s(:send,
                s(:send,
                  s(:const, nil, :ISeq), :of,
                  s(:send,
                    s(:lvar, :c), :instance_method,
                    s(:sym, :foobar))), :label))),
          s(:send, nil, :assert_same,
            s(:lvar, :a),
            s(:lvar, :b)))),
      s(:def, :test_disable_opt,
        s(:args),
        s(:begin,
          s(:lvasgn, :src,
            s(:str, "a['foo'] = a['bar']; 'a'.freeze")),
          s(:lvasgn, :body,
            s(:send,
              s(:send,
                s(:send, nil, :compile,
                  s(:lvar, :src),
                  s(:int, 155),
                  s(:false)), :to_a), :[],
              s(:int, 13))),
          s(:block,
            s(:send,
              s(:lvar, :body), :each),
            s(:args,
              s(:arg, :insn)),
            s(:begin,
              s(:if,
                s(:send,
                  s(:const, nil, :Array), :===,
                  s(:lvar, :insn)), nil,
                s(:next)),
              s(:lvasgn, :op,
                s(:send,
                  s(:lvar, :insn), :first)),
              s(:send, nil, :assert,
                s(:send,
                  s(:send,
                    s(:send,
                      s(:lvar, :op), :to_s), :match,
                    s(:regexp,
                      s(:str, "^opt_"),
                      s(:regopt))), :!),
                s(:dstr,
                  s(:begin,
                    s(:lvar, :op)))))))),
      s(:def, :test_invalid_source,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug11159,
            s(:str, "[ruby-core:69219] [Bug #11159]")),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :TypeError),
              s(:lvar, :bug11159)),
            s(:args),
            s(:send,
              s(:const, nil, :ISeq), :compile,
              s(:nil))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :TypeError),
              s(:lvar, :bug11159)),
            s(:args),
            s(:send,
              s(:const, nil, :ISeq), :compile,
              s(:sym, :foo))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :TypeError),
              s(:lvar, :bug11159)),
            s(:args),
            s(:send,
              s(:const, nil, :ISeq), :compile,
              s(:int, 1))))),
      s(:def, :test_frozen_string_literal_compile_option,
        s(:args),
        s(:begin,
          s(:gvasgn, :$f,
            s(:str, "f")),
          s(:lvasgn, :line,
            s(:send,
              s(:int, 172), :+,
              s(:int, 2))),
          s(:lvasgn, :code,
            s(:str, "    ['foo', 'foo', \"\#{$f}foo\", \"\#{'foo'}\"]\n")),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :s1),
              s(:lvasgn, :s2),
              s(:lvasgn, :s3),
              s(:lvasgn, :s4)),
            s(:send,
              s(:send, nil, :compile,
                s(:lvar, :code),
                s(:lvar, :line),
                s(:hash,
                  s(:pair,
                    s(:sym, :frozen_string_literal),
                    s(:true)))), :eval)),
          s(:send, nil, :assert_predicate,
            s(:lvar, :s1),
            s(:sym, :frozen?)),
          s(:send, nil, :assert_predicate,
            s(:lvar, :s2),
            s(:sym, :frozen?)),
          s(:send, nil, :assert_predicate,
            s(:lvar, :s3),
            s(:sym, :frozen?)),
          s(:send, nil, :assert_predicate,
            s(:lvar, :s4),
            s(:sym, :frozen?)))),
      s(:def, :test_safe_call_chain,
        s(:args),
        s(:begin,
          s(:lvasgn, :src,
            s(:str, "a&.a&.a&.a&.a&.a")),
          s(:lvasgn, :body,
            s(:send,
              s(:send,
                s(:send, nil, :compile,
                  s(:lvar, :src),
                  s(:int, 185),
                  s(:hash,
                    s(:pair,
                      s(:sym, :peephole_optimization),
                      s(:true)))), :to_a), :[],
              s(:int, 13))),
          s(:lvasgn, :labels,
            s(:block,
              s(:send,
                s(:block,
                  s(:send,
                    s(:lvar, :body), :select),
                  s(:args,
                    s(:arg, :op),
                    s(:arg, :arg)),
                  s(:send,
                    s(:lvar, :op), :==,
                    s(:sym, :branchnil))), :map),
              s(:args,
                s(:arg, :op),
                s(:arg, :arg)),
              s(:lvar, :arg))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:send,
                s(:lvar, :labels), :uniq), :size)))),
      s(:def, :test_parent_iseq_mark,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "      ->{\n"),
            s(:str, "        ->{\n"),
            s(:str, "          ->{\n"),
            s(:str, "            eval <<-EOS\n"),
            s(:str, "              class Segfault\n"),
            s(:str, "                define_method :segfault do\n"),
            s(:str, "                  x = nil\n"),
            s(:str, "                  GC.disable\n"),
            s(:str, "                  1000.times do |n|\n"),
            s(:str, "                    n.times do\n"),
            s(:str, "                      x = (foo rescue $!).local_variables\n"),
            s(:str, "                    end\n"),
            s(:str, "                    GC.start\n"),
            s(:str, "                  end\n"),
            s(:str, "                  x\n"),
            s(:str, "                end\n"),
            s(:str, "              end\n"),
            s(:str, "            EOS\n"),
            s(:str, "          }.call\n"),
            s(:str, "        }.call\n"),
            s(:str, "      }.call\n"),
            s(:str, "      at_exit { assert_equal([:n, :x], Segfault.new.segfault.sort) }\n")),
          s(:hash,
            s(:pair,
              s(:sym, :timeout),
              s(:int, 20))))),
      s(:def, :test_compile_file_error,
        s(:args),
        s(:block,
          s(:send,
            s(:const, nil, :Tempfile), :create,
            s(:array,
              s(:str, "test_iseq"),
              s(:str, ".rb"))),
          s(:args,
            s(:arg, :f)),
          s(:begin,
            s(:send,
              s(:lvar, :f), :puts,
              s(:str, "end")),
            s(:send,
              s(:lvar, :f), :close),
            s(:lvasgn, :path,
              s(:send,
                s(:lvar, :f), :path)),
            s(:send, nil, :assert_in_out_err,
              s(:array,
                s(:str, "-"),
                s(:dstr,
                  s(:begin,
                    s(:lvar, :path)))),
              s(:dstr,
                s(:begin,
                  s(:dstr)),
                s(:str, "\n"),
                s(:begin,
                  s(:dstr,
                    s(:str, "        path = ARGV[0]\n"),
                    s(:str, "        begin\n"),
                    s(:str, "          RubyVM::InstructionSequence.compile_file(path)\n"),
                    s(:str, "        rescue SyntaxError => e\n"),
                    s(:str, "          puts e.message\n"),
                    s(:str, "        end\n")))),
              s(:regexp,
                s(:str, "compile error"),
                s(:regopt)),
              s(:regexp,
                s(:str, "keyword_end"),
                s(:regopt)),
              s(:hash,
                s(:pair,
                  s(:sym, :success),
                  s(:true))))))))))
