s(:begin,
  s(:send, nil, :require,
    s(:str, "test/unit")),
  s(:send, nil, :require,
    s(:str, "thread")),
  s(:class,
    s(:const, nil, :TestThread),
    s(:const,
      s(:const,
        s(:const, nil, :Test), :Unit), :TestCase),
    s(:begin,
      s(:class,
        s(:const, nil, :Thread),
        s(:const,
          s(:cbase), :Thread),
        s(:begin,
          s(:casgn, nil, :Threads,
            s(:array)),
          s(:defs,
            s(:self), :new,
            s(:args,
              s(:restarg)),
            s(:begin,
              s(:lvasgn, :th,
                s(:zsuper)),
              s(:send,
                s(:const, nil, :Threads), :<<,
                s(:lvar, :th)),
              s(:lvar, :th))))),
      s(:def, :setup,
        s(:args),
        s(:send,
          s(:const,
            s(:const, nil, :Thread), :Threads), :clear)),
      s(:def, :teardown,
        s(:args),
        s(:block,
          s(:send,
            s(:const,
              s(:const, nil, :Thread), :Threads), :each),
          s(:args,
            s(:arg, :t)),
          s(:begin,
            s(:if,
              s(:send,
                s(:lvar, :t), :alive?),
              s(:send,
                s(:lvar, :t), :kill), nil),
            s(:kwbegin,
              s(:rescue,
                s(:send,
                  s(:lvar, :t), :join),
                s(:resbody,
                  s(:array,
                    s(:const, nil, :Exception)), nil, nil), nil))))),
      s(:def, :test_inspect,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:lvasgn, :th,
              s(:block,
                s(:send,
                  s(:block,
                    s(:send,
                      s(:const, nil, :Module), :new),
                    s(:args),
                    s(:break,
                      s(:send, nil, :module_eval,
                        s(:str, "class Cスレッド < Thread; self; end")))), :start),
                s(:args), nil)),
            s(:send, nil, :assert_match,
              s(:regexp,
                s(:str, "::C\\u{30b9 30ec 30c3 30c9}:"),
                s(:regopt)),
              s(:send,
                s(:lvar, :th), :inspect))),
          s(:send,
            s(:lvar, :th), :join))),
      s(:def, :test_main_thread_variable_in_enumerator,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:send,
              s(:const, nil, :Thread), :main),
            s(:send,
              s(:const, nil, :Thread), :current)),
          s(:send,
            s(:send,
              s(:const, nil, :Thread), :current), :thread_variable_set,
            s(:sym, :foo),
            s(:str, "bar")),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :thread),
              s(:lvasgn, :value)),
            s(:send,
              s(:block,
                s(:send,
                  s(:const, nil, :Fiber), :new),
                s(:args),
                s(:send,
                  s(:const, nil, :Fiber), :yield,
                  s(:array,
                    s(:send,
                      s(:const, nil, :Thread), :current),
                    s(:send,
                      s(:send,
                        s(:const, nil, :Thread), :current), :thread_variable_get,
                      s(:sym, :foo))))), :resume)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:const, nil, :Thread), :current),
            s(:lvar, :thread)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:send,
                s(:const, nil, :Thread), :current), :thread_variable_get,
              s(:sym, :foo)),
            s(:lvar, :value)))),
      s(:def, :test_thread_variable_in_enumerator,
        s(:args),
        s(:send,
          s(:block,
            s(:send,
              s(:const, nil, :Thread), :new),
            s(:args),
            s(:begin,
              s(:send,
                s(:send,
                  s(:const, nil, :Thread), :current), :thread_variable_set,
                s(:sym, :foo),
                s(:str, "bar")),
              s(:masgn,
                s(:mlhs,
                  s(:lvasgn, :thread),
                  s(:lvasgn, :value)),
                s(:send,
                  s(:block,
                    s(:send,
                      s(:const, nil, :Fiber), :new),
                    s(:args),
                    s(:send,
                      s(:const, nil, :Fiber), :yield,
                      s(:array,
                        s(:send,
                          s(:const, nil, :Thread), :current),
                        s(:send,
                          s(:send,
                            s(:const, nil, :Thread), :current), :thread_variable_get,
                          s(:sym, :foo))))), :resume)),
              s(:send, nil, :assert_equal,
                s(:send,
                  s(:const, nil, :Thread), :current),
                s(:lvar, :thread)),
              s(:send, nil, :assert_equal,
                s(:send,
                  s(:send,
                    s(:const, nil, :Thread), :current), :thread_variable_get,
                  s(:sym, :foo)),
                s(:lvar, :value)))), :join)),
      s(:def, :test_thread_variables,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:array),
            s(:send,
              s(:send,
                s(:block,
                  s(:send,
                    s(:const, nil, :Thread), :new),
                  s(:args),
                  s(:send,
                    s(:send,
                      s(:const, nil, :Thread), :current), :thread_variables)), :join), :value)),
          s(:lvasgn, :t,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args),
              s(:begin,
                s(:send,
                  s(:send,
                    s(:const, nil, :Thread), :current), :thread_variable_set,
                  s(:sym, :foo),
                  s(:str, "bar")),
                s(:send,
                  s(:send,
                    s(:const, nil, :Thread), :current), :thread_variables)))),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:sym, :foo)),
            s(:send,
              s(:send,
                s(:lvar, :t), :join), :value)))),
      s(:def, :test_thread_variable?,
        s(:args),
        s(:begin,
          s(:send,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args),
              s(:send, nil, :assert_not_send,
                s(:array,
                  s(:send,
                    s(:const, nil, :Thread), :current),
                  s(:sym, :thread_variable?),
                  s(:str, "foo")))), :value),
          s(:lvasgn, :t,
            s(:send,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:send,
                  s(:send,
                    s(:const, nil, :Thread), :current), :thread_variable_set,
                  s(:str, "foo"),
                  s(:str, "bar"))), :join)),
          s(:send, nil, :assert_send,
            s(:array,
              s(:lvar, :t),
              s(:sym, :thread_variable?),
              s(:str, "foo"))),
          s(:send, nil, :assert_send,
            s(:array,
              s(:lvar, :t),
              s(:sym, :thread_variable?),
              s(:sym, :foo))),
          s(:send, nil, :assert_not_send,
            s(:array,
              s(:lvar, :t),
              s(:sym, :thread_variable?),
              s(:sym, :bar))))),
      s(:def, :test_thread_variable_strings_and_symbols_are_the_same_key,
        s(:args),
        s(:begin,
          s(:lvasgn, :t,
            s(:send,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args), nil), :join)),
          s(:send,
            s(:lvar, :t), :thread_variable_set,
            s(:str, "foo"),
            s(:str, "bar")),
          s(:send, nil, :assert_equal,
            s(:str, "bar"),
            s(:send,
              s(:lvar, :t), :thread_variable_get,
              s(:sym, :foo))))),
      s(:def, :test_thread_variable_frozen,
        s(:args),
        s(:begin,
          s(:lvasgn, :t,
            s(:send,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args), nil), :join)),
          s(:send,
            s(:lvar, :t), :freeze),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :RuntimeError)),
            s(:args),
            s(:send,
              s(:lvar, :t), :thread_variable_set,
              s(:sym, :foo),
              s(:str, "bar"))))),
      s(:def, :test_mutex_synchronize,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const, nil, :Mutex), :new)),
          s(:lvasgn, :r,
            s(:int, 0)),
          s(:lvasgn, :num_threads,
            s(:int, 10)),
          s(:lvasgn, :loop,
            s(:int, 100)),
          s(:block,
            s(:send,
              s(:block,
                s(:send,
                  s(:begin,
                    s(:irange,
                      s(:int, 1),
                      s(:lvar, :num_threads))), :map),
                s(:args),
                s(:block,
                  s(:send,
                    s(:const, nil, :Thread), :new),
                  s(:args),
                  s(:block,
                    s(:send,
                      s(:lvar, :loop), :times),
                    s(:args),
                    s(:block,
                      s(:send,
                        s(:lvar, :m), :synchronize),
                      s(:args),
                      s(:begin,
                        s(:lvasgn, :tmp,
                          s(:lvar, :r)),
                        s(:block,
                          s(:send,
                            s(:int, 100), :times),
                          s(:args), nil),
                        s(:lvasgn, :r,
                          s(:send,
                            s(:lvar, :tmp), :+,
                            s(:int, 1)))))))), :each),
            s(:args,
              s(:arg, :e)),
            s(:send,
              s(:lvar, :e), :join)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:lvar, :num_threads), :*,
              s(:lvar, :loop)),
            s(:lvar, :r)))),
      s(:def, :test_mutex_synchronize_yields_no_block_params,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug8097,
            s(:str, "[ruby-core:53424] [Bug #8097]")),
          s(:send, nil, :assert_empty,
            s(:block,
              s(:send,
                s(:send,
                  s(:const, nil, :Mutex), :new), :synchronize),
              s(:args,
                s(:restarg, :params)),
              s(:break,
                s(:lvar, :params))),
            s(:lvar, :bug8097)))),
      s(:def, :test_local_barrier,
        s(:args),
        s(:begin,
          s(:lvasgn, :dir,
            s(:send,
              s(:const, nil, :File), :dirname,
              s(:str, "(string)"))),
          s(:lvasgn, :lbtest,
            s(:send,
              s(:const, nil, :File), :join,
              s(:lvar, :dir),
              s(:str, "lbtest.rb"))),
          s(:send,
            s(:gvar, :$:), :unshift,
            s(:send,
              s(:const, nil, :File), :join,
              s(:send,
                s(:const, nil, :File), :dirname,
                s(:lvar, :dir)),
              s(:str, "ruby"))),
          s(:send,
            s(:gvar, :$:), :shift),
          s(:block,
            s(:send,
              s(:int, 3), :times),
            s(:args),
            s(:begin,
              s(:xstr,
                s(:begin,
                  s(:send,
                    s(:const, nil, :EnvUtil), :rubybin)),
                s(:str, " "),
                s(:begin,
                  s(:lvar, :lbtest))),
              s(:send, nil, :assert_not_predicate,
                s(:gvar, :$?),
                s(:sym, :coredump?),
                s(:str, "[ruby-dev:30653]")))))),
      s(:def, :test_priority,
        s(:args),
        s(:begin,
          s(:lvasgn, :c1,
            s(:lvasgn, :c2,
              s(:int, 0))),
          s(:lvasgn, :run,
            s(:true)),
          s(:lvasgn, :t1,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args),
              s(:while,
                s(:lvar, :run),
                s(:op_asgn,
                  s(:lvasgn, :c1), :+,
                  s(:int, 1))))),
          s(:send,
            s(:lvar, :t1), :priority=,
            s(:int, 3)),
          s(:lvasgn, :t2,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args),
              s(:while,
                s(:lvar, :run),
                s(:op_asgn,
                  s(:lvasgn, :c2), :+,
                  s(:int, 1))))),
          s(:send,
            s(:lvar, :t2), :priority=,
            s(:int, -3)),
          s(:send, nil, :assert_equal,
            s(:int, 3),
            s(:send,
              s(:lvar, :t1), :priority)),
          s(:send, nil, :assert_equal,
            s(:int, -3),
            s(:send,
              s(:lvar, :t2), :priority)),
          s(:send, nil, :sleep,
            s(:float, 0.5)),
          s(:block,
            s(:send,
              s(:int, 5), :times),
            s(:args),
            s(:begin,
              s(:send, nil, :assert_not_predicate,
                s(:lvar, :t1),
                s(:sym, :stop?)),
              s(:send, nil, :assert_not_predicate,
                s(:lvar, :t2),
                s(:sym, :stop?)),
              s(:if,
                s(:send,
                  s(:lvar, :c1), :>,
                  s(:lvar, :c2)),
                s(:break), nil),
              s(:send, nil, :sleep,
                s(:float, 0.1)))),
          s(:lvasgn, :run,
            s(:false)),
          s(:send,
            s(:lvar, :t1), :kill),
          s(:send,
            s(:lvar, :t2), :kill),
          s(:send, nil, :assert_operator,
            s(:lvar, :c1),
            s(:sym, :>),
            s(:lvar, :c2),
            s(:str, "[ruby-dev:33124]")))),
      s(:def, :test_new,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:block,
              s(:send, nil, :assert_raise,
                s(:const, nil, :ThreadError)),
              s(:args),
              s(:send,
                s(:const, nil, :Thread), :new)),
            s(:lvasgn, :t1,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:send, nil, :sleep))),
            s(:block,
              s(:send, nil, :assert_raise,
                s(:const, nil, :ThreadError)),
              s(:args),
              s(:block,
                s(:send,
                  s(:lvar, :t1), :instance_eval),
                s(:args),
                s(:block,
                  s(:send, nil, :initialize),
                  s(:args), nil))),
            s(:lvasgn, :t2,
              s(:send,
                s(:const, nil, :Thread), :new,
                s(:block_pass,
                  s(:send,
                    s(:send, nil, :method,
                      s(:sym, :sleep)), :to_proc)))),
            s(:block,
              s(:send, nil, :assert_raise,
                s(:const, nil, :ThreadError)),
              s(:args),
              s(:block,
                s(:send,
                  s(:lvar, :t2), :instance_eval),
                s(:args),
                s(:block,
                  s(:send, nil, :initialize),
                  s(:args), nil)))),
          s(:begin,
            s(:if,
              s(:lvar, :t1),
              s(:send,
                s(:lvar, :t1), :kill), nil),
            s(:if,
              s(:lvar, :t2),
              s(:send,
                s(:lvar, :t2), :kill), nil)))),
      s(:def, :test_join,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:lvasgn, :t,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:send, nil, :sleep))),
            s(:send, nil, :assert_nil,
              s(:send,
                s(:lvar, :t), :join,
                s(:float, 0.05)))),
          s(:if,
            s(:lvar, :t),
            s(:send,
              s(:lvar, :t), :kill), nil))),
      s(:def, :test_join2,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:lvasgn, :ok,
              s(:false)),
            s(:lvasgn, :t1,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:begin,
                  s(:lvasgn, :ok,
                    s(:true)),
                  s(:send, nil, :sleep)))),
            s(:until,
              s(:lvar, :ok),
              s(:send,
                s(:const, nil, :Thread), :pass)),
            s(:until,
              s(:send,
                s(:lvar, :t1), :stop?),
              s(:send,
                s(:const, nil, :Thread), :pass)),
            s(:lvasgn, :t2,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:begin,
                  s(:while,
                    s(:lvar, :ok),
                    s(:send,
                      s(:const, nil, :Thread), :pass)),
                  s(:send,
                    s(:lvar, :t1), :join,
                    s(:float, 0.01))))),
            s(:lvasgn, :t3,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:begin,
                  s(:lvasgn, :ok,
                    s(:false)),
                  s(:send,
                    s(:lvar, :t1), :join)))),
            s(:send, nil, :assert_nil,
              s(:send,
                s(:lvar, :t2), :value)),
            s(:send,
              s(:lvar, :t1), :wakeup),
            s(:send, nil, :assert_equal,
              s(:lvar, :t1),
              s(:send,
                s(:lvar, :t3), :value))),
          s(:begin,
            s(:if,
              s(:lvar, :t1),
              s(:send,
                s(:lvar, :t1), :kill), nil),
            s(:if,
              s(:lvar, :t2),
              s(:send,
                s(:lvar, :t2), :kill), nil),
            s(:if,
              s(:lvar, :t3),
              s(:send,
                s(:lvar, :t3), :kill), nil)))),
      s(:def, :test_kill_main_thread,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      p 1\n"),
            s(:str, "      Thread.kill Thread.current\n"),
            s(:str, "      p 2\n")),
          s(:array,
            s(:str, "1")),
          s(:array))),
      s(:def, :test_kill_wrong_argument,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug4367,
            s(:str, "[ruby-core:35086]")),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :TypeError),
              s(:lvar, :bug4367)),
            s(:args),
            s(:send,
              s(:const, nil, :Thread), :kill,
              s(:nil))),
          s(:lvasgn, :o,
            s(:send,
              s(:const, nil, :Object), :new)),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :TypeError),
              s(:lvar, :bug4367)),
            s(:args),
            s(:send,
              s(:const, nil, :Thread), :kill,
              s(:lvar, :o))))),
      s(:def, :test_kill_thread_subclass,
        s(:args),
        s(:begin,
          s(:lvasgn, :c,
            s(:send,
              s(:const, nil, :Class), :new,
              s(:const, nil, :Thread))),
          s(:lvasgn, :t,
            s(:block,
              s(:send,
                s(:lvar, :c), :new),
              s(:args),
              s(:send, nil, :sleep,
                s(:int, 10)))),
          s(:block,
            s(:send, nil, :assert_nothing_raised),
            s(:args),
            s(:send,
              s(:const, nil, :Thread), :kill,
              s(:lvar, :t))),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :t), :value)))),
      s(:def, :test_exit,
        s(:args),
        s(:begin,
          s(:lvasgn, :s,
            s(:int, 0)),
          s(:send,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args),
              s(:begin,
                s(:op_asgn,
                  s(:lvasgn, :s), :+,
                  s(:int, 1)),
                s(:send,
                  s(:const, nil, :Thread), :exit),
                s(:op_asgn,
                  s(:lvasgn, :s), :+,
                  s(:int, 2)))), :join),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:lvar, :s)))),
      s(:def, :test_wakeup,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:lvasgn, :s,
              s(:int, 0)),
            s(:lvasgn, :t,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:begin,
                  s(:op_asgn,
                    s(:lvasgn, :s), :+,
                    s(:int, 1)),
                  s(:send,
                    s(:const, nil, :Thread), :stop),
                  s(:op_asgn,
                    s(:lvasgn, :s), :+,
                    s(:int, 1))))),
            s(:until,
              s(:send,
                s(:lvar, :t), :stop?),
              s(:send,
                s(:const, nil, :Thread), :pass)),
            s(:send, nil, :assert_equal,
              s(:int, 1),
              s(:lvar, :s)),
            s(:send,
              s(:lvar, :t), :wakeup),
            s(:while,
              s(:send,
                s(:lvar, :t), :alive?),
              s(:send,
                s(:const, nil, :Thread), :pass)),
            s(:send, nil, :assert_equal,
              s(:int, 2),
              s(:lvar, :s)),
            s(:block,
              s(:send, nil, :assert_raise,
                s(:const, nil, :ThreadError)),
              s(:args),
              s(:send,
                s(:lvar, :t), :wakeup))),
          s(:if,
            s(:lvar, :t),
            s(:send,
              s(:lvar, :t), :kill), nil))),
      s(:def, :test_stop,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      begin\n"),
            s(:str, "        Thread.stop\n"),
            s(:str, "        p 1\n"),
            s(:str, "      rescue ThreadError\n"),
            s(:str, "        p 2\n"),
            s(:str, "      end\n")),
          s(:array,
            s(:str, "2")),
          s(:array))),
      s(:def, :test_list,
        s(:args),
        s(:block,
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:dstr,
              s(:str, "      t1 = Thread.new { sleep }\n"),
              s(:str, "      Thread.pass\n"),
              s(:str, "      t2 = Thread.new { loop { Thread.pass } }\n"),
              s(:str, "      Thread.new { }.join\n"),
              s(:str, "      p [Thread.current, t1, t2].map{|t| t.object_id }.sort\n"),
              s(:str, "      p Thread.list.map{|t| t.object_id }.sort\n"))),
          s(:args,
            s(:arg, :r),
            s(:arg, :e)),
          s(:begin,
            s(:send, nil, :assert_equal,
              s(:send,
                s(:lvar, :r), :first),
              s(:send,
                s(:lvar, :r), :last)),
            s(:send, nil, :assert_equal,
              s(:array),
              s(:lvar, :e))))),
      s(:def, :test_main,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      p Thread.main == Thread.current\n"),
            s(:str, "      Thread.new { p Thread.main == Thread.current }.join\n")),
          s(:array,
            s(:str, "true"),
            s(:str, "false")),
          s(:array))),
      s(:def, :test_abort_on_exception,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:dstr,
              s(:str, "      p Thread.abort_on_exception\n"),
              s(:str, "      begin\n"),
              s(:str, "        t = Thread.new { raise }\n"),
              s(:str, "        Thread.pass until t.stop?\n"),
              s(:str, "        p 1\n"),
              s(:str, "      rescue\n"),
              s(:str, "        p 2\n"),
              s(:str, "      end\n")),
            s(:array,
              s(:str, "false"),
              s(:str, "1")),
            s(:array)),
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:dstr,
              s(:str, "      Thread.abort_on_exception = true\n"),
              s(:str, "      p Thread.abort_on_exception\n"),
              s(:str, "      begin\n"),
              s(:str, "        Thread.new { raise }\n"),
              s(:str, "        sleep 0.5\n"),
              s(:str, "        p 1\n"),
              s(:str, "      rescue\n"),
              s(:str, "        p 2\n"),
              s(:str, "      end\n")),
            s(:array,
              s(:str, "true"),
              s(:str, "2")),
            s(:array)),
          s(:send, nil, :assert_in_out_err,
            s(:array,
              s(:str, "--disable-gems"),
              s(:str, "-d")),
            s(:dstr,
              s(:str, "      p Thread.abort_on_exception\n"),
              s(:str, "      begin\n"),
              s(:str, "        t = Thread.new { raise }\n"),
              s(:str, "        Thread.pass until t.stop?\n"),
              s(:str, "        p 1\n"),
              s(:str, "      rescue\n"),
              s(:str, "        p 2\n"),
              s(:str, "      end\n")),
            s(:array,
              s(:str, "false"),
              s(:str, "2")),
            s(:regexp,
              s(:str, ".+"),
              s(:regopt))),
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:dstr,
              s(:str, "      p Thread.abort_on_exception\n"),
              s(:str, "      begin\n"),
              s(:str, "        ok = false\n"),
              s(:str, "        t = Thread.new { Thread.pass until ok; raise }\n"),
              s(:str, "        t.abort_on_exception = true\n"),
              s(:str, "        p t.abort_on_exception\n"),
              s(:str, "        ok = 1\n"),
              s(:str, "        sleep 1\n"),
              s(:str, "        p 1\n"),
              s(:str, "      rescue\n"),
              s(:str, "        p 2\n"),
              s(:str, "      end\n")),
            s(:array,
              s(:str, "false"),
              s(:str, "true"),
              s(:str, "2")),
            s(:array)))),
      s(:def, :test_status_and_stop_p,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:lvasgn, :a,
              s(:block,
                s(:send,
                  s(:const,
                    s(:cbase), :Thread), :new),
                s(:args),
                s(:send, nil, :raise,
                  s(:str, "die now")))),
            s(:lvasgn, :b,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:send,
                  s(:const, nil, :Thread), :stop))),
            s(:lvasgn, :c,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:send,
                  s(:const, nil, :Thread), :exit))),
            s(:lvasgn, :e,
              s(:send,
                s(:const, nil, :Thread), :current)),
            s(:while,
              s(:or,
                s(:or,
                  s(:send,
                    s(:lvar, :a), :alive?),
                  s(:send,
                    s(:send,
                      s(:lvar, :b), :stop?), :!)),
                s(:send,
                  s(:lvar, :c), :alive?)),
              s(:send,
                s(:const, nil, :Thread), :pass)),
            s(:send, nil, :assert_equal,
              s(:nil),
              s(:send,
                s(:lvar, :a), :status)),
            s(:send, nil, :assert_predicate,
              s(:lvar, :a),
              s(:sym, :stop?)),
            s(:send, nil, :assert_equal,
              s(:str, "sleep"),
              s(:send,
                s(:lvar, :b), :status)),
            s(:send, nil, :assert_predicate,
              s(:lvar, :b),
              s(:sym, :stop?)),
            s(:send, nil, :assert_equal,
              s(:false),
              s(:send,
                s(:lvar, :c), :status)),
            s(:send, nil, :assert_match,
              s(:regexp,
                s(:str, "^#<TestThread::Thread:.* dead>$"),
                s(:regopt)),
              s(:send,
                s(:lvar, :c), :inspect)),
            s(:send, nil, :assert_predicate,
              s(:lvar, :c),
              s(:sym, :stop?)),
            s(:lvasgn, :es1,
              s(:send,
                s(:lvar, :e), :status)),
            s(:lvasgn, :es2,
              s(:send,
                s(:lvar, :e), :stop?)),
            s(:send, nil, :assert_equal,
              s(:array,
                s(:str, "run"),
                s(:false)),
              s(:array,
                s(:lvar, :es1),
                s(:lvar, :es2)))),
          s(:begin,
            s(:if,
              s(:lvar, :a),
              s(:send,
                s(:lvar, :a), :kill), nil),
            s(:if,
              s(:lvar, :b),
              s(:send,
                s(:lvar, :b), :kill), nil),
            s(:if,
              s(:lvar, :c),
              s(:send,
                s(:lvar, :c), :kill), nil)))),
      s(:def, :test_switch_while_busy_loop,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:lvasgn, :bug1402,
              s(:str, "[ruby-dev:38319] [Bug #1402]")),
            s(:lvasgn, :flag,
              s(:true)),
            s(:lvasgn, :th,
              s(:send,
                s(:const, nil, :Thread), :current)),
            s(:lvasgn, :waiter,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :start),
                s(:args),
                s(:begin,
                  s(:send, nil, :sleep,
                    s(:float, 0.1)),
                  s(:lvasgn, :flag,
                    s(:false)),
                  s(:send, nil, :sleep,
                    s(:int, 1)),
                  s(:send,
                    s(:lvar, :th), :raise,
                    s(:lvar, :bug1402))))),
            s(:block,
              s(:send, nil, :assert_nothing_raised,
                s(:const, nil, :RuntimeError),
                s(:lvar, :bug1402)),
              s(:args),
              s(:while,
                s(:lvar, :flag),
                s(:nil))),
            s(:send, nil, :assert,
              s(:send,
                s(:lvar, :flag), :!),
              s(:lvar, :bug1402))),
          s(:send,
            s(:send,
              s(:lvar, :waiter), :kill), :join))),
      s(:def, :test_safe_level,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:lvasgn, :ok,
              s(:false)),
            s(:lvasgn, :t,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:begin,
                  s(:block,
                    s(:send,
                      s(:const, nil, :EnvUtil), :suppress_warning),
                    s(:args),
                    s(:gvasgn, :$SAFE,
                      s(:int, 1))),
                  s(:lvasgn, :ok,
                    s(:true)),
                  s(:send, nil, :sleep)))),
            s(:until,
              s(:lvar, :ok),
              s(:send,
                s(:const, nil, :Thread), :pass)),
            s(:send, nil, :assert_equal,
              s(:int, 0),
              s(:send,
                s(:send,
                  s(:const, nil, :Thread), :current), :safe_level)),
            s(:send, nil, :assert_equal,
              s(:int, 1),
              s(:send,
                s(:lvar, :t), :safe_level))),
          s(:if,
            s(:lvar, :t),
            s(:send,
              s(:lvar, :t), :kill), nil))),
      s(:def, :test_thread_local,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:lvasgn, :t,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:send, nil, :sleep))),
            s(:send, nil, :assert_equal,
              s(:false),
              s(:send,
                s(:lvar, :t), :key?,
                s(:sym, :foo))),
            s(:send,
              s(:lvar, :t), :[]=,
              s(:str, "foo"),
              s(:str, "foo")),
            s(:send,
              s(:lvar, :t), :[]=,
              s(:str, "bar"),
              s(:str, "bar")),
            s(:send,
              s(:lvar, :t), :[]=,
              s(:str, "baz"),
              s(:str, "baz")),
            s(:send, nil, :assert_equal,
              s(:true),
              s(:send,
                s(:lvar, :t), :key?,
                s(:sym, :foo))),
            s(:send, nil, :assert_equal,
              s(:true),
              s(:send,
                s(:lvar, :t), :key?,
                s(:str, "foo"))),
            s(:send, nil, :assert_equal,
              s(:false),
              s(:send,
                s(:lvar, :t), :key?,
                s(:sym, :qux))),
            s(:send, nil, :assert_equal,
              s(:false),
              s(:send,
                s(:lvar, :t), :key?,
                s(:str, "qux"))),
            s(:send, nil, :assert_equal,
              s(:array,
                s(:sym, :foo),
                s(:sym, :bar),
                s(:sym, :baz)),
              s(:send,
                s(:lvar, :t), :keys))),
          s(:if,
            s(:lvar, :t),
            s(:send,
              s(:lvar, :t), :kill), nil))),
      s(:def, :test_thread_local_security,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :RuntimeError)),
          s(:args),
          s(:send,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args),
              s(:begin,
                s(:send,
                  s(:send,
                    s(:const, nil, :Thread), :current), :[]=,
                  s(:sym, :foo),
                  s(:sym, :bar)),
                s(:send,
                  s(:send,
                    s(:const, nil, :Thread), :current), :freeze),
                s(:send,
                  s(:send,
                    s(:const, nil, :Thread), :current), :[]=,
                  s(:sym, :foo),
                  s(:sym, :baz)))), :join))),
      s(:def, :test_thread_local_dynamic_symbol,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug10667,
            s(:str, "[ruby-core:67185] [Bug #10667]")),
          s(:lvasgn, :t,
            s(:send,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args), nil), :join)),
          s(:lvasgn, :key_str,
            s(:dstr,
              s(:str, "foo"),
              s(:begin,
                s(:send, nil, :rand)))),
          s(:lvasgn, :key_sym,
            s(:send,
              s(:lvar, :key_str), :to_sym)),
          s(:send,
            s(:lvar, :t), :thread_variable_set,
            s(:lvar, :key_str),
            s(:str, "bar")),
          s(:send, nil, :assert_equal,
            s(:str, "bar"),
            s(:send,
              s(:lvar, :t), :thread_variable_get,
              s(:lvar, :key_str)),
            s(:dstr,
              s(:begin,
                s(:lvar, :bug10667)),
              s(:str, ": string key"))),
          s(:send, nil, :assert_equal,
            s(:str, "bar"),
            s(:send,
              s(:lvar, :t), :thread_variable_get,
              s(:lvar, :key_sym)),
            s(:dstr,
              s(:begin,
                s(:lvar, :bug10667)),
              s(:str, ": symbol key"))))),
      s(:def, :test_select_wait,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_nil,
            s(:send,
              s(:const, nil, :IO), :select,
              s(:nil),
              s(:nil),
              s(:nil),
              s(:float, 0.001))),
          s(:lvasgn, :t,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args),
              s(:send,
                s(:const, nil, :IO), :select,
                s(:nil),
                s(:nil),
                s(:nil),
                s(:nil)))),
          s(:until,
            s(:send,
              s(:lvar, :t), :stop?),
            s(:send,
              s(:const, nil, :Thread), :pass)),
          s(:send, nil, :assert_predicate,
            s(:lvar, :t),
            s(:sym, :alive?)),
          s(:send,
            s(:lvar, :t), :kill))),
      s(:def, :test_mutex_deadlock,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const, nil, :Mutex), :new)),
          s(:block,
            s(:send,
              s(:lvar, :m), :synchronize),
            s(:args),
            s(:block,
              s(:send, nil, :assert_raise,
                s(:const, nil, :ThreadError)),
              s(:args),
              s(:block,
                s(:send,
                  s(:lvar, :m), :synchronize),
                s(:args),
                s(:send, nil, :assert,
                  s(:false))))))),
      s(:def, :test_mutex_interrupt,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const, nil, :Mutex), :new)),
          s(:send,
            s(:lvar, :m), :lock),
          s(:lvasgn, :t,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args),
              s(:begin,
                s(:send,
                  s(:lvar, :m), :lock),
                s(:sym, :foo)))),
          s(:until,
            s(:send,
              s(:lvar, :t), :stop?),
            s(:send,
              s(:const, nil, :Thread), :pass)),
          s(:send,
            s(:lvar, :t), :kill),
          s(:send, nil, :assert_nil,
            s(:send,
              s(:lvar, :t), :value)))),
      s(:def, :test_mutex_illegal_unlock,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const, nil, :Mutex), :new)),
          s(:send,
            s(:lvar, :m), :lock),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :ThreadError)),
            s(:args),
            s(:send,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:send,
                  s(:lvar, :m), :unlock)), :join)))),
      s(:def, :test_mutex_fifo_like_lock,
        s(:args),
        s(:begin,
          s(:lvasgn, :m1,
            s(:send,
              s(:const, nil, :Mutex), :new)),
          s(:lvasgn, :m2,
            s(:send,
              s(:const, nil, :Mutex), :new)),
          s(:send,
            s(:lvar, :m1), :lock),
          s(:send,
            s(:lvar, :m2), :lock),
          s(:send,
            s(:lvar, :m1), :unlock),
          s(:send,
            s(:lvar, :m2), :unlock),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :m1), :locked?)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :m2), :locked?)),
          s(:lvasgn, :m3,
            s(:send,
              s(:const, nil, :Mutex), :new)),
          s(:send,
            s(:lvar, :m1), :lock),
          s(:send,
            s(:lvar, :m2), :lock),
          s(:send,
            s(:lvar, :m3), :lock),
          s(:send,
            s(:lvar, :m1), :unlock),
          s(:send,
            s(:lvar, :m2), :unlock),
          s(:send,
            s(:lvar, :m3), :unlock),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :m1), :locked?)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :m2), :locked?)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :m3), :locked?)))),
      s(:def, :test_mutex_trylock,
        s(:args),
        s(:begin,
          s(:lvasgn, :m,
            s(:send,
              s(:const, nil, :Mutex), :new)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:lvar, :m), :try_lock)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:lvar, :m), :try_lock),
            s(:str, "[ruby-core:20943]")),
          s(:send,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args),
              s(:send, nil, :assert_equal,
                s(:false),
                s(:send,
                  s(:lvar, :m), :try_lock))), :join),
          s(:send,
            s(:lvar, :m), :unlock))),
      s(:def, :test_recursive_outer,
        s(:args),
        s(:begin,
          s(:lvasgn, :arr,
            s(:array)),
          s(:lvasgn, :obj,
            s(:send,
              s(:send,
                s(:const, nil, :Struct), :new,
                s(:sym, :foo),
                s(:sym, :visited)), :new,
              s(:lvar, :arr),
              s(:false))),
          s(:send,
            s(:lvar, :arr), :<<,
            s(:lvar, :obj)),
          s(:defs,
            s(:lvar, :obj), :hash,
            s(:args),
            s(:begin,
              s(:send,
                s(:self), :[]=,
                s(:sym, :visited),
                s(:true)),
              s(:zsuper),
              s(:send, nil, :raise,
                s(:str, "recursive_outer should short circuit intermediate calls")))),
          s(:block,
            s(:send, nil, :assert_nothing_raised),
            s(:args),
            s(:send,
              s(:lvar, :arr), :hash)),
          s(:send, nil, :assert,
            s(:send,
              s(:lvar, :obj), :[],
              s(:sym, :visited)),
            s(:str, "obj.hash was not called")))),
      s(:def, :test_thread_instance_variable,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug4389,
            s(:str, "[ruby-core:35192]")),
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:dstr,
              s(:str, "      class << Thread.current\n"),
              s(:str, "        @data = :data\n"),
              s(:str, "      end\n")),
            s(:array),
            s(:array),
            s(:lvar, :bug4389)))),
      s(:def, :test_no_valid_cfp,
        s(:args),
        s(:begin,
          s(:if,
            s(:defined?,
              s(:const, nil, :WIN32OLE)),
            s(:send, nil, :skip,
              s(:str, "with win32ole, cannot run this testcase because win32ole redefines Thread#intialize")), nil),
          s(:lvasgn, :bug5083,
            s(:str, "[ruby-dev:44208]")),
          s(:send, nil, :assert_equal,
            s(:array),
            s(:send,
              s(:send,
                s(:const, nil, :Thread), :new,
                s(:block_pass,
                  s(:send,
                    s(:const, nil, :Module), :method,
                    s(:sym, :nesting)))), :value),
            s(:lvar, :bug5083)),
          s(:send, nil, :assert_instance_of,
            s(:const, nil, :Thread),
            s(:send,
              s(:send,
                s(:const, nil, :Thread), :new,
                s(:sym, :to_s),
                s(:block_pass,
                  s(:send,
                    s(:send,
                      s(:const, nil, :Class), :new), :method,
                    s(:sym, :undef_method)))), :join),
            s(:lvar, :bug5083)))),
      s(:def, :make_handle_interrupt_test_thread1,
        s(:args,
          s(:arg, :flag)),
        s(:begin,
          s(:lvasgn, :r,
            s(:array)),
          s(:lvasgn, :ready_p,
            s(:false)),
          s(:lvasgn, :done,
            s(:false)),
          s(:lvasgn, :th,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args),
              s(:kwbegin,
                s(:rescue,
                  s(:block,
                    s(:send,
                      s(:const, nil, :Thread), :handle_interrupt,
                      s(:hash,
                        s(:pair,
                          s(:const, nil, :RuntimeError),
                          s(:lvar, :flag)))),
                    s(:args),
                    s(:kwbegin,
                      s(:rescue,
                        s(:begin,
                          s(:lvasgn, :ready_p,
                            s(:true)),
                          s(:until,
                            s(:lvar, :done),
                            s(:send, nil, :sleep,
                              s(:float, 0.01)))),
                        s(:resbody, nil, nil,
                          s(:send,
                            s(:lvar, :r), :<<,
                            s(:sym, :c1))), nil))),
                  s(:resbody, nil, nil,
                    s(:send,
                      s(:lvar, :r), :<<,
                      s(:sym, :c2))), nil)))),
          s(:until,
            s(:lvar, :ready_p),
            s(:send,
              s(:const, nil, :Thread), :pass)),
          s(:send,
            s(:lvar, :th), :raise),
          s(:kwbegin,
            s(:rescue,
              s(:begin,
                s(:lvasgn, :done,
                  s(:true)),
                s(:send,
                  s(:lvar, :th), :join)),
              s(:resbody, nil, nil,
                s(:send,
                  s(:lvar, :r), :<<,
                  s(:sym, :c3))), nil)),
          s(:lvar, :r))),
      s(:def, :test_handle_interrupt,
        s(:args),
        s(:block,
          s(:send,
            s(:array,
              s(:array,
                s(:sym, :never),
                s(:sym, :c2)),
              s(:array,
                s(:sym, :immediate),
                s(:sym, :c1)),
              s(:array,
                s(:sym, :on_blocking),
                s(:sym, :c1))), :each),
          s(:args,
            s(:mlhs,
              s(:arg, :flag),
              s(:arg, :c))),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:lvar, :flag),
              s(:lvar, :c)),
            s(:send,
              s(:array,
                s(:lvar, :flag)), :+,
              s(:send, nil, :make_handle_interrupt_test_thread1,
                s(:lvar, :flag)))))),
      s(:def, :test_handle_interrupt_invalid_argument,
        s(:args),
        s(:begin,
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :ArgumentError)),
            s(:args),
            s(:send,
              s(:const, nil, :Thread), :handle_interrupt,
              s(:hash,
                s(:pair,
                  s(:const, nil, :RuntimeError),
                  s(:sym, :immediate))))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :ArgumentError)),
            s(:args),
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :handle_interrupt,
                s(:hash,
                  s(:pair,
                    s(:const, nil, :RuntimeError),
                    s(:sym, :xyzzy)))),
              s(:args), nil)),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :TypeError)),
            s(:args),
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :handle_interrupt,
                s(:array)),
              s(:args), nil)))),
      s(:def, :for_test_handle_interrupt_with_return,
        s(:args),
        s(:rescue,
          s(:block,
            s(:send,
              s(:const, nil, :Thread), :handle_interrupt,
              s(:hash,
                s(:pair,
                  s(:const, nil, :Object),
                  s(:sym, :never)))),
            s(:args),
            s(:begin,
              s(:send,
                s(:send,
                  s(:const, nil, :Thread), :current), :raise,
                s(:send,
                  s(:const, nil, :RuntimeError), :new,
                  s(:str, "have to be rescured"))),
              s(:return))),
          s(:resbody, nil, nil, nil), nil)),
      s(:def, :test_handle_interrupt_with_return,
        s(:args),
        s(:block,
          s(:send, nil, :assert_nothing_raised),
          s(:args),
          s(:begin,
            s(:send, nil, :for_test_handle_interrupt_with_return),
            s(:lvasgn, :_dummy_for_check_ints,
              s(:nil))))),
      s(:def, :test_handle_interrupt_with_break,
        s(:args),
        s(:block,
          s(:send, nil, :assert_nothing_raised),
          s(:args),
          s(:begin,
            s(:kwbegin,
              s(:rescue,
                s(:block,
                  s(:send,
                    s(:const, nil, :Thread), :handle_interrupt,
                    s(:hash,
                      s(:pair,
                        s(:const, nil, :Object),
                        s(:sym, :never)))),
                  s(:args),
                  s(:begin,
                    s(:send,
                      s(:send,
                        s(:const, nil, :Thread), :current), :raise,
                      s(:send,
                        s(:const, nil, :RuntimeError), :new,
                        s(:str, "have to be rescured"))),
                    s(:break))),
                s(:resbody, nil, nil, nil), nil)),
            s(:lvasgn, :_dummy_for_check_ints,
              s(:nil))))),
      s(:def, :test_handle_interrupt_blocking,
        s(:args),
        s(:begin,
          s(:lvasgn, :r,
            s(:sym, :ng)),
          s(:lvasgn, :e,
            s(:send,
              s(:const, nil, :Class), :new,
              s(:const, nil, :Exception))),
          s(:lvasgn, :th_s,
            s(:send,
              s(:const, nil, :Thread), :current)),
          s(:kwbegin,
            s(:ensure,
              s(:begin,
                s(:lvasgn, :th,
                  s(:block,
                    s(:send,
                      s(:const, nil, :Thread), :start),
                    s(:args),
                    s(:block,
                      s(:send,
                        s(:const, nil, :Thread), :handle_interrupt,
                        s(:hash,
                          s(:pair,
                            s(:const, nil, :Object),
                            s(:sym, :on_blocking)))),
                      s(:args),
                      s(:kwbegin,
                        s(:ensure,
                          s(:begin,
                            s(:until,
                              s(:send,
                                s(:lvar, :r), :==,
                                s(:sym, :wait)),
                              s(:send,
                                s(:const, nil, :Thread), :pass)),
                            s(:send,
                              s(:send,
                                s(:const, nil, :Thread), :current), :raise,
                              s(:const, nil, :RuntimeError)),
                            s(:lvasgn, :r,
                              s(:sym, :ok)),
                            s(:send, nil, :sleep)),
                          s(:send,
                            s(:lvar, :th_s), :raise,
                            s(:lvar, :e),
                            s(:str, "raise from ensure"),
                            s(:gvar, :$@))))))),
                s(:block,
                  s(:send, nil, :assert_raise,
                    s(:lvar, :e)),
                  s(:args),
                  s(:begin,
                    s(:lvasgn, :r,
                      s(:sym, :wait)),
                    s(:send, nil, :sleep,
                      s(:float, 0.2)))),
                s(:block,
                  s(:send, nil, :assert_raise,
                    s(:const, nil, :RuntimeError)),
                  s(:args),
                  s(:send,
                    s(:lvar, :th), :join,
                    s(:float, 0.2)))),
              s(:send,
                s(:lvar, :th), :kill))),
          s(:send, nil, :assert_equal,
            s(:sym, :ok),
            s(:lvar, :r)))),
      s(:def, :test_handle_interrupt_and_io,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      th_waiting = true\n"),
            s(:str, "\n"),
            s(:str, "      t = Thread.new {\n"),
            s(:str, "        Thread.handle_interrupt(RuntimeError => :on_blocking) {\n"),
            s(:str, "          nil while th_waiting\n"),
            s(:str, "          # async interrupt should be raised _before_ writing puts arguments\n"),
            s(:str, "          puts \"ng\"\n"),
            s(:str, "        }\n"),
            s(:str, "      }\n"),
            s(:str, "\n"),
            s(:str, "      Thread.pass while t.stop?\n"),
            s(:str, "      t.raise RuntimeError\n"),
            s(:str, "      th_waiting = false\n"),
            s(:str, "      t.join rescue nil\n"),
            s(:str, "      puts \"ok\"\n")),
          s(:array,
            s(:str, "ok")),
          s(:array))),
      s(:def, :test_handle_interrupt_and_p,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      th_waiting = false\n"),
            s(:str, "\n"),
            s(:str, "      t = Thread.new {\n"),
            s(:str, "        Thread.handle_interrupt(RuntimeError => :on_blocking) {\n"),
            s(:str, "          th_waiting = true\n"),
            s(:str, "          nil while th_waiting\n"),
            s(:str, "          # p shouldn't provide interruptible point\n"),
            s(:str, "          p :ok\n"),
            s(:str, "          p :ok\n"),
            s(:str, "        }\n"),
            s(:str, "      }\n"),
            s(:str, "\n"),
            s(:str, "      Thread.pass until th_waiting\n"),
            s(:str, "      t.raise RuntimeError\n"),
            s(:str, "      th_waiting = false\n"),
            s(:str, "      t.join rescue nil\n")),
          s(:array,
            s(:str, ":ok"),
            s(:str, ":ok")),
          s(:array))),
      s(:def, :test_handle_interrupted?,
        s(:args),
        s(:begin,
          s(:lvasgn, :q,
            s(:send,
              s(:const, nil, :Queue), :new)),
          s(:block,
            s(:send,
              s(:const, nil, :Thread), :handle_interrupt,
              s(:hash,
                s(:pair,
                  s(:const, nil, :RuntimeError),
                  s(:sym, :never)))),
            s(:args),
            s(:begin,
              s(:lvasgn, :done,
                s(:false)),
              s(:lvasgn, :th,
                s(:block,
                  s(:send,
                    s(:const, nil, :Thread), :new),
                  s(:args),
                  s(:begin,
                    s(:send,
                      s(:lvar, :q), :push,
                      s(:sym, :e)),
                    s(:kwbegin,
                      s(:ensure,
                        s(:rescue,
                          s(:begin,
                            s(:kwbegin,
                              s(:rescue,
                                s(:until,
                                  s(:lvar, :done),
                                  s(:send,
                                    s(:const, nil, :Thread), :pass)),
                                s(:resbody, nil,
                                  s(:lvasgn, :e),
                                  s(:send,
                                    s(:lvar, :q), :push,
                                    s(:sym, :ng1))), nil)),
                            s(:kwbegin,
                              s(:rescue,
                                s(:if,
                                  s(:send,
                                    s(:const, nil, :Thread), :pending_interrupt?),
                                  s(:block,
                                    s(:send,
                                      s(:const, nil, :Thread), :handle_interrupt,
                                      s(:hash,
                                        s(:pair,
                                          s(:const, nil, :Object),
                                          s(:sym, :immediate)))),
                                    s(:args), nil), nil),
                                s(:resbody,
                                  s(:array,
                                    s(:const, nil, :RuntimeError)),
                                  s(:lvasgn, :e),
                                  s(:send,
                                    s(:lvar, :q), :push,
                                    s(:sym, :ok))), nil))),
                          s(:resbody, nil,
                            s(:lvasgn, :e),
                            s(:send,
                              s(:lvar, :q), :push,
                              s(:sym, :ng2))), nil),
                        s(:send,
                          s(:lvar, :q), :push,
                          s(:sym, :ng3))))))),
              s(:send,
                s(:lvar, :q), :pop),
              s(:send,
                s(:lvar, :th), :raise),
              s(:lvasgn, :done,
                s(:true)),
              s(:send,
                s(:lvar, :th), :join),
              s(:send, nil, :assert_equal,
                s(:sym, :ok),
                s(:send,
                  s(:lvar, :q), :pop)))))),
      s(:def, :test_thread_timer_and_ensure,
        s(:args),
        s(:send, nil, :assert_normal_exit,
          s(:dstr,
            s(:str, "    flag = false\n"),
            s(:str, "    t = Thread.new do\n"),
            s(:str, "      begin\n"),
            s(:str, "        sleep\n"),
            s(:str, "      ensure\n"),
            s(:str, "        1 until flag\n"),
            s(:str, "      end\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    Thread.pass until t.status == \"sleep\"\n"),
            s(:str, "\n"),
            s(:str, "    t.kill\n"),
            s(:str, "    t.alive? == true\n"),
            s(:str, "    flag = true\n"),
            s(:str, "    t.join\n")),
          s(:str, "r36492"),
          s(:hash,
            s(:pair,
              s(:sym, :timeout),
              s(:int, 3))))),
      s(:def, :test_uninitialized,
        s(:args),
        s(:begin,
          s(:lvasgn, :c,
            s(:block,
              s(:send,
                s(:const, nil, :Class), :new,
                s(:const, nil, :Thread)),
              s(:args),
              s(:def, :initialize,
                s(:args), nil))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :ThreadError)),
            s(:args),
            s(:send,
              s(:send,
                s(:lvar, :c), :new), :start)),
          s(:lvasgn, :bug11959,
            s(:str, "[ruby-core:72732] [Bug #11959]")),
          s(:lvasgn, :c,
            s(:block,
              s(:send,
                s(:const, nil, :Class), :new,
                s(:const, nil, :Thread)),
              s(:args),
              s(:def, :initialize,
                s(:args),
                s(:send, nil, :exit)))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :ThreadError),
              s(:lvar, :bug11959)),
            s(:args),
            s(:send,
              s(:lvar, :c), :new)),
          s(:lvasgn, :c,
            s(:block,
              s(:send,
                s(:const, nil, :Class), :new,
                s(:const, nil, :Thread)),
              s(:args),
              s(:def, :initialize,
                s(:args),
                s(:send, nil, :raise)))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :ThreadError),
              s(:lvar, :bug11959)),
            s(:args),
            s(:send,
              s(:lvar, :c), :new)),
          s(:lvasgn, :c,
            s(:block,
              s(:send,
                s(:const, nil, :Class), :new,
                s(:const, nil, :Thread)),
              s(:args),
              s(:def, :initialize,
                s(:args),
                s(:begin,
                  s(:lvasgn, :pending,
                    s(:send, nil, :pending_interrupt?)),
                  s(:block,
                    s(:zsuper),
                    s(:args),
                    s(:lvar, :pending)))))),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:send,
                s(:lvar, :c), :new), :value),
            s(:lvar, :bug11959)))),
      s(:def, :test_backtrace,
        s(:args),
        s(:begin,
          s(:send,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args),
              s(:send, nil, :assert_equal,
                s(:const, nil, :Array),
                s(:send,
                  s(:send,
                    s(:send,
                      s(:const, nil, :Thread), :main), :backtrace), :class))), :join),
          s(:lvasgn, :t,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args), nil)),
          s(:send,
            s(:lvar, :t), :join),
          s(:send, nil, :assert_equal,
            s(:nil),
            s(:send,
              s(:lvar, :t), :backtrace)))),
      s(:def, :test_thread_timer_and_interrupt,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug5757,
            s(:str, "[ruby-dev:44985]")),
          s(:lvasgn, :t0,
            s(:send,
              s(:send,
                s(:const, nil, :Time), :now), :to_f)),
          s(:lvasgn, :pid,
            s(:nil)),
          s(:lvasgn, :cmd,
            s(:str, "Signal.trap(:INT, \"DEFAULT\"); r,=IO.pipe; Thread.start {Thread.pass until Thread.main.stop?; puts; STDOUT.flush}; r.read")),
          s(:lvasgn, :opt,
            s(:hash)),
          s(:if,
            s(:match_with_lvasgn,
              s(:regexp,
                s(:str, "mswin|mingw"),
                s(:regopt)),
              s(:const, nil, :RUBY_PLATFORM)),
            s(:send,
              s(:lvar, :opt), :[]=,
              s(:sym, :new_pgroup),
              s(:true)), nil),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :s),
              s(:lvasgn, :_err)),
            s(:block,
              s(:send,
                s(:const, nil, :EnvUtil), :invoke_ruby,
                s(:array,
                  s(:str, "-e"),
                  s(:lvar, :cmd)),
                s(:str, ""),
                s(:true),
                s(:true),
                s(:lvar, :opt)),
              s(:args,
                s(:arg, :in_p),
                s(:arg, :out_p),
                s(:arg, :err_p),
                s(:arg, :cpid)),
              s(:begin,
                s(:send,
                  s(:lvar, :out_p), :gets),
                s(:lvasgn, :pid,
                  s(:lvar, :cpid)),
                s(:send,
                  s(:const, nil, :Process), :kill,
                  s(:sym, :SIGINT),
                  s(:lvar, :pid)),
                s(:send,
                  s(:const, nil, :Process), :wait,
                  s(:lvar, :pid)),
                s(:array,
                  s(:gvar, :$?),
                  s(:send,
                    s(:lvar, :err_p), :read))))),
          s(:lvasgn, :t1,
            s(:send,
              s(:send,
                s(:const, nil, :Time), :now), :to_f)),
          s(:send, nil, :assert_equal,
            s(:lvar, :pid),
            s(:send,
              s(:lvar, :s), :pid),
            s(:lvar, :bug5757)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:false),
              s(:true),
              s(:false),
              s(:send,
                s(:send,
                  s(:const, nil, :Signal), :list), :[],
                s(:str, "INT"))),
            s(:array,
              s(:send,
                s(:lvar, :s), :exited?),
              s(:send,
                s(:lvar, :s), :signaled?),
              s(:send,
                s(:lvar, :s), :stopped?),
              s(:send,
                s(:lvar, :s), :termsig)),
            s(:str, "[s.exited?, s.signaled?, s.stopped?, s.termsig]")),
          s(:send, nil, :assert_in_delta,
            s(:send,
              s(:lvar, :t1), :-,
              s(:lvar, :t0)),
            s(:int, 1),
            s(:int, 1),
            s(:lvar, :bug5757)))),
      s(:def, :test_thread_join_in_trap,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "    Signal.trap(:INT, \"DEFAULT\")\n"),
            s(:str, "    t0 = Thread.current\n"),
            s(:str, "    assert_nothing_raised{\n"),
            s(:str, "      t = Thread.new {Thread.pass until t0.stop?; Process.kill(:INT, $$)}\n"),
            s(:str, "\n"),
            s(:str, "      Signal.trap :INT do\n"),
            s(:str, "        t.join\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      t.join\n"),
            s(:str, "    }\n")))),
      s(:def, :test_thread_value_in_trap,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "    Signal.trap(:INT, \"DEFAULT\")\n"),
            s(:str, "    t0 = Thread.current\n"),
            s(:str, "    t = Thread.new {Thread.pass until t0.stop?; Process.kill(:INT, $$); :normal_end}\n"),
            s(:str, "\n"),
            s(:str, "    Signal.trap :INT do\n"),
            s(:str, "      t.value\n"),
            s(:str, "    end\n"),
            s(:str, "    assert_equal(:normal_end, t.value)\n")))),
      s(:def, :test_thread_join_current,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :ThreadError)),
          s(:args),
          s(:send,
            s(:send,
              s(:const, nil, :Thread), :current), :join))),
      s(:def, :test_thread_join_main_thread,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :ThreadError)),
          s(:args),
          s(:send,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new,
                s(:send,
                  s(:const, nil, :Thread), :current)),
              s(:args,
                s(:arg, :t)),
              s(:send,
                s(:lvar, :t), :join)), :join))),
      s(:def, :test_main_thread_status_at_exit,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "require 'thread'\n"),
            s(:str, "q = Queue.new\n"),
            s(:str, "Thread.new(Thread.current) {|mth|\n"),
            s(:str, "  begin\n"),
            s(:str, "    q.push nil\n"),
            s(:str, "    mth.run\n"),
            s(:str, "    Thread.pass until mth.stop?\n"),
            s(:str, "    p :mth_stopped # don't run if killed by rb_thread_terminate_all\n"),
            s(:str, "  ensure\n"),
            s(:str, "    puts \"\#{mth.alive?} \#{mth.status} \#{Thread.current.status}\"\n"),
            s(:str, "  end\n"),
            s(:str, "}\n"),
            s(:str, "q.pop\n")),
          s(:array,
            s(:str, "false false aborting")),
          s(:array))),
      s(:def, :test_thread_status_in_trap,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      Signal.trap(:INT) {\n"),
            s(:str, "        puts Thread.current.status\n"),
            s(:str, "        exit\n"),
            s(:str, "      }\n"),
            s(:str, "      t = Thread.current\n"),
            s(:str, "\n"),
            s(:str, "      Thread.new(Thread.current) {|mth|\n"),
            s(:str, "        Thread.pass until t.stop?\n"),
            s(:str, "        puts mth.status\n"),
            s(:str, "        Process.kill(:INT, $$)\n"),
            s(:str, "      }\n"),
            s(:str, "      sleep 0.1\n")),
          s(:array,
            s(:str, "sleep"),
            s(:str, "run")),
          s(:array))),
      s(:def, :test_thread_status_raise_after_kill,
        s(:args),
        s(:begin,
          s(:lvasgn, :ary,
            s(:array)),
          s(:lvasgn, :t,
            s(:block,
              s(:send,
                s(:const, nil, :Thread), :new),
              s(:args),
              s(:kwbegin,
                s(:ensure,
                  s(:begin,
                    s(:send,
                      s(:lvar, :ary), :<<,
                      s(:send,
                        s(:send,
                          s(:const, nil, :Thread), :current), :status)),
                    s(:send, nil, :sleep)),
                  s(:kwbegin,
                    s(:ensure,
                      s(:begin,
                        s(:send,
                          s(:lvar, :ary), :<<,
                          s(:send,
                            s(:send,
                              s(:const, nil, :Thread), :current), :status)),
                        s(:send, nil, :sleep)),
                      s(:send,
                        s(:lvar, :ary), :<<,
                        s(:send,
                          s(:send,
                            s(:const, nil, :Thread), :current), :status)))))))),
          s(:kwbegin,
            s(:ensure,
              s(:begin,
                s(:until,
                  s(:send,
                    s(:send,
                      s(:lvar, :ary), :size), :>=,
                    s(:int, 1)),
                  s(:send,
                    s(:const, nil, :Thread), :pass)),
                s(:until,
                  s(:send,
                    s(:lvar, :t), :stop?),
                  s(:send,
                    s(:const, nil, :Thread), :pass)),
                s(:send,
                  s(:lvar, :t), :kill),
                s(:until,
                  s(:send,
                    s(:send,
                      s(:lvar, :ary), :size), :>=,
                    s(:int, 2)),
                  s(:send,
                    s(:const, nil, :Thread), :pass)),
                s(:until,
                  s(:send,
                    s(:lvar, :t), :stop?),
                  s(:send,
                    s(:const, nil, :Thread), :pass)),
                s(:send,
                  s(:lvar, :t), :raise,
                  s(:str, "wakeup")),
                s(:while,
                  s(:send,
                    s(:lvar, :t), :alive?),
                  s(:send,
                    s(:const, nil, :Thread), :pass)),
                s(:send, nil, :assert_equal,
                  s(:lvar, :ary),
                  s(:array,
                    s(:str, "run"),
                    s(:str, "aborting"),
                    s(:str, "aborting")))),
              s(:rescue,
                s(:send,
                  s(:lvar, :t), :join),
                s(:resbody, nil, nil,
                  s(:nil)), nil))))),
      s(:def, :test_mutex_owned,
        s(:args),
        s(:begin,
          s(:lvasgn, :mutex,
            s(:send,
              s(:const, nil, :Mutex), :new)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:lvar, :mutex), :owned?),
            s(:false)),
          s(:block,
            s(:send,
              s(:lvar, :mutex), :synchronize),
            s(:args),
            s(:send, nil, :assert_equal,
              s(:send,
                s(:lvar, :mutex), :owned?),
              s(:true))),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:lvar, :mutex), :owned?),
            s(:false)))),
      s(:def, :test_mutex_owned2,
        s(:args),
        s(:kwbegin,
          s(:ensure,
            s(:begin,
              s(:lvasgn, :mutex,
                s(:send,
                  s(:const, nil, :Mutex), :new)),
              s(:lvasgn, :th,
                s(:block,
                  s(:send,
                    s(:const, nil, :Thread), :new),
                  s(:args),
                  s(:begin,
                    s(:send,
                      s(:lvar, :mutex), :lock),
                    s(:send, nil, :sleep)))),
              s(:until,
                s(:send,
                  s(:lvar, :mutex), :locked?),
                s(:send,
                  s(:const, nil, :Thread), :pass)),
              s(:send, nil, :assert_equal,
                s(:send,
                  s(:lvar, :mutex), :owned?),
                s(:false))),
            s(:if,
              s(:lvar, :th),
              s(:send,
                s(:lvar, :th), :kill), nil)))),
      s(:def, :test_mutex_unlock_on_trap,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      m = Mutex.new\n"),
            s(:str, "\n"),
            s(:str, "      trapped = false\n"),
            s(:str, "      Signal.trap(\"INT\") { |signo|\n"),
            s(:str, "        m.unlock\n"),
            s(:str, "        trapped = true\n"),
            s(:str, "        puts \"unlocked\"\n"),
            s(:str, "      }\n"),
            s(:str, "\n"),
            s(:str, "      m.lock\n"),
            s(:str, "      puts \"locked\"\n"),
            s(:str, "      Process.kill(\"INT\", $$)\n"),
            s(:str, "      Thread.pass until trapped\n"),
            s(:str, "      puts m.locked?\n")),
          s(:array,
            s(:str, "locked"),
            s(:str, "unlocked"),
            s(:str, "false")),
          s(:array))),
      s(:def, :invoke_rec,
        s(:args,
          s(:arg, :script),
          s(:arg, :vm_stack_size),
          s(:arg, :machine_stack_size),
          s(:optarg, :use_length,
            s(:true))),
        s(:begin,
          s(:lvasgn, :env,
            s(:hash)),
          s(:if,
            s(:lvar, :vm_stack_size),
            s(:send,
              s(:lvar, :env), :[]=,
              s(:str, "RUBY_THREAD_VM_STACK_SIZE"),
              s(:send,
                s(:lvar, :vm_stack_size), :to_s)), nil),
          s(:if,
            s(:lvar, :machine_stack_size),
            s(:send,
              s(:lvar, :env), :[]=,
              s(:str, "RUBY_THREAD_MACHINE_STACK_SIZE"),
              s(:send,
                s(:lvar, :machine_stack_size), :to_s)), nil),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :out)),
            s(:send,
              s(:const, nil, :EnvUtil), :invoke_ruby,
              s(:array,
                s(:lvar, :env),
                s(:str, "-e"),
                s(:lvar, :script)),
              s(:str, ""),
              s(:true),
              s(:true))),
          s(:if,
            s(:lvar, :use_length),
            s(:send,
              s(:lvar, :out), :length),
            s(:lvar, :out)))),
      s(:def, :test_stack_size,
        s(:args),
        s(:begin,
          s(:lvasgn, :h_default,
            s(:send, nil, :eval,
              s(:send, nil, :invoke_rec,
                s(:str, "p RubyVM::DEFAULT_PARAMS"),
                s(:nil),
                s(:nil),
                s(:false)))),
          s(:lvasgn, :h_0,
            s(:send, nil, :eval,
              s(:send, nil, :invoke_rec,
                s(:str, "p RubyVM::DEFAULT_PARAMS"),
                s(:int, 0),
                s(:int, 0),
                s(:false)))),
          s(:lvasgn, :h_large,
            s(:send, nil, :eval,
              s(:send, nil, :invoke_rec,
                s(:str, "p RubyVM::DEFAULT_PARAMS"),
                s(:send,
                  s(:send,
                    s(:int, 1024), :*,
                    s(:int, 1024)), :*,
                  s(:int, 10)),
                s(:send,
                  s(:send,
                    s(:int, 1024), :*,
                    s(:int, 1024)), :*,
                  s(:int, 10)),
                s(:false)))),
          s(:send, nil, :assert_operator,
            s(:send,
              s(:lvar, :h_default), :[],
              s(:sym, :thread_vm_stack_size)),
            s(:sym, :>),
            s(:send,
              s(:lvar, :h_0), :[],
              s(:sym, :thread_vm_stack_size)),
            s(:str, "0 thread_vm_stack_size")),
          s(:send, nil, :assert_operator,
            s(:send,
              s(:lvar, :h_default), :[],
              s(:sym, :thread_vm_stack_size)),
            s(:sym, :<),
            s(:send,
              s(:lvar, :h_large), :[],
              s(:sym, :thread_vm_stack_size)),
            s(:str, "large thread_vm_stack_size")),
          s(:send, nil, :assert_operator,
            s(:send,
              s(:lvar, :h_default), :[],
              s(:sym, :thread_machine_stack_size)),
            s(:sym, :>=),
            s(:send,
              s(:lvar, :h_0), :[],
              s(:sym, :thread_machine_stack_size)),
            s(:str, "0 thread_machine_stack_size")),
          s(:send, nil, :assert_operator,
            s(:send,
              s(:lvar, :h_default), :[],
              s(:sym, :thread_machine_stack_size)),
            s(:sym, :<=),
            s(:send,
              s(:lvar, :h_large), :[],
              s(:sym, :thread_machine_stack_size)),
            s(:str, "large thread_machine_stack_size")))),
      s(:def, :test_vm_machine_stack_size,
        s(:args),
        s(:begin,
          s(:lvasgn, :script,
            s(:str, "def rec; print \".\"; STDOUT.flush; rec; end; rec")),
          s(:lvasgn, :size_default,
            s(:send, nil, :invoke_rec,
              s(:lvar, :script),
              s(:nil),
              s(:nil))),
          s(:send, nil, :assert_operator,
            s(:lvar, :size_default),
            s(:sym, :>),
            s(:int, 0),
            s(:str, "default size")),
          s(:lvasgn, :size_0,
            s(:send, nil, :invoke_rec,
              s(:lvar, :script),
              s(:int, 0),
              s(:nil))),
          s(:send, nil, :assert_operator,
            s(:lvar, :size_default),
            s(:sym, :>),
            s(:lvar, :size_0),
            s(:str, "0 size")),
          s(:lvasgn, :size_large,
            s(:send, nil, :invoke_rec,
              s(:lvar, :script),
              s(:send,
                s(:send,
                  s(:int, 1024), :*,
                  s(:int, 1024)), :*,
                s(:int, 10)),
              s(:nil))),
          s(:send, nil, :assert_operator,
            s(:lvar, :size_default),
            s(:sym, :<),
            s(:lvar, :size_large),
            s(:str, "large size")))),
      s(:if,
        s(:match_with_lvasgn,
          s(:regexp,
            s(:str, "mswin|mingw"),
            s(:regopt)),
          s(:const, nil, :RUBY_PLATFORM)), nil,
        s(:def, :test_machine_stack_size,
          s(:args),
          s(:begin,
            s(:lvasgn, :script,
              s(:str, "def rec; print \".\"; STDOUT.flush; 1.times{1.times{1.times{rec}}}; end; Thread.new{rec}.join")),
            s(:lvasgn, :vm_stack_size,
              s(:send,
                s(:int, 1024), :*,
                s(:int, 1024))),
            s(:lvasgn, :size_default,
              s(:send, nil, :invoke_rec,
                s(:lvar, :script),
                s(:lvar, :vm_stack_size),
                s(:nil))),
            s(:lvasgn, :size_0,
              s(:send, nil, :invoke_rec,
                s(:lvar, :script),
                s(:lvar, :vm_stack_size),
                s(:int, 0))),
            s(:send, nil, :assert_operator,
              s(:lvar, :size_default),
              s(:sym, :>=),
              s(:lvar, :size_0),
              s(:str, "0 size")),
            s(:lvasgn, :size_large,
              s(:send, nil, :invoke_rec,
                s(:lvar, :script),
                s(:lvar, :vm_stack_size),
                s(:send,
                  s(:send,
                    s(:int, 1024), :*,
                    s(:int, 1024)), :*,
                  s(:int, 10)))),
            s(:send, nil, :assert_operator,
              s(:lvar, :size_default),
              s(:sym, :<=),
              s(:lvar, :size_large),
              s(:str, "large size"))))),
      s(:if,
        s(:send,
          s(:const, nil, :Process), :respond_to?,
          s(:sym, :fork)),
        s(:def, :test_blocking_mutex_unlocked_on_fork,
          s(:args),
          s(:begin,
            s(:lvasgn, :bug8433,
              s(:str, "[ruby-core:55102] [Bug #8433]")),
            s(:lvasgn, :mutex,
              s(:send,
                s(:const, nil, :Mutex), :new)),
            s(:lvasgn, :flag,
              s(:false)),
            s(:send,
              s(:lvar, :mutex), :lock),
            s(:lvasgn, :th,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :new),
                s(:args),
                s(:block,
                  s(:send,
                    s(:lvar, :mutex), :synchronize),
                  s(:args),
                  s(:begin,
                    s(:lvasgn, :flag,
                      s(:true)),
                    s(:send, nil, :sleep))))),
            s(:until,
              s(:send,
                s(:lvar, :th), :stop?),
              s(:send,
                s(:const, nil, :Thread), :pass)),
            s(:send,
              s(:lvar, :mutex), :unlock),
            s(:lvasgn, :pid,
              s(:block,
                s(:send,
                  s(:const, nil, :Process), :fork),
                s(:args),
                s(:send, nil, :exit,
                  s(:send,
                    s(:lvar, :mutex), :locked?)))),
            s(:send,
              s(:lvar, :th), :kill),
            s(:masgn,
              s(:mlhs,
                s(:lvasgn, :pid),
                s(:lvasgn, :status)),
              s(:send,
                s(:const, nil, :Process), :waitpid2,
                s(:lvar, :pid))),
            s(:send, nil, :assert_equal,
              s(:false),
              s(:send,
                s(:lvar, :status), :success?),
              s(:lvar, :bug8433)))), nil),
      s(:if,
        s(:send,
          s(:const, nil, :Process), :respond_to?,
          s(:sym, :fork)),
        s(:def, :test_fork_in_thread,
          s(:args),
          s(:begin,
            s(:lvasgn, :bug9751,
              s(:str, "[ruby-core:62070] [Bug #9751]")),
            s(:lvasgn, :f,
              s(:nil)),
            s(:lvasgn, :th,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :start),
                s(:args),
                s(:begin,
                  s(:if,
                    s(:lvasgn, :f,
                      s(:send,
                        s(:const, nil, :IO), :popen,
                        s(:str, "-"))), nil,
                    s(:begin,
                      s(:send,
                        s(:const, nil, :STDERR), :reopen,
                        s(:const, nil, :STDOUT)),
                      s(:send, nil, :exit))),
                  s(:send,
                    s(:const, nil, :Process), :wait2,
                    s(:send,
                      s(:lvar, :f), :pid))))),
            s(:if,
              s(:send,
                s(:lvar, :th), :join,
                s(:int, 3)), nil,
              s(:begin,
                s(:send,
                  s(:const, nil, :Process), :kill,
                  s(:sym, :QUIT),
                  s(:send,
                    s(:lvar, :f), :pid)),
                s(:if,
                  s(:send,
                    s(:lvar, :th), :join,
                    s(:int, 1)), nil,
                  s(:send,
                    s(:const, nil, :Process), :kill,
                    s(:sym, :KILL),
                    s(:send,
                      s(:lvar, :f), :pid))))),
            s(:masgn,
              s(:mlhs,
                s(:lvasgn, :_),
                s(:lvasgn, :status)),
              s(:send,
                s(:lvar, :th), :value)),
            s(:lvasgn, :output,
              s(:send,
                s(:lvar, :f), :read)),
            s(:send,
              s(:lvar, :f), :close),
            s(:send, nil, :assert_not_predicate,
              s(:lvar, :status),
              s(:sym, :signaled?),
              s(:send,
                s(:const, nil, :FailDesc), :[],
                s(:lvar, :status),
                s(:lvar, :bug9751),
                s(:lvar, :output))),
            s(:send, nil, :assert_predicate,
              s(:lvar, :status),
              s(:sym, :success?),
              s(:lvar, :bug9751)))), nil),
      s(:def, :test_subclass_no_initialize,
        s(:args),
        s(:begin,
          s(:lvasgn, :t,
            s(:block,
              s(:send,
                s(:const, nil, :Module), :new),
              s(:args),
              s(:break,
                s(:send, nil, :eval,
                  s(:str, "class Cスレッド < Thread; self; end"))))),
          s(:block,
            s(:send,
              s(:lvar, :t), :class_eval),
            s(:args),
            s(:def, :initialize,
              s(:args), nil)),
          s(:block,
            s(:send, nil, :assert_raise_with_message,
              s(:const, nil, :ThreadError),
              s(:regexp,
                s(:str, "C\\u{30b9 30ec 30c3 30c9}"),
                s(:regopt))),
            s(:args),
            s(:block,
              s(:send,
                s(:lvar, :t), :new),
              s(:args), nil)))),
      s(:def, :test_thread_name,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:lvasgn, :t,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :start),
                s(:args),
                s(:send, nil, :sleep))),
            s(:until,
              s(:send,
                s(:lvar, :t), :stop?),
              s(:send, nil, :sleep,
                s(:float, 0.001))),
            s(:send, nil, :assert_nil,
              s(:send,
                s(:lvar, :t), :name)),
            s(:lvasgn, :s,
              s(:send,
                s(:lvar, :t), :inspect)),
            s(:send,
              s(:lvar, :t), :name=,
              s(:str, "foo")),
            s(:send, nil, :assert_equal,
              s(:str, "foo"),
              s(:send,
                s(:lvar, :t), :name)),
            s(:send,
              s(:lvar, :t), :name=,
              s(:nil)),
            s(:send, nil, :assert_nil,
              s(:send,
                s(:lvar, :t), :name)),
            s(:send, nil, :assert_equal,
              s(:lvar, :s),
              s(:send,
                s(:lvar, :t), :inspect))),
          s(:begin,
            s(:send,
              s(:lvar, :t), :kill),
            s(:send,
              s(:lvar, :t), :join)))),
      s(:def, :test_thread_invalid_name,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:lvasgn, :bug11756,
              s(:str, "[ruby-core:71774] [Bug #11756]")),
            s(:lvasgn, :t,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :start),
                s(:args), nil)),
            s(:block,
              s(:send, nil, :assert_raise,
                s(:const, nil, :ArgumentError),
                s(:lvar, :bug11756)),
              s(:args),
              s(:send,
                s(:lvar, :t), :name=,
                s(:str, "foo\u0000bar"))),
            s(:block,
              s(:send, nil, :assert_raise,
                s(:const, nil, :ArgumentError),
                s(:lvar, :bug11756)),
              s(:args),
              s(:send,
                s(:lvar, :t), :name=,
                s(:send,
                  s(:str, "foo"), :encode,
                  s(:const,
                    s(:const, nil, :Encoding), :UTF_32BE))))),
          s(:begin,
            s(:send,
              s(:lvar, :t), :kill),
            s(:send,
              s(:lvar, :t), :join)))),
      s(:def, :test_thread_invalid_object,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:lvasgn, :bug11756,
              s(:str, "[ruby-core:71774] [Bug #11756]")),
            s(:lvasgn, :t,
              s(:block,
                s(:send,
                  s(:const, nil, :Thread), :start),
                s(:args), nil)),
            s(:block,
              s(:send, nil, :assert_raise,
                s(:const, nil, :TypeError),
                s(:lvar, :bug11756)),
              s(:args),
              s(:send,
                s(:lvar, :t), :name=,
                s(:array)))),
          s(:begin,
            s(:send,
              s(:lvar, :t), :kill),
            s(:send,
              s(:lvar, :t), :join)))),
      s(:def, :test_thread_setname_in_initialize,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug12290,
            s(:str, "[ruby-core:74963] [Bug #12290]")),
          s(:lvasgn, :c,
            s(:block,
              s(:send,
                s(:const, nil, :Class), :new,
                s(:const, nil, :Thread)),
              s(:args),
              s(:def, :initialize,
                s(:args),
                s(:begin,
                  s(:send,
                    s(:self), :name=,
                    s(:str, "foo")),
                  s(:zsuper))))),
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:block,
                s(:send,
                  s(:lvar, :c), :new),
                s(:args),
                s(:send,
                  s(:send,
                    s(:const, nil, :Thread), :current), :name)), :value)))))))
