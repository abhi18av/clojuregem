s(:begin,
  s(:send, nil, :require,
    s(:str, "test/unit")),
  s(:class,
    s(:const, nil, :TestRefinement),
    s(:const,
      s(:const,
        s(:const, nil, :Test), :Unit), :TestCase),
    s(:begin,
      s(:module,
        s(:const, nil, :Sandbox),
        s(:casgn, nil, :BINDING,
          s(:send, nil, :binding))),
      s(:class,
        s(:const, nil, :Foo), nil,
        s(:begin,
          s(:def, :x,
            s(:args),
            s(:return,
              s(:str, "Foo#x"))),
          s(:def, :y,
            s(:args),
            s(:return,
              s(:str, "Foo#y"))),
          s(:def, :a,
            s(:args),
            s(:return,
              s(:str, "Foo#a"))),
          s(:def, :call_x,
            s(:args),
            s(:return,
              s(:send, nil, :x))))),
      s(:module,
        s(:const, nil, :FooExt),
        s(:block,
          s(:send, nil, :refine,
            s(:const, nil, :Foo)),
          s(:args),
          s(:begin,
            s(:def, :x,
              s(:args),
              s(:return,
                s(:str, "FooExt#x"))),
            s(:def, :y,
              s(:args),
              s(:return,
                s(:send,
                  s(:str, "FooExt#y "), :+,
                  s(:zsuper)))),
            s(:def, :z,
              s(:args),
              s(:return,
                s(:str, "FooExt#z"))),
            s(:def, :a,
              s(:args),
              s(:return,
                s(:str, "FooExt#a")))))),
      s(:module,
        s(:const, nil, :FooExt2),
        s(:block,
          s(:send, nil, :refine,
            s(:const, nil, :Foo)),
          s(:args),
          s(:begin,
            s(:def, :x,
              s(:args),
              s(:return,
                s(:str, "FooExt2#x"))),
            s(:def, :y,
              s(:args),
              s(:return,
                s(:send,
                  s(:str, "FooExt2#y "), :+,
                  s(:zsuper)))),
            s(:def, :z,
              s(:args),
              s(:return,
                s(:str, "FooExt2#z")))))),
      s(:class,
        s(:const, nil, :FooSub),
        s(:const, nil, :Foo),
        s(:begin,
          s(:def, :x,
            s(:args),
            s(:return,
              s(:str, "FooSub#x"))),
          s(:def, :y,
            s(:args),
            s(:return,
              s(:send,
                s(:str, "FooSub#y "), :+,
                s(:zsuper)))))),
      s(:send, nil, :eval,
        s(:dstr,
          s(:str, "    using TestRefinement::FooExt\n"),
          s(:str, "\n"),
          s(:str, "    class TestRefinement::FooExtClient\n"),
          s(:str, "      def self.invoke_x_on(foo)\n"),
          s(:str, "        return foo.x\n"),
          s(:str, "      end\n"),
          s(:str, "\n"),
          s(:str, "      def self.invoke_y_on(foo)\n"),
          s(:str, "        return foo.y\n"),
          s(:str, "      end\n"),
          s(:str, "\n"),
          s(:str, "      def self.invoke_z_on(foo)\n"),
          s(:str, "        return foo.z\n"),
          s(:str, "      end\n"),
          s(:str, "\n"),
          s(:str, "      def self.send_z_on(foo)\n"),
          s(:str, "        return foo.send(:z)\n"),
          s(:str, "      end\n"),
          s(:str, "\n"),
          s(:str, "      def self.method_z(foo)\n"),
          s(:str, "        return foo.method(:z)\n"),
          s(:str, "      end\n"),
          s(:str, "\n"),
          s(:str, "      def self.invoke_call_x_on(foo)\n"),
          s(:str, "        return foo.call_x\n"),
          s(:str, "      end\n"),
          s(:str, "    end\n")),
        s(:const,
          s(:const, nil, :Sandbox), :BINDING)),
      s(:send, nil, :eval,
        s(:dstr,
          s(:str, "    using TestRefinement::FooExt\n"),
          s(:str, "    using TestRefinement::FooExt2\n"),
          s(:str, "\n"),
          s(:str, "    class TestRefinement::FooExtClient2\n"),
          s(:str, "      def self.invoke_y_on(foo)\n"),
          s(:str, "        return foo.y\n"),
          s(:str, "      end\n"),
          s(:str, "\n"),
          s(:str, "      def self.invoke_a_on(foo)\n"),
          s(:str, "        return foo.a\n"),
          s(:str, "      end\n"),
          s(:str, "    end\n")),
        s(:const,
          s(:const, nil, :Sandbox), :BINDING)),
      s(:def, :test_override,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:send,
              s(:lvar, :foo), :x)),
          s(:send, nil, :assert_equal,
            s(:str, "FooExt#x"),
            s(:send,
              s(:const, nil, :FooExtClient), :invoke_x_on,
              s(:lvar, :foo))),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:send,
              s(:lvar, :foo), :x)))),
      s(:def, :test_super,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#y"),
            s(:send,
              s(:lvar, :foo), :y)),
          s(:send, nil, :assert_equal,
            s(:str, "FooExt#y Foo#y"),
            s(:send,
              s(:const, nil, :FooExtClient), :invoke_y_on,
              s(:lvar, :foo))),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#y"),
            s(:send,
              s(:lvar, :foo), :y)))),
      s(:def, :test_super_not_chained,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#y"),
            s(:send,
              s(:lvar, :foo), :y)),
          s(:send, nil, :assert_equal,
            s(:str, "FooExt2#y Foo#y"),
            s(:send,
              s(:const, nil, :FooExtClient2), :invoke_y_on,
              s(:lvar, :foo))),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#y"),
            s(:send,
              s(:lvar, :foo), :y)))),
      s(:def, :test_using_same_class_refinements,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#a"),
            s(:send,
              s(:lvar, :foo), :a)),
          s(:send, nil, :assert_equal,
            s(:str, "FooExt#a"),
            s(:send,
              s(:const, nil, :FooExtClient2), :invoke_a_on,
              s(:lvar, :foo))),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#a"),
            s(:send,
              s(:lvar, :foo), :a)))),
      s(:def, :test_new_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NoMethodError)),
            s(:args),
            s(:send,
              s(:lvar, :foo), :z)),
          s(:send, nil, :assert_equal,
            s(:str, "FooExt#z"),
            s(:send,
              s(:const, nil, :FooExtClient), :invoke_z_on,
              s(:lvar, :foo))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NoMethodError)),
            s(:args),
            s(:send,
              s(:lvar, :foo), :z)))),
      s(:module,
        s(:const, nil, :RespondTo),
        s(:begin,
          s(:class,
            s(:const, nil, :Super), nil,
            s(:def, :foo,
              s(:args), nil)),
          s(:class,
            s(:const, nil, :Sub),
            s(:const, nil, :Super), nil),
          s(:module,
            s(:const, nil, :M),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :Sub)),
              s(:args),
              s(:def, :foo,
                s(:args), nil))))),
      s(:def, :test_send_should_not_use_refinements,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NoMethodError)),
            s(:args),
            s(:send,
              s(:lvar, :foo), :send,
              s(:sym, :z))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NoMethodError)),
            s(:args),
            s(:send,
              s(:const, nil, :FooExtClient), :send_z_on,
              s(:lvar, :foo))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NoMethodError)),
            s(:args),
            s(:send,
              s(:lvar, :foo), :send,
              s(:sym, :z))),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:send,
                s(:const,
                  s(:const, nil, :RespondTo), :Sub), :new), :respond_to?,
              s(:sym, :foo))))),
      s(:def, :test_method_should_not_use_refinements,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NameError)),
            s(:args),
            s(:send,
              s(:lvar, :foo), :method,
              s(:sym, :z))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NameError)),
            s(:args),
            s(:send,
              s(:const, nil, :FooExtClient), :method_z,
              s(:lvar, :foo))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NameError)),
            s(:args),
            s(:send,
              s(:lvar, :foo), :method,
              s(:sym, :z))))),
      s(:def, :test_no_local_rebinding,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:send,
              s(:lvar, :foo), :call_x)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:send,
              s(:const, nil, :FooExtClient), :invoke_call_x_on,
              s(:lvar, :foo))),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:send,
              s(:lvar, :foo), :call_x)))),
      s(:def, :test_subclass_is_prior,
        s(:args),
        s(:begin,
          s(:lvasgn, :sub,
            s(:send,
              s(:const, nil, :FooSub), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "FooSub#x"),
            s(:send,
              s(:lvar, :sub), :x)),
          s(:send, nil, :assert_equal,
            s(:str, "FooSub#x"),
            s(:send,
              s(:const, nil, :FooExtClient), :invoke_x_on,
              s(:lvar, :sub))),
          s(:send, nil, :assert_equal,
            s(:str, "FooSub#x"),
            s(:send,
              s(:lvar, :sub), :x)))),
      s(:def, :test_super_in_subclass,
        s(:args),
        s(:begin,
          s(:lvasgn, :sub,
            s(:send,
              s(:const, nil, :FooSub), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "FooSub#y Foo#y"),
            s(:send,
              s(:lvar, :sub), :y)),
          s(:send, nil, :assert_equal,
            s(:str, "FooSub#y Foo#y"),
            s(:send,
              s(:const, nil, :FooExtClient), :invoke_y_on,
              s(:lvar, :sub))),
          s(:send, nil, :assert_equal,
            s(:str, "FooSub#y Foo#y"),
            s(:send,
              s(:lvar, :sub), :y)))),
      s(:def, :test_new_method_on_subclass,
        s(:args),
        s(:begin,
          s(:lvasgn, :sub,
            s(:send,
              s(:const, nil, :FooSub), :new)),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NoMethodError)),
            s(:args),
            s(:send,
              s(:lvar, :sub), :z)),
          s(:send, nil, :assert_equal,
            s(:str, "FooExt#z"),
            s(:send,
              s(:const, nil, :FooExtClient), :invoke_z_on,
              s(:lvar, :sub))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NoMethodError)),
            s(:args),
            s(:send,
              s(:lvar, :sub), :z)))),
      s(:def, :test_module_eval,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:send,
              s(:lvar, :foo), :x)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:block,
              s(:send,
                s(:const, nil, :FooExt), :module_eval),
              s(:args),
              s(:send,
                s(:lvar, :foo), :x))),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:send,
              s(:const, nil, :FooExt), :module_eval,
              s(:str, "foo.x"))),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:send,
              s(:lvar, :foo), :x)))),
      s(:def, :test_instance_eval_without_refinement,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:lvasgn, :ext_client,
            s(:send,
              s(:const, nil, :FooExtClient), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:send,
              s(:lvar, :foo), :x)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:block,
              s(:send,
                s(:lvar, :ext_client), :instance_eval),
              s(:args),
              s(:send,
                s(:lvar, :foo), :x))),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:send,
              s(:lvar, :foo), :x)))),
      s(:module,
        s(:const, nil, :FixnumSlashExt),
        s(:block,
          s(:send, nil, :refine,
            s(:const, nil, :Fixnum)),
          s(:args),
          s(:def, :/,
            s(:args,
              s(:arg, :other)),
            s(:send, nil, :quo,
              s(:lvar, :other))))),
      s(:def, :test_override_builtin_method,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:int, 1), :/,
              s(:int, 2))),
          s(:send, nil, :assert_equal,
            s(:send, nil, :Rational,
              s(:int, 1),
              s(:int, 2)),
            s(:send, nil, :eval_using,
              s(:const, nil, :FixnumSlashExt),
              s(:str, "1 / 2"))),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:int, 1), :/,
              s(:int, 2))))),
      s(:module,
        s(:const, nil, :FixnumPlusExt),
        s(:block,
          s(:send, nil, :refine,
            s(:const, nil, :Fixnum)),
          s(:args),
          s(:begin,
            s(:defs,
              s(:self), :method_added,
              s(:args,
                s(:restarg, :args)), nil),
            s(:def, :+,
              s(:args,
                s(:arg, :other)),
              s(:str, "overridden"))))),
      s(:def, :test_override_builtin_method_with_method_added,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:int, 3),
            s(:send,
              s(:int, 1), :+,
              s(:int, 2))),
          s(:send, nil, :assert_equal,
            s(:str, "overridden"),
            s(:send, nil, :eval_using,
              s(:const, nil, :FixnumPlusExt),
              s(:str, "1 + 2"))),
          s(:send, nil, :assert_equal,
            s(:int, 3),
            s(:send,
              s(:int, 1), :+,
              s(:int, 2))))),
      s(:def, :test_return_value_of_refine,
        s(:args),
        s(:begin,
          s(:lvasgn, :mod,
            s(:nil)),
          s(:lvasgn, :result,
            s(:nil)),
          s(:block,
            s(:send,
              s(:const, nil, :Module), :new),
            s(:args),
            s(:lvasgn, :result,
              s(:block,
                s(:send, nil, :refine,
                  s(:const, nil, :Object)),
                s(:args),
                s(:lvasgn, :mod,
                  s(:self))))),
          s(:send, nil, :assert_equal,
            s(:lvar, :mod),
            s(:lvar, :result)))),
      s(:module,
        s(:const, nil, :RefineSameClass),
        s(:begin,
          s(:casgn, nil, :REFINEMENT1,
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :Fixnum)),
              s(:args),
              s(:def, :foo,
                s(:args),
                s(:return,
                  s(:str, "foo"))))),
          s(:casgn, nil, :REFINEMENT2,
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :Fixnum)),
              s(:args),
              s(:def, :bar,
                s(:args),
                s(:return,
                  s(:str, "bar"))))),
          s(:casgn, nil, :REFINEMENT3,
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :String)),
              s(:args),
              s(:def, :baz,
                s(:args),
                s(:return,
                  s(:str, "baz"))))))),
      s(:def, :test_refine_same_class_twice,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send, nil, :eval_using,
              s(:const, nil, :RefineSameClass),
              s(:str, "1.foo"))),
          s(:send, nil, :assert_equal,
            s(:str, "bar"),
            s(:send, nil, :eval_using,
              s(:const, nil, :RefineSameClass),
              s(:str, "1.bar"))),
          s(:send, nil, :assert_equal,
            s(:const,
              s(:const, nil, :RefineSameClass), :REFINEMENT1),
            s(:const,
              s(:const, nil, :RefineSameClass), :REFINEMENT2)),
          s(:send, nil, :assert_not_equal,
            s(:const,
              s(:const, nil, :RefineSameClass), :REFINEMENT1),
            s(:const,
              s(:const, nil, :RefineSameClass), :REFINEMENT3)))),
      s(:module,
        s(:const, nil, :FixnumFooExt),
        s(:block,
          s(:send, nil, :refine,
            s(:const, nil, :Fixnum)),
          s(:args),
          s(:def, :foo,
            s(:args),
            s(:str, "foo")))),
      s(:def, :test_respond_to_should_not_use_refinements,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:int, 1), :respond_to?,
              s(:sym, :foo))),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send, nil, :eval_using,
              s(:const, nil, :FixnumFooExt),
              s(:str, "1.respond_to?(:foo)"))))),
      s(:module,
        s(:const, nil, :StringCmpExt),
        s(:block,
          s(:send, nil, :refine,
            s(:const, nil, :String)),
          s(:args),
          s(:def, :<=>,
            s(:args,
              s(:arg, :other)),
            s(:return,
              s(:int, 0))))),
      s(:module,
        s(:const, nil, :ArrayEachExt),
        s(:block,
          s(:send, nil, :refine,
            s(:const, nil, :Array)),
          s(:args),
          s(:def, :each,
            s(:args),
            s(:block,
              s(:zsuper),
              s(:args,
                s(:arg, :i)),
              s(:yield,
                s(:send,
                  s(:int, 2), :*,
                  s(:lvar, :i))))))),
      s(:def, :test_builtin_method_no_local_rebinding,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send, nil, :eval_using,
              s(:const, nil, :StringCmpExt),
              s(:str, "\"1\" >= \"2\""))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send, nil, :eval_using,
              s(:const, nil, :ArrayEachExt),
              s(:str, "[1, 2, 3].min"))))),
      s(:module,
        s(:const, nil, :RefinePrependedClass),
        s(:begin,
          s(:module,
            s(:const, nil, :M1),
            s(:def, :foo,
              s(:args),
              s(:send,
                s(:zsuper), :<<,
                s(:sym, :m1)))),
          s(:class,
            s(:const, nil, :C), nil,
            s(:begin,
              s(:send, nil, :prepend,
                s(:const, nil, :M1)),
              s(:def, :foo,
                s(:args),
                s(:array,
                  s(:sym, :c))))),
          s(:module,
            s(:const, nil, :M2),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :C)),
              s(:args),
              s(:def, :foo,
                s(:args),
                s(:send,
                  s(:zsuper), :<<,
                  s(:sym, :m2))))))),
      s(:def, :test_refine_prepended_class,
        s(:args),
        s(:begin,
          s(:lvasgn, :x,
            s(:send, nil, :eval_using,
              s(:const,
                s(:const, nil, :RefinePrependedClass), :M2),
              s(:str, "TestRefinement::RefinePrependedClass::C.new.foo"))),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:sym, :c),
              s(:sym, :m1),
              s(:sym, :m2)),
            s(:lvar, :x)))),
      s(:def, :test_refine_module,
        s(:args),
        s(:begin,
          s(:lvasgn, :m1,
            s(:send,
              s(:const, nil, :Module), :new)),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :TypeError)),
            s(:args),
            s(:block,
              s(:send,
                s(:const, nil, :Module), :new),
              s(:args),
              s(:block,
                s(:send, nil, :refine,
                  s(:lvar, :m1)),
                s(:args),
                s(:def, :foo,
                  s(:args),
                  s(:sym, :m2))))))),
      s(:def, :test_refine_neither_class_nor_module,
        s(:args),
        s(:begin,
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :TypeError)),
            s(:args),
            s(:block,
              s(:send,
                s(:const, nil, :Module), :new),
              s(:args),
              s(:block,
                s(:send, nil, :refine,
                  s(:send,
                    s(:const, nil, :Object), :new)),
                s(:args), nil))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :TypeError)),
            s(:args),
            s(:block,
              s(:send,
                s(:const, nil, :Module), :new),
              s(:args),
              s(:block,
                s(:send, nil, :refine,
                  s(:int, 123)),
                s(:args), nil))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :TypeError)),
            s(:args),
            s(:block,
              s(:send,
                s(:const, nil, :Module), :new),
              s(:args),
              s(:block,
                s(:send, nil, :refine,
                  s(:str, "foo")),
                s(:args), nil))))),
      s(:def, :test_refine_in_class,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :NoMethodError)),
          s(:args),
          s(:block,
            s(:send,
              s(:const, nil, :Class), :new),
            s(:args),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :Fixnum)),
              s(:args),
              s(:def, :foo,
                s(:args),
                s(:str, "c")))))),
      s(:def, :test_main_using,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      class C\n"),
            s(:str, "        def foo\n"),
            s(:str, "          :C\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      module M\n"),
            s(:str, "        refine C do\n"),
            s(:str, "          def foo\n"),
            s(:str, "            :M\n"),
            s(:str, "          end\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      c = C.new\n"),
            s(:str, "      p c.foo\n"),
            s(:str, "      using M\n"),
            s(:str, "      p c.foo\n")),
          s(:array,
            s(:str, ":C"),
            s(:str, ":M")),
          s(:array))),
      s(:def, :test_main_using_is_private,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :NoMethodError)),
          s(:args),
          s(:send, nil, :eval,
            s(:str, "self.using Module.new"),
            s(:const,
              s(:const, nil, :Sandbox), :BINDING)))),
      s(:def, :test_no_kernel_using,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :NoMethodError)),
          s(:args),
          s(:send, nil, :using,
            s(:send,
              s(:const, nil, :Module), :new)))),
      s(:class,
        s(:const, nil, :UsingClass), nil, nil),
      s(:def, :test_module_using_class,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :TypeError)),
          s(:args),
          s(:send, nil, :eval,
            s(:str, "using TestRefinement::UsingClass"),
            s(:const,
              s(:const, nil, :Sandbox), :BINDING)))),
      s(:def, :test_refine_without_block,
        s(:args),
        s(:begin,
          s(:lvasgn, :c1,
            s(:send,
              s(:const, nil, :Class), :new)),
          s(:block,
            s(:send, nil, :assert_raise_with_message,
              s(:const, nil, :ArgumentError),
              s(:str, "no block given")),
            s(:args),
            s(:block,
              s(:send,
                s(:const, nil, :Module), :new),
              s(:args),
              s(:send, nil, :refine,
                s(:lvar, :c1)))))),
      s(:module,
        s(:const, nil, :Inspect),
        s(:module,
          s(:const, nil, :M),
          s(:casgn, nil, :Fixnum,
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :Fixnum)),
              s(:args), nil)))),
      s(:def, :test_inspect,
        s(:args),
        s(:send, nil, :assert_equal,
          s(:str, "#<refinement:Fixnum@TestRefinement::Inspect::M>"),
          s(:send,
            s(:const,
              s(:const,
                s(:const, nil, :Inspect), :M), :Fixnum), :inspect))),
      s(:def, :test_using_method_cache,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      class C\n"),
            s(:str, "        def foo\n"),
            s(:str, "          \"original\"\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      module M1\n"),
            s(:str, "        refine C do\n"),
            s(:str, "          def foo\n"),
            s(:str, "            :M1\n"),
            s(:str, "          end\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      module M2\n"),
            s(:str, "        refine C do\n"),
            s(:str, "          def foo\n"),
            s(:str, "            :M2\n"),
            s(:str, "          end\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      c = C.new\n"),
            s(:str, "      using M1\n"),
            s(:str, "      p c.foo\n"),
            s(:str, "      using M2\n"),
            s(:str, "      p c.foo\n")),
          s(:array,
            s(:str, ":M1"),
            s(:str, ":M2")),
          s(:array))),
      s(:module,
        s(:const, nil, :RedefineRefinedMethod),
        s(:begin,
          s(:class,
            s(:const, nil, :C), nil,
            s(:def, :foo,
              s(:args),
              s(:str, "original"))),
          s(:module,
            s(:const, nil, :M),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :C)),
              s(:args),
              s(:def, :foo,
                s(:args),
                s(:str, "refined")))),
          s(:class,
            s(:const, nil, :C), nil,
            s(:def, :foo,
              s(:args),
              s(:str, "redefined"))))),
      s(:def, :test_redefine_refined_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :x,
            s(:send, nil, :eval_using,
              s(:const,
                s(:const, nil, :RedefineRefinedMethod), :M),
              s(:str, "TestRefinement::RedefineRefinedMethod::C.new.foo"))),
          s(:send, nil, :assert_equal,
            s(:str, "refined"),
            s(:lvar, :x)))),
      s(:module,
        s(:const, nil, :StringExt),
        s(:block,
          s(:send, nil, :refine,
            s(:const, nil, :String)),
          s(:args),
          s(:def, :foo,
            s(:args),
            s(:str, "foo")))),
      s(:module,
        s(:const, nil, :RefineScoping),
        s(:begin,
          s(:block,
            s(:send, nil, :refine,
              s(:const, nil, :String)),
            s(:args),
            s(:begin,
              s(:def, :foo,
                s(:args),
                s(:str, "foo")),
              s(:defs,
                s(:const, nil, :RefineScoping), :call_in_refine_block,
                s(:args),
                s(:send,
                  s(:str, ""), :foo)))),
          s(:defs,
            s(:self), :call_outside_refine_block,
            s(:args),
            s(:send,
              s(:str, ""), :foo)))),
      s(:def, :test_refine_scoping,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:const, nil, :RefineScoping), :call_in_refine_block)),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NoMethodError)),
            s(:args),
            s(:send,
              s(:const, nil, :RefineScoping), :call_outside_refine_block)))),
      s(:module,
        s(:const, nil, :StringRecursiveLength),
        s(:block,
          s(:send, nil, :refine,
            s(:const, nil, :String)),
          s(:args),
          s(:def, :recursive_length,
            s(:args),
            s(:if,
              s(:send, nil, :empty?),
              s(:int, 0),
              s(:send,
                s(:send,
                  s(:send,
                    s(:self), :[],
                    s(:irange,
                      s(:int, 1),
                      s(:int, -1))), :recursive_length), :+,
                s(:int, 1)))))),
      s(:def, :test_refine_recursion,
        s(:args),
        s(:begin,
          s(:lvasgn, :x,
            s(:send, nil, :eval_using,
              s(:const, nil, :StringRecursiveLength),
              s(:str, "'foo'.recursive_length"))),
          s(:send, nil, :assert_equal,
            s(:int, 3),
            s(:lvar, :x)))),
      s(:module,
        s(:const, nil, :ToJSON),
        s(:begin,
          s(:block,
            s(:send, nil, :refine,
              s(:const, nil, :Integer)),
            s(:args),
            s(:def, :to_json,
              s(:args),
              s(:send, nil, :to_s))),
          s(:block,
            s(:send, nil, :refine,
              s(:const, nil, :Array)),
            s(:args),
            s(:def, :to_json,
              s(:args),
              s(:send,
                s(:send,
                  s(:str, "["), :+,
                  s(:send,
                    s(:block,
                      s(:send, nil, :map),
                      s(:args,
                        s(:arg, :i)),
                      s(:send,
                        s(:lvar, :i), :to_json)), :join,
                    s(:str, ","))), :+,
                s(:str, "]")))),
          s(:block,
            s(:send, nil, :refine,
              s(:const, nil, :Hash)),
            s(:args),
            s(:def, :to_json,
              s(:args),
              s(:send,
                s(:send,
                  s(:str, "{"), :+,
                  s(:send,
                    s(:block,
                      s(:send, nil, :map),
                      s(:args,
                        s(:arg, :k),
                        s(:arg, :v)),
                      s(:send,
                        s(:send,
                          s(:send,
                            s(:send,
                              s(:lvar, :k), :to_s), :dump), :+,
                          s(:str, ":")), :+,
                        s(:send,
                          s(:lvar, :v), :to_json))), :join,
                    s(:str, ","))), :+,
                s(:str, "}")))))),
      s(:def, :test_refine_mutual_recursion,
        s(:args),
        s(:begin,
          s(:lvasgn, :x,
            s(:send, nil, :eval_using,
              s(:const, nil, :ToJSON),
              s(:str, "[{1=>2}, {3=>4}].to_json"))),
          s(:send, nil, :assert_equal,
            s(:str, "[{\"1\":2},{\"3\":4}]"),
            s(:lvar, :x)))),
      s(:def, :test_refine_with_proc,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :ArgumentError)),
          s(:args),
          s(:block,
            s(:send,
              s(:const, nil, :Module), :new),
            s(:args),
            s(:send, nil, :refine,
              s(:const, nil, :String),
              s(:block_pass,
                s(:block,
                  s(:send,
                    s(:const, nil, :Proc), :new),
                  s(:args), nil)))))),
      s(:def, :test_using_in_module,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :RuntimeError)),
          s(:args),
          s(:send, nil, :eval,
            s(:dstr,
              s(:str, "        $main = self\n"),
              s(:str, "        module M\n"),
              s(:str, "        end\n"),
              s(:str, "        module M2\n"),
              s(:str, "          $main.send(:using, M)\n"),
              s(:str, "        end\n")),
            s(:const,
              s(:const, nil, :Sandbox), :BINDING)))),
      s(:def, :test_using_in_method,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :RuntimeError)),
          s(:args),
          s(:send, nil, :eval,
            s(:dstr,
              s(:str, "        $main = self\n"),
              s(:str, "        module M\n"),
              s(:str, "        end\n"),
              s(:str, "        class C\n"),
              s(:str, "          def call_using_in_method\n"),
              s(:str, "            $main.send(:using, M)\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "        C.new.call_using_in_method\n")),
            s(:const,
              s(:const, nil, :Sandbox), :BINDING)))),
      s(:module,
        s(:const, nil, :IncludeIntoRefinement),
        s(:begin,
          s(:class,
            s(:const, nil, :C), nil,
            s(:begin,
              s(:def, :bar,
                s(:args),
                s(:return,
                  s(:str, "C#bar"))),
              s(:def, :baz,
                s(:args),
                s(:return,
                  s(:str, "C#baz"))))),
          s(:module,
            s(:const, nil, :Mixin),
            s(:begin,
              s(:def, :foo,
                s(:args),
                s(:return,
                  s(:str, "Mixin#foo"))),
              s(:def, :bar,
                s(:args),
                s(:return,
                  s(:send,
                    s(:zsuper), :<<,
                    s(:str, " Mixin#bar")))),
              s(:def, :baz,
                s(:args),
                s(:return,
                  s(:send,
                    s(:zsuper), :<<,
                    s(:str, " Mixin#baz")))))),
          s(:module,
            s(:const, nil, :M),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :C)),
              s(:args),
              s(:begin,
                s(:send, nil, :include,
                  s(:const, nil, :Mixin)),
                s(:def, :baz,
                  s(:args),
                  s(:return,
                    s(:send,
                      s(:zsuper), :<<,
                      s(:str, " M#baz"))))))))),
      s(:send, nil, :eval,
        s(:dstr,
          s(:str, "    using TestRefinement::IncludeIntoRefinement::M\n"),
          s(:str, "\n"),
          s(:str, "    module TestRefinement::IncludeIntoRefinement::User\n"),
          s(:str, "      def self.invoke_foo_on(x)\n"),
          s(:str, "        x.foo\n"),
          s(:str, "      end\n"),
          s(:str, "\n"),
          s(:str, "      def self.invoke_bar_on(x)\n"),
          s(:str, "        x.bar\n"),
          s(:str, "      end\n"),
          s(:str, "\n"),
          s(:str, "      def self.invoke_baz_on(x)\n"),
          s(:str, "        x.baz\n"),
          s(:str, "      end\n"),
          s(:str, "    end\n")),
        s(:const,
          s(:const, nil, :Sandbox), :BINDING)),
      s(:def, :test_include_into_refinement,
        s(:args),
        s(:begin,
          s(:lvasgn, :x,
            s(:send,
              s(:const,
                s(:const, nil, :IncludeIntoRefinement), :C), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "Mixin#foo"),
            s(:send,
              s(:const,
                s(:const, nil, :IncludeIntoRefinement), :User), :invoke_foo_on,
              s(:lvar, :x))),
          s(:send, nil, :assert_equal,
            s(:str, "C#bar Mixin#bar"),
            s(:send,
              s(:const,
                s(:const, nil, :IncludeIntoRefinement), :User), :invoke_bar_on,
              s(:lvar, :x))),
          s(:send, nil, :assert_equal,
            s(:str, "C#baz Mixin#baz M#baz"),
            s(:send,
              s(:const,
                s(:const, nil, :IncludeIntoRefinement), :User), :invoke_baz_on,
              s(:lvar, :x))))),
      s(:module,
        s(:const, nil, :PrependIntoRefinement),
        s(:begin,
          s(:class,
            s(:const, nil, :C), nil,
            s(:begin,
              s(:def, :bar,
                s(:args),
                s(:return,
                  s(:str, "C#bar"))),
              s(:def, :baz,
                s(:args),
                s(:return,
                  s(:str, "C#baz"))))),
          s(:module,
            s(:const, nil, :Mixin),
            s(:begin,
              s(:def, :foo,
                s(:args),
                s(:return,
                  s(:str, "Mixin#foo"))),
              s(:def, :bar,
                s(:args),
                s(:return,
                  s(:send,
                    s(:zsuper), :<<,
                    s(:str, " Mixin#bar")))),
              s(:def, :baz,
                s(:args),
                s(:return,
                  s(:send,
                    s(:zsuper), :<<,
                    s(:str, " Mixin#baz")))))),
          s(:module,
            s(:const, nil, :M),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :C)),
              s(:args),
              s(:begin,
                s(:send, nil, :prepend,
                  s(:const, nil, :Mixin)),
                s(:def, :baz,
                  s(:args),
                  s(:return,
                    s(:send,
                      s(:zsuper), :<<,
                      s(:str, " M#baz"))))))))),
      s(:send, nil, :eval,
        s(:dstr,
          s(:str, "    using TestRefinement::PrependIntoRefinement::M\n"),
          s(:str, "\n"),
          s(:str, "    module TestRefinement::PrependIntoRefinement::User\n"),
          s(:str, "      def self.invoke_foo_on(x)\n"),
          s(:str, "        x.foo\n"),
          s(:str, "      end\n"),
          s(:str, "\n"),
          s(:str, "      def self.invoke_bar_on(x)\n"),
          s(:str, "        x.bar\n"),
          s(:str, "      end\n"),
          s(:str, "\n"),
          s(:str, "      def self.invoke_baz_on(x)\n"),
          s(:str, "        x.baz\n"),
          s(:str, "      end\n"),
          s(:str, "    end\n")),
        s(:const,
          s(:const, nil, :Sandbox), :BINDING)),
      s(:def, :test_prepend_into_refinement,
        s(:args),
        s(:begin,
          s(:lvasgn, :x,
            s(:send,
              s(:const,
                s(:const, nil, :PrependIntoRefinement), :C), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "Mixin#foo"),
            s(:send,
              s(:const,
                s(:const, nil, :PrependIntoRefinement), :User), :invoke_foo_on,
              s(:lvar, :x))),
          s(:send, nil, :assert_equal,
            s(:str, "C#bar Mixin#bar"),
            s(:send,
              s(:const,
                s(:const, nil, :PrependIntoRefinement), :User), :invoke_bar_on,
              s(:lvar, :x))),
          s(:send, nil, :assert_equal,
            s(:str, "C#baz M#baz Mixin#baz"),
            s(:send,
              s(:const,
                s(:const, nil, :PrependIntoRefinement), :User), :invoke_baz_on,
              s(:lvar, :x))))),
      s(:casgn, nil, :PrependAfterRefine_CODE,
        s(:dstr,
          s(:str, "  module PrependAfterRefine\n"),
          s(:str, "    class C\n"),
          s(:str, "      def foo\n"),
          s(:str, "        \"original\"\n"),
          s(:str, "      end\n"),
          s(:str, "    end\n"),
          s(:str, "\n"),
          s(:str, "    module M\n"),
          s(:str, "      refine C do\n"),
          s(:str, "        def foo\n"),
          s(:str, "          \"refined\"\n"),
          s(:str, "        end\n"),
          s(:str, "\n"),
          s(:str, "        def bar\n"),
          s(:str, "          \"refined\"\n"),
          s(:str, "        end\n"),
          s(:str, "      end\n"),
          s(:str, "    end\n"),
          s(:str, "\n"),
          s(:str, "    module Mixin\n"),
          s(:str, "      def foo\n"),
          s(:str, "        \"mixin\"\n"),
          s(:str, "      end\n"),
          s(:str, "\n"),
          s(:str, "      def bar\n"),
          s(:str, "        \"mixin\"\n"),
          s(:str, "      end\n"),
          s(:str, "    end\n"),
          s(:str, "\n"),
          s(:str, "    class C\n"),
          s(:str, "      prepend Mixin\n"),
          s(:str, "    end\n"),
          s(:str, "  end\n"))),
      s(:send, nil, :eval,
        s(:const, nil, :PrependAfterRefine_CODE)),
      s(:def, :test_prepend_after_refine_wb_miss,
        s(:args),
        s(:begin,
          s(:if,
            s(:match_with_lvasgn,
              s(:regexp,
                s(:str, "\\A(arm|mips)"),
                s(:regopt)),
              s(:const, nil, :RUBY_PLATFORM)),
            s(:send, nil, :skip,
              s(:str, "too slow cpu")), nil),
          s(:send, nil, :assert_normal_exit,
            s(:dstr,
              s(:str, "\n"),
              s(:str, "      GC.stress = true\n"),
              s(:str, "      10.times{\n"),
              s(:str, "        "),
              s(:begin,
                s(:const, nil, :PrependAfterRefine_CODE)),
              s(:str, "\n"),
              s(:str, "        undef PrependAfterRefine\n"),
              s(:str, "      }\n"),
              s(:str, "    "))))),
      s(:def, :test_prepend_after_refine,
        s(:args),
        s(:begin,
          s(:lvasgn, :x,
            s(:send, nil, :eval_using,
              s(:const,
                s(:const, nil, :PrependAfterRefine), :M),
              s(:str, "TestRefinement::PrependAfterRefine::C.new.foo"))),
          s(:send, nil, :assert_equal,
            s(:str, "refined"),
            s(:lvar, :x)),
          s(:send, nil, :assert_equal,
            s(:str, "mixin"),
            s(:send,
              s(:send,
                s(:const,
                  s(:const,
                    s(:const, nil, :TestRefinement), :PrependAfterRefine), :C), :new), :foo)),
          s(:lvasgn, :y,
            s(:send, nil, :eval_using,
              s(:const,
                s(:const, nil, :PrependAfterRefine), :M),
              s(:str, "TestRefinement::PrependAfterRefine::C.new.bar"))),
          s(:send, nil, :assert_equal,
            s(:str, "refined"),
            s(:lvar, :y)),
          s(:send, nil, :assert_equal,
            s(:str, "mixin"),
            s(:send,
              s(:send,
                s(:const,
                  s(:const,
                    s(:const, nil, :TestRefinement), :PrependAfterRefine), :C), :new), :bar)))),
      s(:module,
        s(:const, nil, :SuperInBlock),
        s(:begin,
          s(:class,
            s(:const, nil, :C), nil,
            s(:def, :foo,
              s(:args,
                s(:restarg, :args)),
              s(:array,
                s(:sym, :foo),
                s(:splat,
                  s(:lvar, :args))))),
          s(:module,
            s(:const, nil, :R),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :C)),
              s(:args),
              s(:def, :foo,
                s(:args,
                  s(:restarg, :args)),
                s(:block,
                  s(:send, nil, :tap),
                  s(:args),
                  s(:return,
                    s(:super,
                      s(:sym, :ref),
                      s(:splat,
                        s(:lvar, :args)))))))))),
      s(:def, :test_super_in_block,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug7925,
            s(:str, "[ruby-core:52750] [Bug #7925]")),
          s(:lvasgn, :x,
            s(:send, nil, :eval_using,
              s(:const,
                s(:const, nil, :SuperInBlock), :R),
              s(:dstr,
                s(:str, "TestRefinement:: SuperInBlock::C.new.foo("),
                s(:begin,
                  s(:send,
                    s(:lvar, :bug7925), :dump)),
                s(:str, ")")))),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:sym, :foo),
              s(:sym, :ref),
              s(:lvar, :bug7925)),
            s(:lvar, :x),
            s(:lvar, :bug7925)))),
      s(:module,
        s(:const, nil, :ModuleUsing),
        s(:begin,
          s(:send, nil, :using,
            s(:const, nil, :FooExt)),
          s(:defs,
            s(:self), :invoke_x_on,
            s(:args,
              s(:arg, :foo)),
            s(:return,
              s(:send,
                s(:lvar, :foo), :x))),
          s(:defs,
            s(:self), :invoke_y_on,
            s(:args,
              s(:arg, :foo)),
            s(:return,
              s(:send,
                s(:lvar, :foo), :y))),
          s(:defs,
            s(:self), :invoke_z_on,
            s(:args,
              s(:arg, :foo)),
            s(:return,
              s(:send,
                s(:lvar, :foo), :z))),
          s(:defs,
            s(:self), :send_z_on,
            s(:args,
              s(:arg, :foo)),
            s(:return,
              s(:send,
                s(:lvar, :foo), :send,
                s(:sym, :z)))),
          s(:defs,
            s(:self), :method_z,
            s(:args,
              s(:arg, :foo)),
            s(:return,
              s(:send,
                s(:lvar, :foo), :method,
                s(:sym, :z)))),
          s(:defs,
            s(:self), :invoke_call_x_on,
            s(:args,
              s(:arg, :foo)),
            s(:return,
              s(:send,
                s(:lvar, :foo), :call_x))))),
      s(:def, :test_module_using,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:send,
              s(:lvar, :foo), :x)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#y"),
            s(:send,
              s(:lvar, :foo), :y)),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NoMethodError)),
            s(:args),
            s(:send,
              s(:lvar, :foo), :z)),
          s(:send, nil, :assert_equal,
            s(:str, "FooExt#x"),
            s(:send,
              s(:const, nil, :ModuleUsing), :invoke_x_on,
              s(:lvar, :foo))),
          s(:send, nil, :assert_equal,
            s(:str, "FooExt#y Foo#y"),
            s(:send,
              s(:const, nil, :ModuleUsing), :invoke_y_on,
              s(:lvar, :foo))),
          s(:send, nil, :assert_equal,
            s(:str, "FooExt#z"),
            s(:send,
              s(:const, nil, :ModuleUsing), :invoke_z_on,
              s(:lvar, :foo))),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#x"),
            s(:send,
              s(:lvar, :foo), :x)),
          s(:send, nil, :assert_equal,
            s(:str, "Foo#y"),
            s(:send,
              s(:lvar, :foo), :y)),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :NoMethodError)),
            s(:args),
            s(:send,
              s(:lvar, :foo), :z)))),
      s(:def, :test_module_using_in_method,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :RuntimeError)),
          s(:args),
          s(:send,
            s(:send,
              s(:const, nil, :Module), :new), :send,
            s(:sym, :using),
            s(:const, nil, :FooExt)))),
      s(:def, :test_module_using_invalid_self,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :RuntimeError)),
          s(:args),
          s(:send, nil, :eval,
            s(:dstr,
              s(:str, "        module TestRefinement::TestModuleUsingInvalidSelf\n"),
              s(:str, "          Module.new.send(:using, TestRefinement::FooExt)\n"),
              s(:str, "        end\n")),
            s(:const,
              s(:const, nil, :Sandbox), :BINDING)))),
      s(:class,
        s(:const, nil, :Bar), nil, nil),
      s(:module,
        s(:const, nil, :BarExt),
        s(:block,
          s(:send, nil, :refine,
            s(:const, nil, :Bar)),
          s(:args),
          s(:def, :x,
            s(:args),
            s(:return,
              s(:str, "BarExt#x"))))),
      s(:module,
        s(:const, nil, :FooBarExt),
        s(:begin,
          s(:send, nil, :include,
            s(:const, nil, :FooExt)),
          s(:send, nil, :include,
            s(:const, nil, :BarExt)))),
      s(:module,
        s(:const, nil, :FooBarExtClient),
        s(:begin,
          s(:send, nil, :using,
            s(:const, nil, :FooBarExt)),
          s(:defs,
            s(:self), :invoke_x_on,
            s(:args,
              s(:arg, :foo)),
            s(:return,
              s(:send,
                s(:lvar, :foo), :x))))),
      s(:def, :test_module_inclusion,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "FooExt#x"),
            s(:send,
              s(:const, nil, :FooBarExtClient), :invoke_x_on,
              s(:lvar, :foo))),
          s(:lvasgn, :bar,
            s(:send,
              s(:const, nil, :Bar), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "BarExt#x"),
            s(:send,
              s(:const, nil, :FooBarExtClient), :invoke_x_on,
              s(:lvar, :bar))))),
      s(:module,
        s(:const, nil, :FooFoo2Ext),
        s(:begin,
          s(:send, nil, :include,
            s(:const, nil, :FooExt)),
          s(:send, nil, :include,
            s(:const, nil, :FooExt2)))),
      s(:module,
        s(:const, nil, :FooFoo2ExtClient),
        s(:begin,
          s(:send, nil, :using,
            s(:const, nil, :FooFoo2Ext)),
          s(:defs,
            s(:self), :invoke_x_on,
            s(:args,
              s(:arg, :foo)),
            s(:return,
              s(:send,
                s(:lvar, :foo), :x))),
          s(:defs,
            s(:self), :invoke_y_on,
            s(:args,
              s(:arg, :foo)),
            s(:return,
              s(:send,
                s(:lvar, :foo), :y))))),
      s(:def, :test_module_inclusion2,
        s(:args),
        s(:begin,
          s(:lvasgn, :foo,
            s(:send,
              s(:const, nil, :Foo), :new)),
          s(:send, nil, :assert_equal,
            s(:str, "FooExt2#x"),
            s(:send,
              s(:const, nil, :FooFoo2ExtClient), :invoke_x_on,
              s(:lvar, :foo))),
          s(:send, nil, :assert_equal,
            s(:str, "FooExt2#y Foo#y"),
            s(:send,
              s(:const, nil, :FooFoo2ExtClient), :invoke_y_on,
              s(:lvar, :foo))))),
      s(:def, :test_eval_scoping,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      module M\n"),
            s(:str, "        refine String do\n"),
            s(:str, "          def upcase\n"),
            s(:str, "            reverse\n"),
            s(:str, "          end\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      puts \"hello world\".upcase\n"),
            s(:str, "      puts eval(%{using M; \"hello world\".upcase})\n"),
            s(:str, "      puts \"hello world\".upcase\n")),
          s(:array,
            s(:str, "HELLO WORLD"),
            s(:str, "dlrow olleh"),
            s(:str, "HELLO WORLD")),
          s(:array))),
      s(:def, :test_eval_with_binding_scoping,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      module M\n"),
            s(:str, "        refine String do\n"),
            s(:str, "          def upcase\n"),
            s(:str, "            reverse\n"),
            s(:str, "          end\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      puts \"hello world\".upcase\n"),
            s(:str, "      b = binding\n"),
            s(:str, "      puts eval(%{using M; \"hello world\".upcase}, b)\n"),
            s(:str, "      puts eval(%{\"hello world\".upcase}, b)\n")),
          s(:array,
            s(:str, "HELLO WORLD"),
            s(:str, "dlrow olleh"),
            s(:str, "dlrow olleh")),
          s(:array))),
      s(:def, :test_case_dispatch_is_aware_of_refinements,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      module RefineSymbol\n"),
            s(:str, "        refine Symbol do\n"),
            s(:str, "          def ===(other)\n"),
            s(:str, "            true\n"),
            s(:str, "          end\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      using RefineSymbol\n"),
            s(:str, "\n"),
            s(:str, "      case :a\n"),
            s(:str, "      when :b\n"),
            s(:str, "        puts \"refinement used\"\n"),
            s(:str, "      else\n"),
            s(:str, "        puts \"refinement not used\"\n"),
            s(:str, "      end\n")),
          s(:array,
            s(:str, "refinement used")),
          s(:array))),
      s(:def, :test_refine_after_using,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "      bug8880 = '[ruby-core:57079] [Bug #8880]'\n"),
            s(:str, "      module Test\n"),
            s(:str, "        refine(String) do\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "      using Test\n"),
            s(:str, "      def t\n"),
            s(:str, "        'Refinements are broken!'.chop!\n"),
            s(:str, "      end\n"),
            s(:str, "      t\n"),
            s(:str, "      module Test\n"),
            s(:str, "        refine(String) do\n"),
            s(:str, "          def chop!\n"),
            s(:str, "            self.sub!(/broken/, 'fine')\n"),
            s(:str, "          end\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "      assert_equal('Refinements are fine!', t, bug8880)\n")))),
      s(:def, :test_instance_methods,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug8881,
            s(:str, "[ruby-core:57080] [Bug #8881]")),
          s(:send, nil, :assert_not_include,
            s(:send,
              s(:const, nil, :Foo), :instance_methods,
              s(:false)),
            s(:sym, :z),
            s(:lvar, :bug8881)),
          s(:send, nil, :assert_not_include,
            s(:send,
              s(:const, nil, :FooSub), :instance_methods,
              s(:true)),
            s(:sym, :z),
            s(:lvar, :bug8881)))),
      s(:def, :test_method_defined,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_not_send,
            s(:array,
              s(:const, nil, :Foo),
              s(:sym, :method_defined?),
              s(:sym, :z))),
          s(:send, nil, :assert_not_send,
            s(:array,
              s(:const, nil, :FooSub),
              s(:sym, :method_defined?),
              s(:sym, :z))))),
      s(:def, :test_undef_refined_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug8966,
            s(:str, "[ruby-core:57466] [Bug #8966]")),
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:dstr,
              s(:str, "      module Foo\n"),
              s(:str, "        refine Object do\n"),
              s(:str, "          def foo\n"),
              s(:str, "            puts \"foo\"\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      using Foo\n"),
              s(:str, "\n"),
              s(:str, "      class Object\n"),
              s(:str, "        begin\n"),
              s(:str, "          undef foo\n"),
              s(:str, "        rescue Exception => e\n"),
              s(:str, "          p e.class\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n")),
            s(:array,
              s(:str, "NameError")),
            s(:array),
            s(:lvar, :bug8966)),
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:dstr,
              s(:str, "      module Foo\n"),
              s(:str, "        refine Object do\n"),
              s(:str, "          def foo\n"),
              s(:str, "            puts \"foo\"\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      # without `using Foo'\n"),
              s(:str, "\n"),
              s(:str, "      class Object\n"),
              s(:str, "        begin\n"),
              s(:str, "          undef foo\n"),
              s(:str, "        rescue Exception => e\n"),
              s(:str, "          p e.class\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n")),
            s(:array,
              s(:str, "NameError")),
            s(:array),
            s(:lvar, :bug8966)))),
      s(:def, :test_refine_undefed_method_and_call,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      class Foo\n"),
            s(:str, "        def foo\n"),
            s(:str, "        end\n"),
            s(:str, "\n"),
            s(:str, "        undef foo\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      module FooExt\n"),
            s(:str, "        refine Foo do\n"),
            s(:str, "          def foo\n"),
            s(:str, "          end\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      begin\n"),
            s(:str, "        Foo.new.foo\n"),
            s(:str, "      rescue => e\n"),
            s(:str, "        p e.class\n"),
            s(:str, "      end\n")),
          s(:array,
            s(:str, "NoMethodError")),
          s(:array))),
      s(:def, :test_refine_undefed_method_and_send,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      class Foo\n"),
            s(:str, "        def foo\n"),
            s(:str, "        end\n"),
            s(:str, "\n"),
            s(:str, "        undef foo\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      module FooExt\n"),
            s(:str, "        refine Foo do\n"),
            s(:str, "          def foo\n"),
            s(:str, "          end\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      begin\n"),
            s(:str, "        Foo.new.send(:foo)\n"),
            s(:str, "      rescue => e\n"),
            s(:str, "        p e.class\n"),
            s(:str, "      end\n")),
          s(:array,
            s(:str, "NoMethodError")),
          s(:array))),
      s(:def, :test_adding_private_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug9452,
            s(:str, "[ruby-core:60111] [Bug #9452]")),
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:dstr,
              s(:str, "      module R\n"),
              s(:str, "        refine Object do\n"),
              s(:str, "          def m\n"),
              s(:str, "            puts \"Success!\"\n"),
              s(:str, "          end\n"),
              s(:str, "\n"),
              s(:str, "          private(:m)\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      using R\n"),
              s(:str, "\n"),
              s(:str, "      m\n"),
              s(:str, "      42.m rescue p($!.class)\n")),
            s(:array,
              s(:str, "Success!"),
              s(:str, "NoMethodError")),
            s(:array),
            s(:lvar, :bug9452)))),
      s(:def, :test_making_private_method_public,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug9452,
            s(:str, "[ruby-core:60111] [Bug #9452]")),
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:dstr,
              s(:str, "        class Object\n"),
              s(:str, "          private\n"),
              s(:str, "          def m\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "\n"),
              s(:str, "        module R\n"),
              s(:str, "          refine Object do\n"),
              s(:str, "            def m\n"),
              s(:str, "              puts \"Success!\"\n"),
              s(:str, "            end\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "\n"),
              s(:str, "        using R\n"),
              s(:str, "        m\n"),
              s(:str, "        42.m\n")),
            s(:array,
              s(:str, "Success!"),
              s(:str, "Success!")),
            s(:array),
            s(:lvar, :bug9452)))),
      s(:def, :test_refine_basic_object,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_separately,
            s(:array),
            s(:dstr,
              s(:str, "    bug10106 = '[ruby-core:64166] [Bug #10106]'\n"),
              s(:str, "    module RefinementBug\n"),
              s(:str, "      refine BasicObject do\n"),
              s(:str, "        def foo\n"),
              s(:str, "          1\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "    end\n"),
              s(:str, "\n"),
              s(:str, "    assert_raise(NoMethodError, bug10106) {Object.new.foo}\n"))),
          s(:send, nil, :assert_separately,
            s(:array),
            s(:dstr,
              s(:str, "    bug10707 = '[ruby-core:67389] [Bug #10707]'\n"),
              s(:str, "    module RefinementBug\n"),
              s(:str, "      refine BasicObject do\n"),
              s(:str, "        def foo\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "    end\n"),
              s(:str, "\n"),
              s(:str, "    assert(methods, bug10707)\n"),
              s(:str, "    assert_raise(NameError, bug10707) {method(:foo)}\n"))))),
      s(:def, :test_change_refined_new_method_visibility,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "    bug10706 = '[ruby-core:67387] [Bug #10706]'\n"),
            s(:str, "    module RefinementBug\n"),
            s(:str, "      refine Object do\n"),
            s(:str, "        def foo\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    assert_raise(NameError, bug10706) {private(:foo)}\n")))),
      s(:def, :test_alias_refined_method,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "    bug10731 = '[ruby-core:67523] [Bug #10731]'\n"),
            s(:str, "\n"),
            s(:str, "    class C\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    module RefinementBug\n"),
            s(:str, "      refine C do\n"),
            s(:str, "        def foo\n"),
            s(:str, "        end\n"),
            s(:str, "\n"),
            s(:str, "        def bar\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    assert_raise(NameError, bug10731) do\n"),
            s(:str, "      class C\n"),
            s(:str, "        alias foo bar\n"),
            s(:str, "      end\n"),
            s(:str, "    end\n")))),
      s(:def, :test_singleton_method_should_not_use_refinements,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "    bug10744 = '[ruby-core:67603] [Bug #10744]'\n"),
            s(:str, "\n"),
            s(:str, "    class C\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    module RefinementBug\n"),
            s(:str, "      refine C.singleton_class do\n"),
            s(:str, "        def foo\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    assert_raise(NameError, bug10744) { C.singleton_method(:foo) }\n")))),
      s(:def, :test_refined_method_defined,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "    bug10753 = '[ruby-core:67656] [Bug #10753]'\n"),
            s(:str, "\n"),
            s(:str, "    c = Class.new do\n"),
            s(:str, "      def refined_public; end\n"),
            s(:str, "      def refined_protected; end\n"),
            s(:str, "      def refined_private; end\n"),
            s(:str, "\n"),
            s(:str, "      public :refined_public\n"),
            s(:str, "      protected :refined_protected\n"),
            s(:str, "      private :refined_private\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    m = Module.new do\n"),
            s(:str, "      refine(c) do\n"),
            s(:str, "        def refined_public; end\n"),
            s(:str, "        def refined_protected; end\n"),
            s(:str, "        def refined_private; end\n"),
            s(:str, "\n"),
            s(:str, "        public :refined_public\n"),
            s(:str, "        protected :refined_protected\n"),
            s(:str, "        private :refined_private\n"),
            s(:str, "      end\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    using m\n"),
            s(:str, "\n"),
            s(:str, "    assert_equal(true, c.public_method_defined?(:refined_public), bug10753)\n"),
            s(:str, "    assert_equal(false, c.public_method_defined?(:refined_protected), bug10753)\n"),
            s(:str, "    assert_equal(false, c.public_method_defined?(:refined_private), bug10753)\n"),
            s(:str, "\n"),
            s(:str, "    assert_equal(false, c.protected_method_defined?(:refined_public), bug10753)\n"),
            s(:str, "    assert_equal(true, c.protected_method_defined?(:refined_protected), bug10753)\n"),
            s(:str, "    assert_equal(false, c.protected_method_defined?(:refined_private), bug10753)\n"),
            s(:str, "\n"),
            s(:str, "    assert_equal(false, c.private_method_defined?(:refined_public), bug10753)\n"),
            s(:str, "    assert_equal(false, c.private_method_defined?(:refined_protected), bug10753)\n"),
            s(:str, "    assert_equal(true, c.private_method_defined?(:refined_private), bug10753)\n")))),
      s(:def, :test_undefined_refined_method_defined,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "    bug10753 = '[ruby-core:67656] [Bug #10753]'\n"),
            s(:str, "\n"),
            s(:str, "    c = Class.new\n"),
            s(:str, "\n"),
            s(:str, "    m = Module.new do\n"),
            s(:str, "      refine(c) do\n"),
            s(:str, "        def undefined_refined_public; end\n"),
            s(:str, "        def undefined_refined_protected; end\n"),
            s(:str, "        def undefined_refined_private; end\n"),
            s(:str, "        public :undefined_refined_public\n"),
            s(:str, "        protected :undefined_refined_protected\n"),
            s(:str, "        private :undefined_refined_private\n"),
            s(:str, "      end\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    using m\n"),
            s(:str, "\n"),
            s(:str, "    assert_equal(false, c.public_method_defined?(:undefined_refined_public), bug10753)\n"),
            s(:str, "    assert_equal(false, c.public_method_defined?(:undefined_refined_protected), bug10753)\n"),
            s(:str, "    assert_equal(false, c.public_method_defined?(:undefined_refined_private), bug10753)\n"),
            s(:str, "\n"),
            s(:str, "    assert_equal(false, c.protected_method_defined?(:undefined_refined_public), bug10753)\n"),
            s(:str, "    assert_equal(false, c.protected_method_defined?(:undefined_refined_protected), bug10753)\n"),
            s(:str, "    assert_equal(false, c.protected_method_defined?(:undefined_refined_private), bug10753)\n"),
            s(:str, "\n"),
            s(:str, "    assert_equal(false, c.private_method_defined?(:undefined_refined_public), bug10753)\n"),
            s(:str, "    assert_equal(false, c.private_method_defined?(:undefined_refined_protected), bug10753)\n"),
            s(:str, "    assert_equal(false, c.private_method_defined?(:undefined_refined_private), bug10753)\n")))),
      s(:def, :test_remove_refined_method,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "    bug10765 = '[ruby-core:67722] [Bug #10765]'\n"),
            s(:str, "\n"),
            s(:str, "    class C\n"),
            s(:str, "      def foo\n"),
            s(:str, "        \"C#foo\"\n"),
            s(:str, "      end\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    module RefinementBug\n"),
            s(:str, "      refine C do\n"),
            s(:str, "        def foo\n"),
            s(:str, "          \"RefinementBug#foo\"\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    using RefinementBug\n"),
            s(:str, "\n"),
            s(:str, "    class C\n"),
            s(:str, "      remove_method :foo\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    assert_equal(\"RefinementBug#foo\", C.new.foo, bug10765)\n")))),
      s(:def, :test_remove_undefined_refined_method,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "    bug10765 = '[ruby-core:67722] [Bug #10765]'\n"),
            s(:str, "\n"),
            s(:str, "    class C\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    module RefinementBug\n"),
            s(:str, "      refine C do\n"),
            s(:str, "        def foo\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "    end\n"),
            s(:str, "\n"),
            s(:str, "    using RefinementBug\n"),
            s(:str, "\n"),
            s(:str, "    assert_raise(NameError, bug10765) {\n"),
            s(:str, "      class C\n"),
            s(:str, "        remove_method :foo\n"),
            s(:str, "      end\n"),
            s(:str, "    }\n")))),
      s(:module,
        s(:const, nil, :NotIncludeSuperclassMethod),
        s(:begin,
          s(:class,
            s(:const, nil, :X), nil,
            s(:def, :foo,
              s(:args), nil)),
          s(:class,
            s(:const, nil, :Y),
            s(:const, nil, :X), nil),
          s(:module,
            s(:const, nil, :Bar),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :Y)),
              s(:args),
              s(:def, :foo,
                s(:args), nil))))),
      s(:def, :test_instance_methods_not_include_superclass_method,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug10826,
            s(:str, "[ruby-dev:48854] [Bug #10826]")),
          s(:send, nil, :assert_not_include,
            s(:send,
              s(:const,
                s(:const, nil, :NotIncludeSuperclassMethod), :Y), :instance_methods,
              s(:false)),
            s(:sym, :foo),
            s(:lvar, :bug10826)),
          s(:send, nil, :assert_include,
            s(:send,
              s(:const,
                s(:const, nil, :NotIncludeSuperclassMethod), :Y), :instance_methods,
              s(:true)),
            s(:sym, :foo),
            s(:lvar, :bug10826)))),
      s(:def, :test_undef_original_method,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array),
          s(:dstr,
            s(:str, "      module NoPlus\n"),
            s(:str, "        refine String do\n"),
            s(:str, "          undef +\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      using NoPlus\n"),
            s(:str, "      \"a\" + \"b\" rescue p($!.class)\n")),
          s(:array,
            s(:str, "NoMethodError")),
          s(:array))),
      s(:def, :test_call_refined_method_in_duplicate_module,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug10885,
            s(:str, "[ruby-dev:48878]")),
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:dstr,
              s(:str, "      module M\n"),
              s(:str, "        refine Object do\n"),
              s(:str, "          def raise\n"),
              s(:str, "            # do nothing\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "\n"),
              s(:str, "        class << self\n"),
              s(:str, "          using M\n"),
              s(:str, "          def m0\n"),
              s(:str, "            raise\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "\n"),
              s(:str, "        using M\n"),
              s(:str, "        def M.m1\n"),
              s(:str, "          raise\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      M.dup.m0\n"),
              s(:str, "      M.dup.m1\n")),
            s(:array),
            s(:array),
            s(:lvar, :bug10885)))),
      s(:def, :test_check_funcall_undefined,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug11117,
            s(:str, "[ruby-core:69064] [Bug #11117]")),
          s(:lvasgn, :x,
            s(:send,
              s(:const, nil, :Class), :new)),
          s(:block,
            s(:send,
              s(:const, nil, :Module), :new),
            s(:args),
            s(:block,
              s(:send, nil, :refine,
                s(:lvar, :x)),
              s(:args),
              s(:def, :to_regexp,
                s(:args),
                s(:regexp,
                  s(:regopt))))),
          s(:block,
            s(:send, nil, :assert_nothing_raised,
              s(:const, nil, :NoMethodError),
              s(:lvar, :bug11117)),
            s(:args),
            s(:send, nil, :assert_nil,
              s(:send,
                s(:const, nil, :Regexp), :try_convert,
                s(:send,
                  s(:lvar, :x), :new)))))),
      s(:def, :test_funcall_inherited,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug11117,
            s(:str, "[ruby-core:69064] [Bug #11117]")),
          s(:block,
            s(:send,
              s(:const, nil, :Module), :new),
            s(:args),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :Dir)),
              s(:args),
              s(:def, :to_s,
                s(:args), nil))),
          s(:lvasgn, :x,
            s(:send,
              s(:send,
                s(:const, nil, :Class), :new,
                s(:const, nil, :Dir)), :allocate)),
          s(:block,
            s(:send, nil, :assert_nothing_raised,
              s(:const, nil, :NoMethodError),
              s(:lvar, :bug11117)),
            s(:args),
            s(:send,
              s(:lvar, :x), :inspect)))),
      s(:def, :test_alias_refined_method2,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug11182,
            s(:str, "[ruby-core:69360]")),
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:dstr,
              s(:str, "      class C\n"),
              s(:str, "        def foo\n"),
              s(:str, "          puts \"C\"\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      module M\n"),
              s(:str, "        refine C do\n"),
              s(:str, "          def foo\n"),
              s(:str, "            puts \"Refined C\"\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      class D < C\n"),
              s(:str, "        alias bar foo\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      using M\n"),
              s(:str, "      D.new.bar\n")),
            s(:array,
              s(:str, "C")),
            s(:array),
            s(:lvar, :bug11182)))),
      s(:def, :test_reopen_refinement_module,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "      $VERBOSE = nil\n"),
            s(:str, "      class C\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      module R\n"),
            s(:str, "        refine C do\n"),
            s(:str, "          def m\n"),
            s(:str, "            :foo\n"),
            s(:str, "          end\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      using R\n"),
            s(:str, "      assert_equal(:foo, C.new.m)\n"),
            s(:str, "\n"),
            s(:str, "      module R\n"),
            s(:str, "        refine C do\n"),
            s(:str, "          def m\n"),
            s(:str, "            :bar\n"),
            s(:str, "          end\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "\n"),
            s(:str, "      assert_equal(:bar, C.new.m, \"[ruby-core:71423] [Bug #11672]\")\n")))),
      s(:module,
        s(:const, nil, :MixedUsing1),
        s(:begin,
          s(:class,
            s(:const, nil, :C), nil,
            s(:def, :foo,
              s(:args),
              s(:sym, :orig_foo))),
          s(:module,
            s(:const, nil, :R1),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :C)),
              s(:args),
              s(:def, :foo,
                s(:args),
                s(:array,
                  s(:sym, :R1),
                  s(:zsuper))))),
          s(:send, nil, :module_function),
          s(:def, :foo,
            s(:args),
            s(:array,
              s(:sym, :foo),
              s(:send,
                s(:send,
                  s(:const, nil, :C), :new), :foo))),
          s(:send, nil, :using,
            s(:const, nil, :R1)),
          s(:def, :bar,
            s(:args),
            s(:array,
              s(:sym, :bar),
              s(:send,
                s(:send,
                  s(:const, nil, :C), :new), :foo))))),
      s(:module,
        s(:const, nil, :MixedUsing2),
        s(:begin,
          s(:class,
            s(:const, nil, :C), nil,
            s(:def, :foo,
              s(:args),
              s(:sym, :orig_foo))),
          s(:module,
            s(:const, nil, :R1),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :C)),
              s(:args),
              s(:def, :foo,
                s(:args),
                s(:array,
                  s(:sym, :R1_foo),
                  s(:zsuper))))),
          s(:module,
            s(:const, nil, :R2),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :C)),
              s(:args),
              s(:begin,
                s(:def, :bar,
                  s(:args),
                  s(:array,
                    s(:sym, :R2_bar),
                    s(:send,
                      s(:send,
                        s(:const, nil, :C), :new), :foo))),
                s(:send, nil, :using,
                  s(:const, nil, :R1)),
                s(:def, :baz,
                  s(:args),
                  s(:array,
                    s(:sym, :R2_baz),
                    s(:send,
                      s(:send,
                        s(:const, nil, :C), :new), :foo)))))),
          s(:send, nil, :using,
            s(:const, nil, :R2)),
          s(:send, nil, :module_function),
          s(:def, :f1,
            s(:args),
            s(:send,
              s(:send,
                s(:const, nil, :C), :new), :bar)),
          s(:def, :f2,
            s(:args),
            s(:send,
              s(:send,
                s(:const, nil, :C), :new), :baz)))),
      s(:def, :test_mixed_using,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:array,
              s(:sym, :foo),
              s(:sym, :orig_foo)),
            s(:send,
              s(:const, nil, :MixedUsing1), :foo)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:sym, :bar),
              s(:array,
                s(:sym, :R1),
                s(:sym, :orig_foo))),
            s(:send,
              s(:const, nil, :MixedUsing1), :bar)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:sym, :R2_bar),
              s(:sym, :orig_foo)),
            s(:send,
              s(:const, nil, :MixedUsing2), :f1)),
          s(:send, nil, :assert_equal,
            s(:array,
              s(:sym, :R2_baz),
              s(:array,
                s(:sym, :R1_foo),
                s(:sym, :orig_foo))),
            s(:send,
              s(:const, nil, :MixedUsing2), :f2)))),
      s(:module,
        s(:const, nil, :MethodMissing),
        s(:begin,
          s(:class,
            s(:const, nil, :Foo), nil, nil),
          s(:module,
            s(:const, nil, :Bar),
            s(:block,
              s(:send, nil, :refine,
                s(:const, nil, :Foo)),
              s(:args),
              s(:def, :method_missing,
                s(:args,
                  s(:arg, :mid),
                  s(:restarg, :args)),
                s(:str, "method_missing refined")))),
          s(:send, nil, :using,
            s(:const, nil, :Bar)),
          s(:defs,
            s(:self), :call_undefined_method,
            s(:args),
            s(:send,
              s(:send,
                s(:const, nil, :Foo), :new), :foo)))),
      s(:def, :test_method_missing,
        s(:args),
        s(:block,
          s(:send, nil, :assert_raise,
            s(:const, nil, :NoMethodError)),
          s(:args),
          s(:send,
            s(:const, nil, :MethodMissing), :call_undefined_method))),
      s(:def, :test_refine_with_prepend,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:begin,
              s(:dstr)),
            s(:str, "\n"),
            s(:begin,
              s(:dstr,
                s(:str, "      bug = '[ruby-core:78073] [Bug #12920]'\n"),
                s(:str, "      Fixnum.prepend(Module.new)\n"),
                s(:str, "      Module.new do\n"),
                s(:str, "        refine Fixnum do\n"),
                s(:str, "          define_method(:+) {}\n"),
                s(:str, "        end\n"),
                s(:str, "      end\n"),
                s(:str, "      assert_kind_of(Time, Time.now, bug)\n")))))),
      s(:send, nil, :private),
      s(:def, :eval_using,
        s(:args,
          s(:arg, :mod),
          s(:arg, :s)),
        s(:send, nil, :eval,
          s(:dstr,
            s(:str, "using "),
            s(:begin,
              s(:lvar, :mod)),
            s(:str, "; "),
            s(:begin,
              s(:lvar, :s))),
          s(:const,
            s(:const, nil, :Sandbox), :BINDING))))))
