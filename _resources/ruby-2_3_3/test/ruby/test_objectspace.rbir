s(:begin,
  s(:send, nil, :require,
    s(:str, "test/unit")),
  s(:class,
    s(:const, nil, :TestObjectSpace),
    s(:const,
      s(:const,
        s(:const, nil, :Test), :Unit), :TestCase),
    s(:begin,
      s(:defs,
        s(:self), :deftest_id2ref,
        s(:args,
          s(:arg, :obj)),
        s(:begin,
          s(:match_with_lvasgn,
            s(:regexp,
              s(:str, ":(\\d+)"),
              s(:regopt)),
            s(:send,
              s(:send, nil, :caller), :[],
              s(:int, 0))),
          s(:lvasgn, :file,
            s(:back_ref, :$`)),
          s(:lvasgn, :line,
            s(:send,
              s(:nth_ref, 1), :to_i)),
          s(:lvasgn, :code,
            s(:dstr,
              s(:str, "    define_method(\"test_id2ref_"),
              s(:begin,
                s(:lvar, :line)),
              s(:str, "\") {\n      o = ObjectSpace._id2ref(obj.object_id);\n      assert_same(obj, o, \"didn't round trip: \#{obj.inspect}\");\n    }\n"))),
          s(:send, nil, :eval,
            s(:lvar, :code),
            s(:send, nil, :binding),
            s(:lvar, :file),
            s(:lvar, :line)))),
      s(:send, nil, :deftest_id2ref,
        s(:int, -4611686018427387905)),
      s(:send, nil, :deftest_id2ref,
        s(:int, -4611686018427387904)),
      s(:send, nil, :deftest_id2ref,
        s(:int, -1073741825)),
      s(:send, nil, :deftest_id2ref,
        s(:int, -1073741824)),
      s(:send, nil, :deftest_id2ref,
        s(:int, -1)),
      s(:send, nil, :deftest_id2ref,
        s(:int, 0)),
      s(:send, nil, :deftest_id2ref,
        s(:int, 1)),
      s(:send, nil, :deftest_id2ref,
        s(:int, 1073741823)),
      s(:send, nil, :deftest_id2ref,
        s(:int, 1073741824)),
      s(:send, nil, :deftest_id2ref,
        s(:int, 4611686018427387903)),
      s(:send, nil, :deftest_id2ref,
        s(:int, 4611686018427387904)),
      s(:send, nil, :deftest_id2ref,
        s(:sym, :a)),
      s(:send, nil, :deftest_id2ref,
        s(:sym, :abcdefghijilkjl)),
      s(:send, nil, :deftest_id2ref,
        s(:sym, :==)),
      s(:send, nil, :deftest_id2ref,
        s(:send,
          s(:const, nil, :Object), :new)),
      s(:send, nil, :deftest_id2ref,
        s(:self)),
      s(:send, nil, :deftest_id2ref,
        s(:true)),
      s(:send, nil, :deftest_id2ref,
        s(:false)),
      s(:send, nil, :deftest_id2ref,
        s(:nil)),
      s(:def, :test_count_objects,
        s(:args),
        s(:begin,
          s(:lvasgn, :h,
            s(:hash)),
          s(:send,
            s(:const, nil, :ObjectSpace), :count_objects,
            s(:lvar, :h)),
          s(:send, nil, :assert_kind_of,
            s(:const, nil, :Hash),
            s(:lvar, :h)),
          s(:send, nil, :assert_empty,
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :h), :keys), :delete_if),
              s(:args,
                s(:arg, :x)),
              s(:or,
                s(:send,
                  s(:lvar, :x), :is_a?,
                  s(:const, nil, :Symbol)),
                s(:send,
                  s(:lvar, :x), :is_a?,
                  s(:const, nil, :Integer))))),
          s(:send, nil, :assert_empty,
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :h), :values), :delete_if),
              s(:args,
                s(:arg, :x)),
              s(:send,
                s(:lvar, :x), :is_a?,
                s(:const, nil, :Integer)))),
          s(:lvasgn, :h,
            s(:send,
              s(:const, nil, :ObjectSpace), :count_objects)),
          s(:send, nil, :assert_kind_of,
            s(:const, nil, :Hash),
            s(:lvar, :h)),
          s(:send, nil, :assert_empty,
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :h), :keys), :delete_if),
              s(:args,
                s(:arg, :x)),
              s(:or,
                s(:send,
                  s(:lvar, :x), :is_a?,
                  s(:const, nil, :Symbol)),
                s(:send,
                  s(:lvar, :x), :is_a?,
                  s(:const, nil, :Integer))))),
          s(:send, nil, :assert_empty,
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :h), :values), :delete_if),
              s(:args,
                s(:arg, :x)),
              s(:send,
                s(:lvar, :x), :is_a?,
                s(:const, nil, :Integer)))),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :TypeError)),
            s(:args),
            s(:send,
              s(:const, nil, :ObjectSpace), :count_objects,
              s(:int, 1))),
          s(:lvasgn, :h0,
            s(:hash,
              s(:pair,
                s(:sym, :T_FOO),
                s(:int, 1000)))),
          s(:lvasgn, :h,
            s(:send,
              s(:const, nil, :ObjectSpace), :count_objects,
              s(:lvar, :h0))),
          s(:send, nil, :assert_same,
            s(:lvar, :h0),
            s(:lvar, :h)),
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:lvar, :h0), :[],
              s(:sym, :T_FOO))))),
      s(:def, :test_finalizer,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_in_out_err,
            s(:array,
              s(:str, "-e"),
              s(:dstr,
                s(:str, "      a = []\n"),
                s(:str, "      ObjectSpace.define_finalizer(a) { p :ok }\n"),
                s(:str, "      b = a.dup\n"),
                s(:str, "      ObjectSpace.define_finalizer(a) { p :ok }\n"),
                s(:str, "      !b\n"))),
            s(:str, ""),
            s(:array,
              s(:str, ":ok"),
              s(:str, ":ok"),
              s(:str, ":ok"),
              s(:str, ":ok")),
            s(:array)),
          s(:block,
            s(:send, nil, :assert_raise,
              s(:const, nil, :ArgumentError)),
            s(:args),
            s(:send,
              s(:const, nil, :ObjectSpace), :define_finalizer,
              s(:array),
              s(:send,
                s(:const, nil, :Object), :new))),
          s(:lvasgn, :code,
            s(:block,
              s(:send, nil, :proc),
              s(:args,
                s(:arg, :priv)),
              s(:dstr,
                s(:str, "      fin = Object.new\n"),
                s(:str, "      class << fin\n"),
                s(:str, "        "),
                s(:begin,
                  s(:lvar, :priv)),
                s(:str, "def call(id)\n"),
                s(:str, "          puts \"finalized\"\n"),
                s(:str, "        end\n"),
                s(:str, "      end\n"),
                s(:str, "      ObjectSpace.define_finalizer([], fin)\n")))),
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:send,
              s(:lvar, :code), :[],
              s(:str, "")),
            s(:array,
              s(:str, "finalized"))),
          s(:send, nil, :assert_in_out_err,
            s(:array),
            s(:send,
              s(:lvar, :code), :[],
              s(:str, "private ")),
            s(:array,
              s(:str, "finalized"))),
          s(:lvasgn, :c,
            s(:send,
              s(:send,
                s(:const, nil, :EnvUtil), :labeled_class,
                s(:str, "Cあ")), :new)),
          s(:lvasgn, :o,
            s(:send,
              s(:const, nil, :Object), :new)),
          s(:block,
            s(:send, nil, :assert_raise_with_message,
              s(:const, nil, :ArgumentError),
              s(:regexp,
                s(:str, "C\\u{3042}"),
                s(:regopt))),
            s(:args),
            s(:send,
              s(:const, nil, :ObjectSpace), :define_finalizer,
              s(:lvar, :o),
              s(:lvar, :c))))),
      s(:def, :test_finalizer_with_super,
        s(:args),
        s(:send, nil, :assert_in_out_err,
          s(:array,
            s(:str, "-e"),
            s(:dstr,
              s(:str, "      class A\n"),
              s(:str, "        def foo\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      class B < A\n"),
              s(:str, "        def foo\n"),
              s(:str, "          1.times { super }\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      class C\n"),
              s(:str, "        module M\n"),
              s(:str, "        end\n"),
              s(:str, "\n"),
              s(:str, "        FINALIZER = proc do\n"),
              s(:str, "          M.module_eval do\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "\n"),
              s(:str, "        def define_finalizer\n"),
              s(:str, "          ObjectSpace.define_finalizer(self, FINALIZER)\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      class D\n"),
              s(:str, "        def foo\n"),
              s(:str, "          B.new.foo\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      C::M.singleton_class.send :define_method, :module_eval do |src, id, line|\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      GC.stress = true\n"),
              s(:str, "      10.times do\n"),
              s(:str, "        C.new.define_finalizer\n"),
              s(:str, "        D.new.foo\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      p :ok\n"))),
          s(:str, ""),
          s(:array,
            s(:str, ":ok")),
          s(:array))),
      s(:def, :test_each_object,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const, nil, :Class), :new)),
          s(:lvasgn, :new_obj,
            s(:send,
              s(:lvar, :klass), :new)),
          s(:lvasgn, :found,
            s(:array)),
          s(:lvasgn, :count,
            s(:block,
              s(:send,
                s(:const, nil, :ObjectSpace), :each_object,
                s(:lvar, :klass)),
              s(:args,
                s(:arg, :obj)),
              s(:send,
                s(:lvar, :found), :<<,
                s(:lvar, :obj)))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:lvar, :count)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :found), :size)),
          s(:send, nil, :assert_same,
            s(:lvar, :new_obj),
            s(:send,
              s(:lvar, :found), :[],
              s(:int, 0))))),
      s(:def, :test_each_object_enumerator,
        s(:args),
        s(:begin,
          s(:lvasgn, :klass,
            s(:send,
              s(:const, nil, :Class), :new)),
          s(:lvasgn, :new_obj,
            s(:send,
              s(:lvar, :klass), :new)),
          s(:lvasgn, :found,
            s(:array)),
          s(:lvasgn, :counter,
            s(:send,
              s(:const, nil, :ObjectSpace), :each_object,
              s(:lvar, :klass))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:block,
              s(:send,
                s(:lvar, :counter), :each),
              s(:args,
                s(:arg, :obj)),
              s(:send,
                s(:lvar, :found), :<<,
                s(:lvar, :obj)))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :found), :size)),
          s(:send, nil, :assert_same,
            s(:lvar, :new_obj),
            s(:send,
              s(:lvar, :found), :[],
              s(:int, 0))))),
      s(:def, :test_each_object_no_gabage,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "    GC.disable\n"),
            s(:str, "    eval('begin; 1.times{}; rescue; ensure; end')\n"),
            s(:str, "    arys = []\n"),
            s(:str, "    ObjectSpace.each_object(Array){|ary|\n"),
            s(:str, "      arys << ary\n"),
            s(:str, "    }\n"),
            s(:str, "    GC.enable\n"),
            s(:str, "    arys.each{|ary|\n"),
            s(:str, "      begin\n"),
            s(:str, "        assert_equal(String, ary.inspect.class) # should not cause SEGV\n"),
            s(:str, "      rescue RuntimeError\n"),
            s(:str, "        # rescue \"can't modify frozen File\" error.\n"),
            s(:str, "      end\n"),
            s(:str, "    }\n")))),
      s(:def, :test_each_object_recursive_key,
        s(:args),
        s(:send, nil, :assert_normal_exit,
          s(:dstr,
            s(:str, "      h = {[\"foo\"]=>nil}\n"),
            s(:str, "      p Thread.current[:__recursive_key__]\n")),
          s(:str, "[ruby-core:66742] [Bug #10579]"))),
      s(:def, :test_each_object_singleton_class,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_separately,
            s(:array),
            s(:dstr,
              s(:str, "      class C\n"),
              s(:str, "        class << self\n"),
              s(:str, "          $c = self\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      exist = false\n"),
              s(:str, "      ObjectSpace.each_object(Class){|o|\n"),
              s(:str, "        exist = true if $c == o\n"),
              s(:str, "      }\n"),
              s(:str, "      assert(exist, 'Bug #11360')\n"))),
          s(:lvasgn, :klass,
            s(:send,
              s(:const, nil, :Class), :new)),
          s(:lvasgn, :instance,
            s(:send,
              s(:lvar, :klass), :new)),
          s(:lvasgn, :sclass,
            s(:send,
              s(:lvar, :instance), :singleton_class)),
          s(:lvasgn, :meta,
            s(:send,
              s(:lvar, :klass), :singleton_class)),
          s(:send, nil, :assert_kind_of,
            s(:lvar, :meta),
            s(:lvar, :sclass)),
          s(:send, nil, :assert_include,
            s(:send,
              s(:send,
                s(:const, nil, :ObjectSpace), :each_object,
                s(:lvar, :meta)), :to_a),
            s(:lvar, :sclass)))))))
