s(:begin,
  s(:send, nil, :require,
    s(:str, "test/unit")),
  s(:send, nil, :require,
    s(:str, "objspace")),
  s(:class,
    s(:const, nil, :TestRubyOptimization),
    s(:const,
      s(:const,
        s(:const, nil, :Test), :Unit), :TestCase),
    s(:begin,
      s(:casgn, nil, :BIGNUM_POS_MIN_32,
        s(:int, 1073741824)),
      s(:if,
        s(:send,
          s(:const, nil, :BIGNUM_POS_MIN_32), :kind_of?,
          s(:const, nil, :Fixnum)),
        s(:casgn, nil, :FIXNUM_MAX,
          s(:int, 4611686018427387903)),
        s(:casgn, nil, :FIXNUM_MAX,
          s(:int, 1073741823))),
      s(:casgn, nil, :BIGNUM_NEG_MAX_32,
        s(:int, -1073741825)),
      s(:if,
        s(:send,
          s(:const, nil, :BIGNUM_NEG_MAX_32), :kind_of?,
          s(:const, nil, :Fixnum)),
        s(:casgn, nil, :FIXNUM_MIN,
          s(:int, -4611686018427387904)),
        s(:casgn, nil, :FIXNUM_MIN,
          s(:int, -1073741824))),
      s(:def, :assert_redefine_method,
        s(:args,
          s(:arg, :klass),
          s(:arg, :method),
          s(:arg, :code),
          s(:optarg, :msg,
            s(:nil))),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "      class "),
            s(:begin,
              s(:lvar, :klass)),
            s(:str, "\n"),
            s(:str, "        undef "),
            s(:begin,
              s(:lvar, :method)),
            s(:str, "\n"),
            s(:str, "        def "),
            s(:begin,
              s(:lvar, :method)),
            s(:str, "(*args)\n"),
            s(:str, "          args[0]\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "      "),
            s(:begin,
              s(:lvar, :code)),
            s(:str, "\n")))),
      s(:def, :test_fixnum_plus,
        s(:args),
        s(:begin,
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :a),
              s(:lvasgn, :b)),
            s(:array,
              s(:int, 1),
              s(:int, 2))),
          s(:send, nil, :assert_equal,
            s(:int, 3),
            s(:send,
              s(:lvar, :a), :+,
              s(:lvar, :b))),
          s(:send, nil, :assert_instance_of,
            s(:const, nil, :Fixnum),
            s(:const, nil, :FIXNUM_MAX)),
          s(:send, nil, :assert_instance_of,
            s(:const, nil, :Bignum),
            s(:send,
              s(:const, nil, :FIXNUM_MAX), :+,
              s(:int, 1))),
          s(:send, nil, :assert_equal,
            s(:int, 21),
            s(:send,
              s(:int, 10), :+,
              s(:int, 11))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Fixnum"),
            s(:str, "+"),
            s(:str, "assert_equal 11, 10 + 11")))),
      s(:def, :test_fixnum_minus,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:int, 5),
            s(:send,
              s(:int, 8), :-,
              s(:int, 3))),
          s(:send, nil, :assert_instance_of,
            s(:const, nil, :Fixnum),
            s(:const, nil, :FIXNUM_MIN)),
          s(:send, nil, :assert_instance_of,
            s(:const, nil, :Bignum),
            s(:send,
              s(:const, nil, :FIXNUM_MIN), :-,
              s(:int, 1))),
          s(:send, nil, :assert_equal,
            s(:int, 5),
            s(:send,
              s(:int, 8), :-,
              s(:int, 3))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Fixnum"),
            s(:str, "-"),
            s(:str, "assert_equal 3, 8 - 3")))),
      s(:def, :test_fixnum_mul,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:int, 15),
            s(:send,
              s(:int, 3), :*,
              s(:int, 5))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Fixnum"),
            s(:str, "*"),
            s(:str, "assert_equal 5, 3 * 5")))),
      s(:def, :test_fixnum_div,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:int, 3),
            s(:send,
              s(:int, 15), :/,
              s(:int, 5))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Fixnum"),
            s(:str, "/"),
            s(:str, "assert_equal 5, 15 / 5")))),
      s(:def, :test_fixnum_mod,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:int, 8), :%,
              s(:int, 7))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Fixnum"),
            s(:str, "%"),
            s(:str, "assert_equal 7, 8 % 7")))),
      s(:def, :test_float_plus,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:float, 4.0),
            s(:send,
              s(:float, 2.0), :+,
              s(:float, 2.0))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Float"),
            s(:str, "+"),
            s(:str, "assert_equal 2.0, 2.0 + 2.0")))),
      s(:def, :test_float_minus,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:float, 4.0),
            s(:send,
              s(:float, 2.0), :+,
              s(:float, 2.0))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Float"),
            s(:str, "+"),
            s(:str, "assert_equal 2.0, 2.0 + 2.0")))),
      s(:def, :test_float_mul,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:float, 29.25),
            s(:send,
              s(:float, 4.5), :*,
              s(:float, 6.5))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Float"),
            s(:str, "*"),
            s(:str, "assert_equal 6.5, 4.5 * 6.5")))),
      s(:def, :test_float_div,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_in_delta,
            s(:float, 0.6306306306306306),
            s(:send,
              s(:float, 4.2), :/,
              s(:float, 6.66))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Float"),
            s(:str, "/"),
            s(:str, "assert_equal 6.66, 4.2 / 6.66"),
            s(:str, "[Bug #9238]")))),
      s(:def, :test_string_length,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:int, 6),
            s(:send,
              s(:str, "string"), :length)),
          s(:send, nil, :assert_redefine_method,
            s(:str, "String"),
            s(:str, "length"),
            s(:str, "assert_nil \"string\".length")))),
      s(:def, :test_string_size,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:int, 6),
            s(:send,
              s(:str, "string"), :size)),
          s(:send, nil, :assert_redefine_method,
            s(:str, "String"),
            s(:str, "size"),
            s(:str, "assert_nil \"string\".size")))),
      s(:def, :test_string_empty?,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:str, ""), :empty?)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:str, "string"), :empty?)),
          s(:send, nil, :assert_redefine_method,
            s(:str, "String"),
            s(:str, "empty?"),
            s(:str, "assert_nil \"string\".empty?")))),
      s(:def, :test_string_plus,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:str, ""),
            s(:send,
              s(:str, ""), :+,
              s(:str, ""))),
          s(:send, nil, :assert_equal,
            s(:str, "x"),
            s(:send,
              s(:str, "x"), :+,
              s(:str, ""))),
          s(:send, nil, :assert_equal,
            s(:str, "x"),
            s(:send,
              s(:str, ""), :+,
              s(:str, "x"))),
          s(:send, nil, :assert_equal,
            s(:str, "ab"),
            s(:send,
              s(:str, "a"), :+,
              s(:str, "b"))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "String"),
            s(:str, "+"),
            s(:str, "assert_equal \"b\", \"a\" + \"b\"")))),
      s(:def, :test_string_succ,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:str, "b"),
            s(:send,
              s(:str, "a"), :succ)),
          s(:send, nil, :assert_equal,
            s(:str, "B"),
            s(:send,
              s(:str, "A"), :succ)))),
      s(:def, :test_string_format,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:str, "2"),
            s(:send,
              s(:str, "%d"), :%,
              s(:int, 2))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "String"),
            s(:str, "%"),
            s(:str, "assert_equal 2, \"%d\" % 2")))),
      s(:def, :test_string_freeze,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:str, "foo"),
            s(:send,
              s(:str, "foo"), :freeze)),
          s(:send, nil, :assert_equal,
            s(:send,
              s(:send,
                s(:str, "foo"), :freeze), :object_id),
            s(:send,
              s(:send,
                s(:str, "foo"), :freeze), :object_id)),
          s(:send, nil, :assert_redefine_method,
            s(:str, "String"),
            s(:str, "freeze"),
            s(:str, "assert_nil \"foo\".freeze")))),
      s(:def, :test_string_freeze_saves_memory,
        s(:args),
        s(:ensure,
          s(:begin,
            s(:lvasgn, :n,
              s(:int, 16384)),
            s(:lvasgn, :data,
              s(:send,
                s(:str, "."), :freeze)),
            s(:masgn,
              s(:mlhs,
                s(:lvasgn, :r),
                s(:lvasgn, :w)),
              s(:send,
                s(:const, nil, :IO), :pipe)),
            s(:send,
              s(:lvar, :w), :write,
              s(:lvar, :data)),
            s(:lvasgn, :s,
              s(:send,
                s(:lvar, :r), :readpartial,
                s(:lvar, :n),
                s(:str, ""))),
            s(:send, nil, :assert_operator,
              s(:send,
                s(:const, nil, :ObjectSpace), :memsize_of,
                s(:lvar, :s)),
              s(:sym, :>=),
              s(:lvar, :n),
              s(:str, "IO buffer NOT resized prematurely because will likely be reused")),
            s(:send,
              s(:lvar, :s), :freeze),
            s(:send, nil, :assert_equal,
              s(:send,
                s(:const, nil, :ObjectSpace), :memsize_of,
                s(:lvar, :data)),
              s(:send,
                s(:const, nil, :ObjectSpace), :memsize_of,
                s(:lvar, :s)),
              s(:str, "buffer resized on freeze since it cannot be written to again"))),
          s(:begin,
            s(:if,
              s(:lvar, :r),
              s(:send,
                s(:lvar, :r), :close), nil),
            s(:if,
              s(:lvar, :w),
              s(:send,
                s(:lvar, :w), :close), nil)))),
      s(:def, :test_string_eq_neq,
        s(:args),
        s(:block,
          s(:send,
            s(:array,
              s(:str, "=="),
              s(:str, "!=")), :each),
          s(:args,
            s(:arg, :m)),
          s(:send, nil, :assert_redefine_method,
            s(:str, "String"),
            s(:lvar, :m),
            s(:dstr,
              s(:str, "        assert_equal :b, (\"a\" "),
              s(:begin,
                s(:lvar, :m)),
              s(:str, " \"b\").to_sym\n"),
              s(:str, "        b = 'b'\n"),
              s(:str, "        assert_equal :b, (\"a\" "),
              s(:begin,
                s(:lvar, :m)),
              s(:str, " b).to_sym\n"),
              s(:str, "        assert_equal :b, (b "),
              s(:begin,
                s(:lvar, :m)),
              s(:str, " \"b\").to_sym\n"))))),
      s(:def, :test_string_ltlt,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:str, ""),
            s(:send,
              s(:str, ""), :<<,
              s(:str, ""))),
          s(:send, nil, :assert_equal,
            s(:str, "x"),
            s(:send,
              s(:str, "x"), :<<,
              s(:str, ""))),
          s(:send, nil, :assert_equal,
            s(:str, "x"),
            s(:send,
              s(:str, ""), :<<,
              s(:str, "x"))),
          s(:send, nil, :assert_equal,
            s(:str, "ab"),
            s(:send,
              s(:str, "a"), :<<,
              s(:str, "b"))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "String"),
            s(:str, "<<"),
            s(:str, "assert_equal \"b\", \"a\" << \"b\"")))),
      s(:def, :test_array_plus,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:array,
              s(:int, 1),
              s(:int, 2)),
            s(:send,
              s(:array,
                s(:int, 1)), :+,
              s(:array,
                s(:int, 2)))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Array"),
            s(:str, "+"),
            s(:str, "assert_equal [2], [1]+[2]")))),
      s(:def, :test_array_minus,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:array,
              s(:int, 2)),
            s(:send,
              s(:array,
                s(:int, 1),
                s(:int, 2)), :-,
              s(:array,
                s(:int, 1)))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Array"),
            s(:str, "-"),
            s(:str, "assert_equal [1], [1,2]-[1]")))),
      s(:def, :test_array_length,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:array), :length)),
          s(:send, nil, :assert_equal,
            s(:int, 3),
            s(:send,
              s(:array,
                s(:int, 1),
                s(:int, 2),
                s(:int, 3)), :length)),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Array"),
            s(:str, "length"),
            s(:str, "assert_nil([].length); assert_nil([1,2,3].length)")))),
      s(:def, :test_array_empty?,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:array), :empty?)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:array,
                s(:int, 1),
                s(:int, 2),
                s(:int, 3)), :empty?)),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Array"),
            s(:str, "empty?"),
            s(:str, "assert_nil([].empty?); assert_nil([1,2,3].empty?)")))),
      s(:def, :test_hash_length,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:int, 0),
            s(:send,
              s(:hash), :length)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:hash,
                s(:pair,
                  s(:int, 1),
                  s(:int, 1))), :length)),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Hash"),
            s(:str, "length"),
            s(:str, "assert_nil({}.length); assert_nil({1=>1}.length)")))),
      s(:def, :test_hash_empty?,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:hash), :empty?)),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:hash,
                s(:pair,
                  s(:int, 1),
                  s(:int, 1))), :empty?)),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Hash"),
            s(:str, "empty?"),
            s(:str, "assert_nil({}.empty?); assert_nil({1=>1}.empty?)")))),
      s(:def, :test_hash_aref_with,
        s(:args),
        s(:begin,
          s(:lvasgn, :h,
            s(:hash,
              s(:pair,
                s(:str, "foo"),
                s(:int, 1)))),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :h), :[],
              s(:str, "foo"))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Hash"),
            s(:str, "[]"),
            s(:dstr,
              s(:str, "      h = { \"foo\" => 1 }\n"),
              s(:str, "      assert_equal \"foo\", h[\"foo\"]\n"))))),
      s(:def, :test_hash_aset_with,
        s(:args),
        s(:begin,
          s(:lvasgn, :h,
            s(:hash)),
          s(:send, nil, :assert_equal,
            s(:int, 1),
            s(:send,
              s(:lvar, :h), :[]=,
              s(:str, "foo"),
              s(:int, 1))),
          s(:send, nil, :assert_redefine_method,
            s(:str, "Hash"),
            s(:str, "[]="),
            s(:dstr,
              s(:str, "      h = {}\n"),
              s(:str, "      assert_equal 1, h[\"foo\"] = 1, \"assignment always returns value set\"\n"),
              s(:str, "      assert_nil h[\"foo\"]\n"))))),
      s(:class,
        s(:const, nil, :MyObj), nil,
        s(:def, :==,
          s(:args,
            s(:arg, :other)),
          s(:true))),
      s(:def, :test_eq,
        s(:args),
        s(:begin,
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:nil), :==,
              s(:nil))),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:int, 1), :==,
              s(:int, 1))),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:str, "string"), :==,
              s(:str, "string"))),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:int, 1), :==,
              s(:send,
                s(:const, nil, :MyObj), :new))),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send,
              s(:nil), :==,
              s(:send,
                s(:const, nil, :MyObj), :new))),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:send,
                s(:const, nil, :MyObj), :new), :==,
              s(:int, 1))),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:send,
              s(:send,
                s(:const, nil, :MyObj), :new), :==,
              s(:nil))))),
      s(:defs,
        s(:self), :tailcall,
        s(:args,
          s(:arg, :klass),
          s(:arg, :src),
          s(:optarg, :file,
            s(:nil)),
          s(:optarg, :path,
            s(:nil)),
          s(:optarg, :line,
            s(:nil)),
          s(:kwoptarg, :tailcall,
            s(:true))),
        s(:begin,
          s(:if,
            s(:lvar, :file), nil,
            s(:begin,
              s(:masgn,
                s(:mlhs,
                  s(:lvasgn, :loc)),
                s(:send, nil, :caller_locations,
                  s(:int, 1),
                  s(:int, 1))),
              s(:lvasgn, :file,
                s(:send,
                  s(:lvar, :loc), :path)),
              s(:or_asgn,
                s(:lvasgn, :line),
                s(:send,
                  s(:lvar, :loc), :lineno)))),
          s(:send,
            s(:send,
              s(:send,
                s(:const,
                  s(:const, nil, :RubyVM), :InstructionSequence), :new,
                s(:dstr,
                  s(:str, "proc {|_|_.class_eval {"),
                  s(:begin,
                    s(:lvar, :src)),
                  s(:str, "}}")),
                s(:lvar, :file),
                s(:begin,
                  s(:or,
                    s(:lvar, :path),
                    s(:lvar, :file))),
                s(:lvar, :line),
                s(:hash,
                  s(:pair,
                    s(:sym, :tailcall_optimization),
                    s(:lvar, :tailcall)),
                  s(:pair,
                    s(:sym, :trace_instruction),
                    s(:false)))), :eval), :[],
            s(:lvar, :klass)))),
      s(:def, :tailcall,
        s(:args,
          s(:restarg, :args)),
        s(:send,
          s(:send,
            s(:self), :class), :tailcall,
          s(:send, nil, :singleton_class),
          s(:splat,
            s(:lvar, :args)))),
      s(:def, :test_tailcall,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug4082,
            s(:str, "[ruby-core:33289]")),
          s(:send, nil, :tailcall,
            s(:dstr,
              s(:str, "      def fact_helper(n, res)\n"),
              s(:str, "        if n == 1\n"),
              s(:str, "          res\n"),
              s(:str, "        else\n"),
              s(:str, "          fact_helper(n - 1, n * res)\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "      def fact(n)\n"),
              s(:str, "        fact_helper(n, 1)\n"),
              s(:str, "      end\n"))),
          s(:send, nil, :assert_equal,
            s(:int, 9131),
            s(:send,
              s(:send,
                s(:send, nil, :fact,
                  s(:int, 3000)), :to_s), :size),
            s(:lvar, :bug4082)))),
      s(:def, :test_tailcall_with_block,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug6901,
            s(:str, "[ruby-dev:46065]")),
          s(:send, nil, :tailcall,
            s(:dstr,
              s(:str, "      def identity(val)\n"),
              s(:str, "        val\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      def delay\n"),
              s(:str, "        -> {\n"),
              s(:str, "          identity(yield)\n"),
              s(:str, "        }\n"),
              s(:str, "      end\n"))),
          s(:send, nil, :assert_equal,
            s(:int, 123),
            s(:send,
              s(:block,
                s(:send, nil, :delay),
                s(:args),
                s(:int, 123)), :call),
            s(:lvar, :bug6901)))),
      s(:def, :just_yield,
        s(:args),
        s(:yield)),
      s(:def, :test_tailcall_inhibited_by_block,
        s(:args),
        s(:begin,
          s(:send, nil, :tailcall,
            s(:dstr,
              s(:str, "      def yield_result\n"),
              s(:str, "        just_yield {:ok}\n"),
              s(:str, "      end\n"))),
          s(:send, nil, :assert_equal,
            s(:sym, :ok),
            s(:send, nil, :yield_result)))),
      s(:def, :do_raise,
        s(:args),
        s(:send, nil, :raise,
          s(:str, "should be rescued"))),
      s(:def, :errinfo,
        s(:args),
        s(:gvar, :$!)),
      s(:def, :test_tailcall_inhibited_by_rescue,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug12082,
            s(:str, "[ruby-core:73871] [Bug #12082]")),
          s(:send, nil, :tailcall,
            s(:dstr,
              s(:str, "      def to_be_rescued\n"),
              s(:str, "        return do_raise\n"),
              s(:str, "        1 + 2\n"),
              s(:str, "      rescue\n"),
              s(:str, "        errinfo\n"),
              s(:str, "      end\n"))),
          s(:lvasgn, :result,
            s(:send, nil, :to_be_rescued)),
          s(:send, nil, :assert_instance_of,
            s(:const, nil, :RuntimeError),
            s(:lvar, :result),
            s(:lvar, :bug12082)),
          s(:send, nil, :assert_equal,
            s(:str, "should be rescued"),
            s(:send,
              s(:lvar, :result), :message),
            s(:lvar, :bug12082)))),
      s(:def, :test_tailcall_symbol_block_arg,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug12565,
            s(:str, "[ruby-core:46065]")),
          s(:send, nil, :tailcall,
            s(:dstr,
              s(:str, "      def apply_one_and_two(&block)\n"),
              s(:str, "        yield(1, 2)\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      def add_one_and_two\n"),
              s(:str, "        apply_one_and_two(&:+)\n"),
              s(:str, "      end\n"))),
          s(:send, nil, :assert_equal,
            s(:int, 3),
            s(:send, nil, :add_one_and_two),
            s(:block,
              s(:send, nil, :message,
                s(:lvar, :bug12565)),
              s(:args),
              s(:send, nil, :disasm,
                s(:sym, :add_one_and_two)))))),
      s(:def, :test_tailcall_condition_block,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug,
            s(:str, "[ruby-core:78015] [Bug #12905]")),
          s(:lvasgn, :src,
            s(:dstr,
              s(:begin,
                s(:dstr)),
              s(:str, "\n"),
              s(:begin,
                s(:dstr,
                  s(:str, "      def run(current, final)\n"),
                  s(:str, "        if current < final\n"),
                  s(:str, "          run(current+1, final)\n"),
                  s(:str, "        else\n"),
                  s(:str, "          nil\n"),
                  s(:str, "        end\n"),
                  s(:str, "      end\n"))))),
          s(:lvasgn, :obj,
            s(:send,
              s(:const, nil, :Object), :new)),
          s(:send,
            s(:send,
              s(:self), :class), :tailcall,
            s(:send,
              s(:lvar, :obj), :singleton_class),
            s(:lvar, :src),
            s(:hash,
              s(:pair,
                s(:sym, :tailcall),
                s(:false)))),
          s(:lvasgn, :e,
            s(:block,
              s(:send, nil, :assert_raise,
                s(:const, nil, :SystemStackError)),
              s(:args),
              s(:send,
                s(:lvar, :obj), :run,
                s(:int, 1),
                s(:const,
                  s(:const, nil, :Float), :INFINITY)))),
          s(:lvasgn, :level,
            s(:send,
              s(:send,
                s(:lvar, :e), :backtrace_locations), :size)),
          s(:lvasgn, :obj,
            s(:send,
              s(:const, nil, :Object), :new)),
          s(:send,
            s(:send,
              s(:self), :class), :tailcall,
            s(:send,
              s(:lvar, :obj), :singleton_class),
            s(:lvar, :src),
            s(:hash,
              s(:pair,
                s(:sym, :tailcall),
                s(:true)))),
          s(:op_asgn,
            s(:lvasgn, :level), :*,
            s(:int, 2)),
          s(:lvasgn, :mesg,
            s(:block,
              s(:send, nil, :message),
              s(:args),
              s(:dstr,
                s(:begin,
                  s(:lvar, :bug)),
                s(:str, ": "),
                s(:begin,
                  s(:send,
                    s(:send,
                      s(:gvar, :$!), :backtrace_locations), :size)),
                s(:str, " / "),
                s(:begin,
                  s(:lvar, :level)),
                s(:str, " stack levels")))),
          s(:block,
            s(:send, nil, :assert_nothing_raised,
              s(:const, nil, :SystemStackError),
              s(:lvar, :mesg)),
            s(:args),
            s(:send,
              s(:lvar, :obj), :run,
              s(:int, 1),
              s(:lvar, :level))))),
      s(:class,
        s(:const, nil, :Bug10557), nil,
        s(:begin,
          s(:def, :[],
            s(:args,
              s(:arg, :_)),
            s(:send, nil, :block_given?)),
          s(:def, :[]=,
            s(:args,
              s(:arg, :_),
              s(:arg, :_)),
            s(:send, nil, :block_given?)))),
      s(:def, :test_block_given_aset_aref,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug10557,
            s(:str, "[ruby-core:66595]")),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:block,
              s(:send,
                s(:send,
                  s(:const, nil, :Bug10557), :new), :[],
                s(:nil)),
              s(:args), nil),
            s(:lvar, :bug10557)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:block,
              s(:send,
                s(:send,
                  s(:const, nil, :Bug10557), :new), :[],
                s(:int, 0)),
              s(:args), nil),
            s(:lvar, :bug10557)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:block,
              s(:send,
                s(:send,
                  s(:const, nil, :Bug10557), :new), :[],
                s(:false)),
              s(:args), nil),
            s(:lvar, :bug10557)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:block,
              s(:send,
                s(:send,
                  s(:const, nil, :Bug10557), :new), :[],
                s(:str, "")),
              s(:args), nil),
            s(:lvar, :bug10557)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:block,
              s(:send,
                s(:send,
                  s(:const, nil, :Bug10557), :new), :[]=,
                s(:nil),
                s(:int, 1)),
              s(:args), nil),
            s(:lvar, :bug10557)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:block,
              s(:send,
                s(:send,
                  s(:const, nil, :Bug10557), :new), :[]=,
                s(:int, 0),
                s(:int, 1)),
              s(:args), nil),
            s(:lvar, :bug10557)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:block,
              s(:send,
                s(:send,
                  s(:const, nil, :Bug10557), :new), :[]=,
                s(:false),
                s(:int, 1)),
              s(:args), nil),
            s(:lvar, :bug10557)),
          s(:send, nil, :assert_equal,
            s(:true),
            s(:block,
              s(:send,
                s(:send,
                  s(:const, nil, :Bug10557), :new), :[]=,
                s(:str, ""),
                s(:int, 1)),
              s(:args), nil),
            s(:lvar, :bug10557)))),
      s(:def, :test_string_freeze_block,
        s(:args),
        s(:send, nil, :assert_separately,
          s(:array),
          s(:dstr,
            s(:str, "      class String\n"),
            s(:str, "        undef freeze\n"),
            s(:str, "        def freeze\n"),
            s(:str, "          block_given?\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n"),
            s(:str, "      assert_equal(true, \"block\".freeze {})\n"),
            s(:str, "      assert_equal(false, \"block\".freeze)\n")))),
      s(:def, :test_opt_case_dispatch,
        s(:args),
        s(:begin,
          s(:lvasgn, :code,
            s(:dstr,
              s(:str, "      case foo\n"),
              s(:str, "      when \"foo\" then :foo\n"),
              s(:str, "      when true then true\n"),
              s(:str, "      when false then false\n"),
              s(:str, "      when :sym then :sym\n"),
              s(:str, "      when 6 then :fix\n"),
              s(:str, "      when nil then nil\n"),
              s(:str, "      when 0.1 then :float\n"),
              s(:str, "      when 0xffffffffffffffff then :big\n"),
              s(:str, "      else\n"),
              s(:str, "        :nomatch\n"),
              s(:str, "      end\n"))),
          s(:lvasgn, :check,
            s(:hash,
              s(:pair,
                s(:str, "foo"),
                s(:sym, :foo)),
              s(:pair,
                s(:true),
                s(:true)),
              s(:pair,
                s(:false),
                s(:false)),
              s(:pair,
                s(:sym, :sym),
                s(:sym, :sym)),
              s(:pair,
                s(:int, 6),
                s(:sym, :fix)),
              s(:pair,
                s(:nil),
                s(:nil)),
              s(:pair,
                s(:float, 0.1),
                s(:sym, :float)),
              s(:pair,
                s(:int, 18446744073709551615),
                s(:sym, :big)))),
          s(:lvasgn, :iseq,
            s(:send,
              s(:const,
                s(:const, nil, :RubyVM), :InstructionSequence), :compile,
              s(:lvar, :code))),
          s(:send, nil, :assert_match,
            s(:regexp,
              s(:str, "\\bopt_case_dispatch\\b"),
              s(:regopt)),
            s(:send,
              s(:lvar, :iseq), :disasm)),
          s(:block,
            s(:send,
              s(:lvar, :check), :each),
            s(:args,
              s(:arg, :foo),
              s(:arg, :expect)),
            s(:send, nil, :assert_equal,
              s(:lvar, :expect),
              s(:send, nil, :eval,
                s(:dstr,
                  s(:str, "foo = "),
                  s(:begin,
                    s(:send,
                      s(:lvar, :foo), :inspect)),
                  s(:str, "\n"),
                  s(:begin,
                    s(:lvar, :code)))))),
          s(:send, nil, :assert_equal,
            s(:sym, :nomatch),
            s(:send, nil, :eval,
              s(:dstr,
                s(:str, "foo = :blah\n"),
                s(:begin,
                  s(:lvar, :code))))),
          s(:block,
            s(:send,
              s(:lvar, :check), :each),
            s(:args,
              s(:arg, :foo),
              s(:arg, :_)),
            s(:begin,
              s(:lvasgn, :klass,
                s(:send,
                  s(:send,
                    s(:lvar, :foo), :class), :to_s)),
              s(:send, nil, :assert_separately,
                s(:array),
                s(:dstr,
                  s(:str, "        class "),
                  s(:begin,
                    s(:lvar, :klass)),
                  s(:str, "\n"),
                  s(:str, "          undef ===\n"),
                  s(:str, "          def ===(*args)\n"),
                  s(:str, "            false\n"),
                  s(:str, "          end\n"),
                  s(:str, "        end\n"),
                  s(:str, "        foo = "),
                  s(:begin,
                    s(:send,
                      s(:lvar, :foo), :inspect)),
                  s(:str, "\n"),
                  s(:str, "        ret = "),
                  s(:begin,
                    s(:lvar, :code)),
                  s(:str, "\n"),
                  s(:str, "        assert_equal :nomatch, ret, foo.inspect\n"))))))),
      s(:def, :test_eqq,
        s(:args),
        s(:block,
          s(:send,
            s(:array,
              s(:nil),
              s(:true),
              s(:false),
              s(:float, 0.1),
              s(:sym, :sym),
              s(:str, "str"),
              s(:int, 18446744073709551615)), :each),
          s(:args,
            s(:arg, :v)),
          s(:begin,
            s(:lvasgn, :k,
              s(:send,
                s(:send,
                  s(:lvar, :v), :class), :to_s)),
            s(:send, nil, :assert_redefine_method,
              s(:lvar, :k),
              s(:str, "==="),
              s(:dstr,
                s(:str, "assert_equal("),
                s(:begin,
                  s(:send,
                    s(:lvar, :v), :inspect)),
                s(:str, " === 0, 0)")))))),
      s(:def, :test_opt_case_dispatch_inf,
        s(:args),
        s(:begin,
          s(:lvasgn, :inf,
            s(:send,
              s(:float, 1.0), :/,
              s(:float, 0.0))),
          s(:lvasgn, :result,
            s(:case,
              s(:lvar, :inf),
              s(:when,
                s(:int, 1),
                s(:int, 1)),
              s(:when,
                s(:int, 0),
                s(:int, 0)),
              s(:rescue,
                s(:send,
                  s(:lvar, :inf), :to_i),
                s(:resbody, nil, nil,
                  s(:nil)), nil))),
          s(:send, nil, :assert_nil,
            s(:lvar, :result),
            s(:str, "[ruby-dev:49423] [Bug #11804]")))),
      s(:def, :test_nil_safe_conditional_assign,
        s(:args),
        s(:begin,
          s(:lvasgn, :bug11816,
            s(:str, "[ruby-core:74993] [Bug #11816]")),
          s(:send, nil, :assert_ruby_status,
            s(:array),
            s(:str, "nil&.foo &&= false"),
            s(:lvar, :bug11816)))))))
