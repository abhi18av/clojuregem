s(:begin,
  s(:send, nil, :require,
    s(:str, "test/unit")),
  s(:class,
    s(:const, nil, :TestIseqLoad),
    s(:const,
      s(:const,
        s(:const, nil, :Test), :Unit), :TestCase),
    s(:begin,
      s(:send, nil, :require,
        s(:str, "-test-/iseq_load/iseq_load")),
      s(:casgn, nil, :ISeq,
        s(:const,
          s(:const, nil, :RubyVM), :InstructionSequence)),
      s(:def, :test_bug8543,
        s(:args),
        s(:send, nil, :assert_iseq_roundtrip,
          s(:dstr,
            s(:str, "      puts \"tralivali\"\n"),
            s(:str, "      def funct(a, b)\n"),
            s(:str, "        a**b\n"),
            s(:str, "      end\n"),
            s(:str, "      3.times { |i| puts \"Hello, world\#{funct(2,i)}!\" }\n")))),
      s(:def, :test_case_when,
        s(:args),
        s(:send, nil, :assert_iseq_roundtrip,
          s(:dstr,
            s(:str, "      def user_mask(target)\n"),
            s(:str, "        target.each_char.inject(0) do |mask, chr|\n"),
            s(:str, "          case chr\n"),
            s(:str, "          when \"u\"\n"),
            s(:str, "            mask | 04700\n"),
            s(:str, "          when \"g\"\n"),
            s(:str, "            mask | 02070\n"),
            s(:str, "          when \"o\"\n"),
            s(:str, "            mask | 01007\n"),
            s(:str, "          when \"a\"\n"),
            s(:str, "            mask | 07777\n"),
            s(:str, "          else\n"),
            s(:str, "            raise ArgumentError, \"invalid `who' symbol in file mode: \#{chr}\"\n"),
            s(:str, "          end\n"),
            s(:str, "        end\n"),
            s(:str, "      end\n")))),
      s(:def, :test_splatsplat,
        s(:args),
        s(:send, nil, :assert_iseq_roundtrip,
          s(:str, "def splatsplat(**); end"))),
      s(:def, :test_hidden,
        s(:args),
        s(:send, nil, :assert_iseq_roundtrip,
          s(:str, "def x(a, (b, *c), d: false); end"))),
      s(:def, :assert_iseq_roundtrip,
        s(:args,
          s(:arg, :src)),
        s(:begin,
          s(:lvasgn, :a,
            s(:send,
              s(:send,
                s(:const, nil, :ISeq), :compile,
                s(:lvar, :src)), :to_a)),
          s(:lvasgn, :b,
            s(:send,
              s(:send,
                s(:const, nil, :ISeq), :iseq_load,
                s(:lvar, :a)), :to_a)),
          s(:if,
            s(:send,
              s(:lvar, :a), :!=,
              s(:lvar, :b)),
            s(:send, nil, :warn,
              s(:send, nil, :diff,
                s(:lvar, :a),
                s(:lvar, :b))), nil),
          s(:send, nil, :assert_equal,
            s(:lvar, :a),
            s(:lvar, :b)),
          s(:send, nil, :assert_equal,
            s(:lvar, :a),
            s(:send,
              s(:send,
                s(:const, nil, :ISeq), :iseq_load,
                s(:lvar, :b)), :to_a)))),
      s(:def, :test_next_in_block_in_block,
        s(:args),
        s(:begin,
          s(:ivasgn, :@next_broke,
            s(:false)),
          s(:lvasgn, :src,
            s(:str, "      3.times { 3.times { next; @next_broke = true } }\n")),
          s(:lvasgn, :a,
            s(:send,
              s(:send,
                s(:const, nil, :ISeq), :compile,
                s(:lvar, :src)), :to_a)),
          s(:lvasgn, :iseq,
            s(:send,
              s(:const, nil, :ISeq), :iseq_load,
              s(:lvar, :a))),
          s(:send,
            s(:lvar, :iseq), :eval),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:ivar, :@next_broke)),
          s(:send, nil, :skip,
            s(:str, "failing due to stack_max mismatch")),
          s(:send, nil, :assert_iseq_roundtrip,
            s(:lvar, :src)))),
      s(:def, :test_break_ensure,
        s(:args),
        s(:begin,
          s(:lvasgn, :src,
            s(:dstr,
              s(:str, "      def test_break_ensure_def_method\n"),
              s(:str, "        bad = true\n"),
              s(:str, "        while true\n"),
              s(:str, "          begin\n"),
              s(:str, "            break\n"),
              s(:str, "          ensure\n"),
              s(:str, "            bad = false\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "        bad\n"),
              s(:str, "      end\n"))),
          s(:lvasgn, :a,
            s(:send,
              s(:send,
                s(:const, nil, :ISeq), :compile,
                s(:lvar, :src)), :to_a)),
          s(:lvasgn, :iseq,
            s(:send,
              s(:const, nil, :ISeq), :iseq_load,
              s(:lvar, :a))),
          s(:send,
            s(:lvar, :iseq), :eval),
          s(:send, nil, :assert_equal,
            s(:false),
            s(:send, nil, :test_break_ensure_def_method)),
          s(:send, nil, :skip,
            s(:str, "failing due to exception entry sp mismatch")),
          s(:send, nil, :assert_iseq_roundtrip,
            s(:lvar, :src)))),
      s(:def, :test_kwarg,
        s(:args),
        s(:send, nil, :assert_iseq_roundtrip,
          s(:dstr,
            s(:str, "      def foo(kwarg: :foo)\n"),
            s(:str, "        kwarg\n"),
            s(:str, "      end\n"),
            s(:str, "      foo(kwarg: :bar)\n")))),
      s(:def, :test_require_integration,
        s(:args),
        s(:begin,
          s(:send, nil, :skip,
            s(:str, "iseq loader require integration tests still failing")),
          s(:lvasgn, :f,
            s(:send,
              s(:const, nil, :File), :expand_path,
              s(:str, "(string)"))),
          s(:block,
            s(:send,
              s(:int, 3), :times),
            s(:args),
            s(:lvasgn, :f,
              s(:send,
                s(:const, nil, :File), :dirname,
                s(:lvar, :f)))),
          s(:block,
            s(:send,
              s(:send,
                s(:const, nil, :Dir), :[],
                s(:send,
                  s(:const, nil, :File), :join,
                  s(:lvar, :f),
                  s(:str, "ruby"),
                  s(:str, "*.rb"))), :each),
            s(:args,
              s(:arg, :f)),
            s(:begin,
              s(:lvasgn, :iseq,
                s(:send,
                  s(:const, nil, :ISeq), :compile_file,
                  s(:lvar, :f))),
              s(:lvasgn, :orig,
                s(:send,
                  s(:send,
                    s(:lvar, :iseq), :to_a), :freeze)),
              s(:lvasgn, :loaded,
                s(:send,
                  s(:send,
                    s(:const, nil, :ISeq), :iseq_load,
                    s(:lvar, :orig)), :to_a)),
              s(:if,
                s(:send,
                  s(:lvar, :loaded), :!=,
                  s(:lvar, :orig)),
                s(:begin,
                  s(:send, nil, :warn,
                    s(:lvar, :f)),
                  s(:send, nil, :warn,
                    s(:send, nil, :diff,
                      s(:lvar, :orig),
                      s(:lvar, :loaded)))), nil))))))))
