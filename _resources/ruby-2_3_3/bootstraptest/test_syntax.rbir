s(:begin,
  s(:send, nil, :assert_equal,
    s(:str, "4"),
    s(:str, "1 && 2 && 3 && 4")),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:str, "1 && nil && 3 && 4")),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:str, "1 && 2 && 3 && nil")),
  s(:send, nil, :assert_equal,
    s(:str, "false"),
    s(:str, "1 && 2 && 3 && false")),
  s(:send, nil, :assert_equal,
    s(:str, "4"),
    s(:str, "1 and 2 and 3 and 4")),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:str, "1 and nil and 3 and 4")),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:str, "1 and 2 and 3 and nil")),
  s(:send, nil, :assert_equal,
    s(:str, "false"),
    s(:str, "1 and 2 and 3 and false")),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:str, "nil && true")),
  s(:send, nil, :assert_equal,
    s(:str, "false"),
    s(:str, "false && true")),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case 1\n"),
      s(:str, "  when 2\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case 1\n"),
      s(:str, "  when 10,20,30\n"),
      s(:str, "    :ng1\n"),
      s(:str, "  when 1,2,3\n"),
      s(:str, "    :ok\n"),
      s(:str, "  when 100,200,300\n"),
      s(:str, "    :ng2\n"),
      s(:str, "  else\n"),
      s(:str, "    :elseng\n"),
      s(:str, "  end"))),
  s(:send, nil, :assert_equal,
    s(:str, "elseok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case 123\n"),
      s(:str, "  when 10,20,30\n"),
      s(:str, "    :ng1\n"),
      s(:str, "  when 1,2,3\n"),
      s(:str, "    :ng2\n"),
      s(:str, "  when 100,200,300\n"),
      s(:str, "    :ng3\n"),
      s(:str, "  else\n"),
      s(:str, "    :elseok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case 'test'\n"),
      s(:str, "  when /testx/\n"),
      s(:str, "    :ng1\n"),
      s(:str, "  when /test/\n"),
      s(:str, "    :ok\n"),
      s(:str, "  when /tetxx/\n"),
      s(:str, "    :ng2\n"),
      s(:str, "  else\n"),
      s(:str, "    :ng_else\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case Object.new\n"),
      s(:str, "  when Object\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case Object\n"),
      s(:str, "  when Object.new\n"),
      s(:str, "    :ng\n"),
      s(:str, "  else\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case 'test'\n"),
      s(:str, "  when 'tes'\n"),
      s(:str, "    :ng\n"),
      s(:str, "  when 'te'\n"),
      s(:str, "    :ng\n"),
      s(:str, "  else\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case 'test'\n"),
      s(:str, "  when 'tes'\n"),
      s(:str, "    :ng\n"),
      s(:str, "  when 'te'\n"),
      s(:str, "    :ng\n"),
      s(:str, "  when 'test'\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ng"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case 'test'\n"),
      s(:str, "  when 'tes'\n"),
      s(:str, "    :ng\n"),
      s(:str, "  when /te/\n"),
      s(:str, "    :ng\n"),
      s(:str, "  else\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case 'test'\n"),
      s(:str, "  when 'tes'\n"),
      s(:str, "    :ng\n"),
      s(:str, "  when /test/\n"),
      s(:str, "    :ok\n"),
      s(:str, "  else\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "100"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def test(arg)\n"),
      s(:str, "    case 1\n"),
      s(:str, "    when 2\n"),
      s(:str, "      3\n"),
      s(:str, "    end\n"),
      s(:str, "    return arg\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  test(100)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ary = [1, 2]\n"),
      s(:str, "  case 1\n"),
      s(:str, "  when *ary\n"),
      s(:str, "    :ok\n"),
      s(:str, "  else\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ary = [1, 2]\n"),
      s(:str, "  case 3\n"),
      s(:str, "  when *ary\n"),
      s(:str, "    :ng\n"),
      s(:str, "  else\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ary = [1, 2]\n"),
      s(:str, "  case 1\n"),
      s(:str, "  when :x, *ary\n"),
      s(:str, "    :ok\n"),
      s(:str, "  when :z\n"),
      s(:str, "    :ng1\n"),
      s(:str, "  else\n"),
      s(:str, "    :ng2\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ary = [1, 2]\n"),
      s(:str, "  case 3\n"),
      s(:str, "  when :x, *ary\n"),
      s(:str, "    :ng1\n"),
      s(:str, "  when :z\n"),
      s(:str, "    :ng2\n"),
      s(:str, "  else\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[:false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :false, :false, :false, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :then, :false, :then, :then, :then, :false, :false, :false, :false, :false, :false, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :false, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :false, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :false, :then, :then, :then, :then, :then, :then, :then, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep, :then, :sep]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "\n"),
      s(:str, "  def make_perm ary, num\n"),
      s(:str, "    if num == 1\n"),
      s(:str, "      ary.map{|e| [e]}\n"),
      s(:str, "    else\n"),
      s(:str, "      base = make_perm(ary, num-1)\n"),
      s(:str, "      res  = []\n"),
      s(:str, "      base.each{|b|\n"),
      s(:str, "        ary.each{|e|\n"),
      s(:str, "          res << [e] + b\n"),
      s(:str, "        }\n"),
      s(:str, "      }\n"),
      s(:str, "      res\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def each_test\n"),
      s(:str, "    conds = make_perm(['fv', 'tv'], 3)\n"),
      s(:str, "    bangs = make_perm(['', '!'], 3)\n"),
      s(:str, "    exprs = make_perm(['and', 'or'], 3)\n"),
      s(:str, "    ['if', 'unless'].each{|syn|\n"),
      s(:str, "      conds.each{|cs|\n"),
      s(:str, "        bangs.each{|bs|\n"),
      s(:str, "          exprs.each{|es|\n"),
      s(:str, "            yield(syn, cs, bs, es)\n"),
      s(:str, "          }\n"),
      s(:str, "        }\n"),
      s(:str, "      }\n"),
      s(:str, "    }\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  fv = false\n"),
      s(:str, "  tv = true\n"),
      s(:str, "\n"),
      s(:str, "  $ans = []\n"),
      s(:str, "  each_test{|syn, conds, bangs, exprs|\n"),
      s(:str, "    c1, c2, c3 = conds\n"),
      s(:str, "    bang1, bang2, bang3 = bangs\n"),
      s(:str, "    e1, e2 = exprs\n"),
      s(:str, "    eval %Q{\n"),
      s(:str, "      \#{syn} \#{bang1}\#{c1} \#{e1} \#{bang2}\#{c2} \#{e2} \#{bang3}\#{c3}\n"),
      s(:str, "        $ans << :then\n"),
      s(:str, "      else\n"),
      s(:str, "        $ans << :false\n"),
      s(:str, "      end\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"),
      s(:str, "\n"),
      s(:str, "  each_test{|syn, conds, bangs, exprs|\n"),
      s(:str, "    c1, c2, c3 = conds\n"),
      s(:str, "    bang1, bang2, bang3 = bangs\n"),
      s(:str, "    e1, e2 = exprs\n"),
      s(:str, "    eval %Q{\n"),
      s(:str, "      \#{syn} \#{bang1}\#{c1} \#{e1} \#{bang2}\#{c2} \#{e2} \#{bang3}\#{c3}\n"),
      s(:str, "        $ans << :then\n"),
      s(:str, "      end\n"),
      s(:str, "      $ans << :sep\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"),
      s(:str, "  $ans\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  defined?(m)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "method"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "  end\n"),
      s(:str, "  defined?(m)\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  defined?(a.class)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "method"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  a = 1\n"),
      s(:str, "  defined?(a.class)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[\"method\", \"method\", \"method\", \"method\", nil, nil, \"method\", \"method\", \"method\", nil]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C\n"),
      s(:str, "    def test\n"),
      s(:str, "      [defined?(m1()), defined?(self.m1), defined?(C.new.m1),\n"),
      s(:str, "       defined?(m2()), defined?(self.m2), defined?(C.new.m2),\n"),
      s(:str, "       defined?(m3()), defined?(self.m3), defined?(C.new.m3)]\n"),
      s(:str, "    end\n"),
      s(:str, "    def m1\n"),
      s(:str, "    end\n"),
      s(:str, "    private\n"),
      s(:str, "    def m2\n"),
      s(:str, "    end\n"),
      s(:str, "    protected\n"),
      s(:str, "    def m3\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  C.new.test + [defined?(C.new.m3)]\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[nil, nil, nil, nil, \"global-variable\", \"global-variable\", nil, nil]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  $ans = [defined?($1), defined?($2), defined?($3), defined?($4)]\n"),
      s(:str, "  /(a)(b)/ =~ 'ab'\n"),
      s(:str, "  $ans + [defined?($1), defined?($2), defined?($3), defined?($4)]\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "nilselftruefalse"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  defined?(nil) + defined?(self) +\n"),
      s(:str, "    defined?(true) + defined?(false)\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  defined?(@a)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "instance-variable"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  @a = 1\n"),
      s(:str, "  defined?(@a)\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  defined?(@@a)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "class variable"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  @@a = 1\n"),
      s(:str, "  defined?(@@a)\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  defined?($a)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "global-variable"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  $a = 1\n"),
      s(:str, "  defined?($a)\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  defined?(C_definedtest)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "constant"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  C_definedtest = 1\n"),
      s(:str, "  defined?(C_definedtest)\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  defined?(::C_definedtest)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "constant"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  C_definedtest = 1\n"),
      s(:str, "  defined?(::C_definedtest)\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  defined?(C_definedtestA::C_definedtestB::C_definedtestC)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "constant"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C_definedtestA\n"),
      s(:str, "    class C_definedtestB\n"),
      s(:str, "      C_definedtestC = 1\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  defined?(C_definedtestA::C_definedtestB::C_definedtestC)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "30"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  sum = 0\n"),
      s(:str, "  30.times{|ib|\n"),
      s(:str, "    if ib % 10 == 0 .. true\n"),
      s(:str, "      sum += ib\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"),
      s(:str, "  sum\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "63"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  sum = 0\n"),
      s(:str, "  30.times{|ib|\n"),
      s(:str, "    if ib % 10 == 0 ... true\n"),
      s(:str, "      sum += ib\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"),
      s(:str, "  sum\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[[\"NUM\", \"Type: NUM\\n\"], [\"NUM\", \"123\\n\"], [\"NUM\", \"456\\n\"], [\"NUM\", \"Type: ARP\\n\"], [\"NUM\", \"aaa\\n\"], [\"NUM\", \"bbb\\n\"], [\"NUM\", \"\\f\\n\"], [\"ARP\", \"Type: ARP\\n\"], [\"ARP\", \"aaa\\n\"], [\"ARP\", \"bbb\\n\"]]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  t = nil\n"),
      s(:str, "  unless ''.respond_to? :lines\n"),
      s(:str, "    class String\n"),
      s(:str, "      def lines\n"),
      s(:str, "        self\n"),
      s(:str, "      end\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  ary = []\n"),
      s(:str, "\"this must not print\n"),
      s(:str, "Type: NUM\n"),
      s(:str, "123\n"),
      s(:str, "456\n"),
      s(:str, "Type: ARP\n"),
      s(:str, "aaa\n"),
      s(:str, "bbb\n"),
      s(:str, "\\f\n"),
      s(:str, "this must not print\n"),
      s(:str, "hoge\n"),
      s(:str, "Type: ARP\n"),
      s(:str, "aaa\n"),
      s(:str, "bbb\n"),
      s(:str, "\".lines.each{|l|\n"),
      s(:str, "    if (t = l[/^Type: (.*)/, 1])..(/^\\f/ =~ l)\n"),
      s(:str, "      ary << [t, l]\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"),
      s(:str, "  ary\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "if true  then 1 ; end")),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:str, "if false then 1 ; end")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "if true  then 1 ; else; 2; end")),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:str, "if false then 1 ; else; 2; end")),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:str, "if true  then   ; elsif true then ; 1 ; end")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "if false then   ; elsif true then ; 1 ; end")),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:str, "unless true  then 1 ; end")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "unless false then 1 ; end")),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:str, "unless true  then 1 ; else; 2; end")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "unless false then 1 ; else; 2; end")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "1 if true")),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:str, "1 if false")),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:str, "1 if nil")),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:str, "1 unless true")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "1 unless false")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "1 unless nil")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "1 || 2 || 3 || 4")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "1 || false || 3 || 4")),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:str, "nil || 2 || 3 || 4")),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:str, "false || 2 || 3 || 4")),
  s(:send, nil, :assert_equal,
    s(:str, "false"),
    s(:str, "nil || false || nil || false")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "1 or 2 or 3 or 4")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "1 or false or 3 or 4")),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:str, "nil or 2 or 3 or 4")),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:str, "false or 2 or 3 or 4")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "if true && \"\"; then 1; end")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:str, "if nil || true; then 1; end")),
  s(:send, nil, :assert_equal,
    s(:str, "false"),
    s(:str, "nil or false or nil or false")),
  s(:send, nil, :assert_equal,
    s(:str, "elseng"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case\n"),
      s(:str, "  when 1==2, 2==3\n"),
      s(:str, "    :ng1\n"),
      s(:str, "  when false, 4==5\n"),
      s(:str, "    :ok\n"),
      s(:str, "  when false\n"),
      s(:str, "    :ng2\n"),
      s(:str, "  else\n"),
      s(:str, "    :elseng\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case\n"),
      s(:str, "  when nil, nil\n"),
      s(:str, "    :ng1\n"),
      s(:str, "  when 1,2,3\n"),
      s(:str, "    :ok\n"),
      s(:str, "  when false, false\n"),
      s(:str, "    :ng2\n"),
      s(:str, "  else\n"),
      s(:str, "    :elseng\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "elseok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case\n"),
      s(:str, "  when nil\n"),
      s(:str, "    :ng1\n"),
      s(:str, "  when false\n"),
      s(:str, "    :ng2\n"),
      s(:str, "  else\n"),
      s(:str, "    :elseok\n"),
      s(:str, "  end"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  case\n"),
      s(:str, "  when 1\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  r = nil\n"),
      s(:str, "  ary = []\n"),
      s(:str, "  case\n"),
      s(:str, "  when false\n"),
      s(:str, "    r = :ng1\n"),
      s(:str, "  when false, false\n"),
      s(:str, "    r = :ng2\n"),
      s(:str, "  when *ary\n"),
      s(:str, "    r = :ng3\n"),
      s(:str, "  when false, *ary\n"),
      s(:str, "    r = :ng4\n"),
      s(:str, "  when true, *ary\n"),
      s(:str, "    r = :ok\n"),
      s(:str, "  end\n"),
      s(:str, "  r\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ary = []\n"),
      s(:str, "  case\n"),
      s(:str, "  when false, *ary\n"),
      s(:str, "    :ng\n"),
      s(:str, "  else\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ary = [false, nil]\n"),
      s(:str, "  case\n"),
      s(:str, "  when *ary\n"),
      s(:str, "    :ng\n"),
      s(:str, "  else\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ary = [false, nil]\n"),
      s(:str, "  case\n"),
      s(:str, "  when *ary\n"),
      s(:str, "    :ng\n"),
      s(:str, "  when true\n"),
      s(:str, "    :ok\n"),
      s(:str, "  else\n"),
      s(:str, "    :ng2\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ng"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ary = [false, nil]\n"),
      s(:str, "  case\n"),
      s(:str, "  when *ary\n"),
      s(:str, "    :ok\n"),
      s(:str, "  else\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ary = [false, true]\n"),
      s(:str, "  case\n"),
      s(:str, "  when *ary\n"),
      s(:str, "    :ok\n"),
      s(:str, "  else\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ary = [false, true]\n"),
      s(:str, "  case\n"),
      s(:str, "  when false, false\n"),
      s(:str, "  when false, *ary\n"),
      s(:str, "    :ok\n"),
      s(:str, "  else\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  while i < 10\n"),
      s(:str, "    i+=1\n"),
      s(:str, "  end"))),
  s(:send, nil, :assert_equal,
    s(:str, "10"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  while i < 10\n"),
      s(:str, "    i+=1\n"),
      s(:str, "  end; i"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  until i > 10\n"),
      s(:str, "    i+=1\n"),
      s(:str, "  end"))),
  s(:send, nil, :assert_equal,
    s(:str, "11"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  until i > 10\n"),
      s(:str, "    i+=1\n"),
      s(:str, "  end; i"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  begin\n"),
      s(:str, "    i+=1\n"),
      s(:str, "  end while false\n"),
      s(:str, "  i\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  begin\n"),
      s(:str, "    i+=1\n"),
      s(:str, "  end until true\n"),
      s(:str, "  i\n"))),
  s(:def, :assert_syntax_error,
    s(:args,
      s(:arg, :expected),
      s(:arg, :code),
      s(:optarg, :message,
        s(:str, ""))),
    s(:send, nil, :assert_equal,
      s(:dstr,
        s(:begin,
          s(:lvar, :expected))),
      s(:dstr,
        s(:dstr,
          s(:str, "begin eval(%q{"),
          s(:begin,
            s(:lvar, :code)),
          s(:str, "}, nil, '', 0)")),
        s(:str, "; rescue SyntaxError => e; e.message[/\\A:(?:\\d+:)? (.*)/, 1] end")),
      s(:lvar, :message))),
  s(:send, nil, :assert_syntax_error,
    s(:str, "unterminated string meets end of file"),
    s(:str, "()..\""),
    s(:str, "[ruby-dev:29732]")),
  s(:send, nil, :assert_equal,
    s(:str, "[]"),
    s(:str, "$&;[]"),
    s(:str, "[ruby-dev:31068]")),
  s(:send, nil, :assert_syntax_error,
    s(:str, "syntax error, unexpected *, expecting '}'"),
    s(:str, "{*0}"),
    s(:str, "[ruby-dev:31072]")),
  s(:send, nil, :assert_syntax_error,
    s(:str, "`@0' is not allowed as an instance variable name"),
    s(:str, "@0..0"),
    s(:str, "[ruby-dev:31095]")),
  s(:send, nil, :assert_syntax_error,
    s(:str, "identifier $00 is not valid to get"),
    s(:str, "$00..0"),
    s(:str, "[ruby-dev:31100]")),
  s(:send, nil, :assert_syntax_error,
    s(:str, "identifier $00 is not valid to set"),
    s(:str, "0..$00=1")),
  s(:send, nil, :assert_equal,
    s(:str, "0"),
    s(:str, "[*0];0"),
    s(:str, "[ruby-dev:31102]")),
  s(:send, nil, :assert_syntax_error,
    s(:str, "syntax error, unexpected ')'"),
    s(:str, "v0,(*,v1,) = 0"),
    s(:str, "[ruby-dev:31104]")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class << (ary=[]); def []; 0; end; def []=(x); super(0,x);end;end; ary[]+=1\n")),
    s(:str, "[ruby-dev:31110]")),
  s(:send, nil, :assert_syntax_error,
    s(:str, "Can't set variable $1"),
    s(:str, "0..$1=1"),
    s(:str, "[ruby-dev:31118]")),
  s(:send, nil, :assert_valid_syntax,
    s(:str, "1.times{1+(1&&next)}"),
    s(:str, "[ruby-dev:31119]")),
  s(:send, nil, :assert_valid_syntax,
    s(:str, "x=-1;loop{x+=1&&redo if (x+=1).zero?}"),
    s(:str, "[ruby-dev:31119]")),
  s(:send, nil, :assert_syntax_error,
    s(:str, "syntax error, unexpected end-of-input"),
    s(:str, "!"),
    s(:str, "[ruby-dev:31243]")),
  s(:send, nil, :assert_equal,
    s(:str, "[nil]"),
    s(:str, "[()]"),
    s(:str, "[ruby-dev:31252]")),
  s(:send, nil, :assert_equal,
    s(:str, "true"),
    s(:str, "!_=()"),
    s(:str, "[ruby-dev:31263]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:str, "while true; redo; end if 1 == 2; :ok"),
    s(:str, "[ruby-dev:31360]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  1.times {\n"),
      s(:str, "    begin\n"),
      s(:str, "    ensure\n"),
      s(:str, "      next\n"),
      s(:str, "    end\n"),
      s(:str, "  }; :ok\n")),
    s(:str, "[ruby-dev:31373]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  flag = false\n"),
      s(:str, "  1.times {\n"),
      s(:str, "    next if flag\n"),
      s(:str, "    flag = true\n"),
      s(:str, "    begin\n"),
      s(:str, "    ensure\n"),
      s(:str, "      redo\n"),
      s(:str, "    end\n"),
      s(:str, "  }; :ok\n")),
    s(:str, "[ruby-dev:31373]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  1.times{\n"),
      s(:str, "    p(1, (next; 2))\n"),
      s(:str, "  }; :ok\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "3"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  1 + (while true\n"),
      s(:str, "         break 2 if (i+=1) > 1\n"),
      s(:str, "         next\n"),
      s(:str, "       end)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "3"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  1 + (while true\n"),
      s(:str, "         break 2 if (i+=1) > 1\n"),
      s(:str, "         p(1, (next; 2))\n"),
      s(:str, "       end)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  1.times{\n"),
      s(:str, "    break if i>1\n"),
      s(:str, "    i+=1\n"),
      s(:str, "    p(1, (redo; 2))\n"),
      s(:str, "  }; :ok\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "3"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  1 + (while true\n"),
      s(:str, "         break 2 if (i+=1) > 1\n"),
      s(:str, "         redo\n"),
      s(:str, "       end)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "3"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  1 + (while true\n"),
      s(:str, "         break 2 if (i+=1) > 1\n"),
      s(:str, "         p(1, (redo; 2))\n"),
      s(:str, "       end)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  a = [0]\n"),
      s(:str, "  a[*a]+=1\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ary = [0]\n"),
      s(:str, "  case 1\n"),
      s(:str, "  when *ary, 1\n"),
      s(:str, "    1\n"),
      s(:str, "  end +\n"),
      s(:str, "  case\n"),
      s(:str, "  when *ary\n"),
      s(:str, "    1\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_match,
    s(:regexp,
      s(:str, "invalid multibyte char"),
      s(:regopt)),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  STDERR.reopen(STDOUT)\n"),
      s(:str, "  eval(\"\\\"\\xf0\".force_encoding(\"utf-8\"))\n")),
    s(:str, "[ruby-dev:32429]")),
  s(:send, nil, :assert_equal,
    s(:str, "true"),
    s(:str, "!false")),
  s(:send, nil, :assert_equal,
    s(:str, "true"),
    s(:str, "1 == 1")),
  s(:send, nil, :assert_equal,
    s(:str, "true"),
    s(:str, "1 != 2")),
  s(:send, nil, :assert_equal,
    s(:str, "true"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C; def !=(obj); true; end; end\n"),
      s(:str, "  C.new != 1\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "true"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C; def !@; true; end; end\n"),
      s(:str, "  !C.new\n"))),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  eval \"while true; return; end rescue p $!\"\n")),
    s(:str, "[ruby-dev:31663]")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def bar\n"),
      s(:str, "    raise\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def foo\n"),
      s(:str, "    1.times{\n"),
      s(:str, "      begin\n"),
      s(:str, "        return bar\n"),
      s(:str, "      rescue\n"),
      s(:str, "        :ok\n"),
      s(:str, "      end\n"),
      s(:str, "    }\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  foo\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  counter = 2\n"),
      s(:str, "  while true\n"),
      s(:str, "    counter -= 1\n"),
      s(:str, "    next if counter != 0\n"),
      s(:str, "    break\n"),
      s(:str, "  end\n"),
      s(:str, "  :ok\n")),
    s(:str, "[ruby-core:14385]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  counter = 2\n"),
      s(:str, "  while true\n"),
      s(:str, "    counter -= 1\n"),
      s(:str, "    next if counter != 0\n"),
      s(:str, "    break :ok\n"),
      s(:str, "  end # direct\n")),
    s(:str, "[ruby-core:14385]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  counter = 2\n"),
      s(:str, "  while true\n"),
      s(:str, "    counter -= 1\n"),
      s(:str, "    break if counter == 0\n"),
      s(:str, "    \"\#{next}\"\n"),
      s(:str, "  end\n"),
      s(:str, "  :ok\n")),
    s(:str, "reported by Yusuke ENDOH")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  counter = 2\n"),
      s(:str, "  while true\n"),
      s(:str, "    counter -= 1\n"),
      s(:str, "    break if counter == 0\n"),
      s(:str, "    next\n"),
      s(:str, "    redo\n"),
      s(:str, "  end\n"),
      s(:str, "  :ok\n")),
    s(:str, "reported by Yusuke ENDOH")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  counter = 2\n"),
      s(:str, "  while true\n"),
      s(:str, "    counter -= 1\n"),
      s(:str, "    break if counter == 0\n"),
      s(:str, "    next\n"),
      s(:str, "    \"\#{ redo }\"\n"),
      s(:str, "  end\n"),
      s(:str, "  :ok\n")),
    s(:str, "reported by Yusuke ENDOH")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    raise\n"),
      s(:str, "  rescue\n"),
      s(:str, "    counter = 2\n"),
      s(:str, "    while true\n"),
      s(:str, "      counter -= 1\n"),
      s(:str, "      break if counter == 0\n"),
      s(:str, "      next\n"),
      s(:str, "      retry\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n")),
    s(:str, "reported by Yusuke ENDOH")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  counter = 2\n"),
      s(:str, "  while true\n"),
      s(:str, "    counter -= 1\n"),
      s(:str, "    break if counter == 0\n"),
      s(:str, "    next\n"),
      s(:str, "    \"\#{ break }\"\n"),
      s(:str, "  end\n")),
    s(:str, "reported by Yusuke ENDOH")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  counter = 2\n"),
      s(:str, "  while true\n"),
      s(:str, "    counter -= 1\n"),
      s(:str, "    next if counter != 0\n"),
      s(:str, "    \"\#{ break }\"\n"),
      s(:str, "  end\n")),
    s(:str, "reported by Yusuke ENDOH")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  1.times do\n"),
      s(:str, "    [\n"),
      s(:str, "      1, 2, 3, 4, 5, 6, 7, 8,\n"),
      s(:str, "      begin\n"),
      s(:str, "        false ? next : p\n"),
      s(:str, "        break while true\n"),
      s(:str, "      end\n"),
      s(:str, "    ]\n"),
      s(:str, "  end\n"),
      s(:str, "  :ok\n")),
    s(:str, "[ruby-dev:32882]")),
  s(:send, nil, :assert_equal,
    s(:str, "1\n2\n"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  while i<2\n"),
      s(:str, "    i += 1\n"),
      s(:str, "    next p(i)\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_valid_syntax,
    s(:str, "1.times {|i|print (42),1;}"),
    s(:str, "[ruby-list:44479]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def a() end\n"),
      s(:str, "  begin\n"),
      s(:str, "    if defined?(a(1).a)\n"),
      s(:str, "      :ng\n"),
      s(:str, "    else\n"),
      s(:str, "      :ok\n"),
      s(:str, "    end\n"),
      s(:str, "  rescue\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:16010]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def a() end\n"),
      s(:str, "  begin\n"),
      s(:str, "    if defined?(a::B)\n"),
      s(:str, "      :ng\n"),
      s(:str, "    else\n"),
      s(:str, "      :ok\n"),
      s(:str, "    end\n"),
      s(:str, "  rescue\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:16010]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  defined? C && 0\n"))),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C\n"),
      s(:str, "    def m\n"),
      s(:str, "      defined?(super())\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  C.new.m\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class X < RuntimeError;end\n"),
      s(:str, "  x = [X]\n"),
      s(:str, "  begin\n"),
      s(:str, "   raise X\n"),
      s(:str, "  rescue *x\n"),
      s(:str, "   :ok\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:14537]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  a = [false]\n"),
      s(:str, "  (a[0] &&= true) == false ? :ok : :ng\n")),
    s(:str, "[ruby-dev:34679]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  a = []\n"),
      s(:str, "  100.times {|i| a << i << nil << nil }\n"),
      s(:str, "  p a.compact!\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  \"\#{}\"\"\#{}ok\"\n")),
    s(:str, "[ruby-dev:38968]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  \"o\" \"\#{}k\"\n")),
    s(:str, "[ruby-dev:38980]")),
  s(:lvasgn, :bug2415,
    s(:str, "[ruby-core:26961]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  0.times do\n"),
      s(:str, "    0.times do\n"),
      s(:str, "      def x(a=1, b, *rest); nil end\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n")),
    s(:lvar, :bug2415)),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  0.times do\n"),
      s(:str, "    0.times do\n"),
      s(:str, "      def x@; nil end\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n")),
    s(:lvar, :bug2415)),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  0.times do\n"),
      s(:str, "    0.times do\n"),
      s(:str, "      def x(a = 0.times do\n"),
      s(:str, "              def y(a=1, b, *rest); nil; end\n"),
      s(:str, "            end)\n"),
      s(:str, "        nil\n"),
      s(:str, "      end\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n")),
    s(:lvar, :bug2415)),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  0.times do\n"),
      s(:str, "    0.times do\n"),
      s(:str, "      def x(a = 0.times do\n"),
      s(:str, "              def x@; nil; end\n"),
      s(:str, "            end)\n"),
      s(:str, "        nil\n"),
      s(:str, "      end\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n")),
    s(:lvar, :bug2415)),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  a {\n"),
      s(:str, "    b {|c.d| }\n"),
      s(:str, "    e\n"),
      s(:str, "  }\n")),
    s(:str, "[ruby-dev:39861]")),
  s(:lvasgn, :bug1240,
    s(:str, "[ruby-core:22637]")),
  s(:send, nil, :assert_valid_syntax,
    s(:str, "x y { \"\#{}\".z { } }"),
    s(:lvar, :bug1240)),
  s(:send, nil, :assert_valid_syntax,
    s(:str, "x y { \"\#{}\".z do end }"),
    s(:lvar, :bug1240)),
  s(:send, nil, :assert_valid_syntax,
    s(:str, "y \"\#{a 1}\" do end"),
    s(:str, "[ruby-core:29579]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def foo(&block)\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  foo do\n"),
      s(:str, "    s = defined?(raise + 1)\n"),
      s(:str, "    Class\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:30293]")))
