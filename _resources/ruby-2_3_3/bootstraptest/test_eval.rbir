s(:begin,
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    a = :ok\n"),
      s(:str, "    $b = binding\n"),
      s(:str, "  end\n"),
      s(:str, "  m\n"),
      s(:str, "  eval('a', $b)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[:ok, :ok2]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    a = :ok\n"),
      s(:str, "    $b = binding\n"),
      s(:str, "  end\n"),
      s(:str, "  m\n"),
      s(:str, "  eval('b = :ok2', $b)\n"),
      s(:str, "  eval('[a, b]', $b)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[nil, 1]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  $ans = []\n"),
      s(:str, "  def m\n"),
      s(:str, "    $b = binding\n"),
      s(:str, "  end\n"),
      s(:str, "  m\n"),
      s(:str, "  $ans << eval(%q{\n"),
      s(:str, "    $ans << eval(%q{\n"),
      s(:str, "      a\n"),
      s(:str, "    }, $b)\n"),
      s(:str, "    a = 1\n"),
      s(:str, "  }, $b)\n"),
      s(:str, "  $ans\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "C"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Const = :top\n"),
      s(:str, "  class C\n"),
      s(:str, "    Const = :C\n"),
      s(:str, "    def m\n"),
      s(:str, "      binding\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  eval('Const', C.new.m)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "top"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Const = :top\n"),
      s(:str, "  a = 1\n"),
      s(:str, "  class C\n"),
      s(:str, "    Const = :C\n"),
      s(:str, "    def m\n"),
      s(:str, "      eval('Const', TOPLEVEL_BINDING)\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  C.new.m\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr,
      s(:str, ":ok\n"),
      s(:str, "ok")),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C\n"),
      s(:str, "    $b = binding\n"),
      s(:str, "  end\n"),
      s(:str, "  eval %q{\n"),
      s(:str, "    def m\n"),
      s(:str, "      :ok\n"),
      s(:str, "    end\n"),
      s(:str, "  }, $b\n"),
      s(:str, "  p C.new.m\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  b = proc{\n"),
      s(:str, "    a = :ok\n"),
      s(:str, "    binding\n"),
      s(:str, "  }.call\n"),
      s(:str, "  a = :ng\n"),
      s(:str, "  eval(\"a\", b)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "C"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C\n"),
      s(:str, "    def foo\n"),
      s(:str, "      binding\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  C.new.foo.eval(\"self.class.to_s\")\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  eval('1')\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  eval('a=1; a')\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  a = 1\n"),
      s(:str, "  eval('a')\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  __send__ :eval, %{\n"),
      s(:str, "    :ok\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  1.__send__ :instance_eval, %{\n"),
      s(:str, "    :ok\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  1.instance_eval{\n"),
      s(:str, "    self\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "foo"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  'foo'.instance_eval{\n"),
      s(:str, "    self\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class Fixnum\n"),
      s(:str, "    Const = 1\n"),
      s(:str, "  end\n"),
      s(:str, "  1.instance_eval %{\n"),
      s(:str, "    Const\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "top"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Const = :top\n"),
      s(:str, "  class C\n"),
      s(:str, "    Const = :C\n"),
      s(:str, "  end\n"),
      s(:str, "  C.module_eval{\n"),
      s(:str, "    Const\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "C"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Const = :top\n"),
      s(:str, "  class C\n"),
      s(:str, "    Const = :C\n"),
      s(:str, "  end\n"),
      s(:str, "  C.class_eval %{\n"),
      s(:str, "    def m\n"),
      s(:str, "      Const\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"),
      s(:str, "  C.new.m\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "top"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Const = :top\n"),
      s(:str, "  class C\n"),
      s(:str, "    Const = :C\n"),
      s(:str, "  end\n"),
      s(:str, "  C.class_eval{\n"),
      s(:str, "    def m\n"),
      s(:str, "      Const\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"),
      s(:str, "  C.new.m\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[:top, :C, :top, :C]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Const = :top\n"),
      s(:str, "  class C\n"),
      s(:str, "    Const = :C\n"),
      s(:str, "  end\n"),
      s(:str, "  $nest = false\n"),
      s(:str, "  $ans = []\n"),
      s(:str, "  def m\n"),
      s(:str, "    $ans << Const\n"),
      s(:str, "    C.module_eval %{\n"),
      s(:str, "      $ans << Const\n"),
      s(:str, "      Boo = false unless defined? Boo\n"),
      s(:str, "      unless $nest\n"),
      s(:str, "        $nest = true\n"),
      s(:str, "        m\n"),
      s(:str, "      end\n"),
      s(:str, "    }\n"),
      s(:str, "  end\n"),
      s(:str, "  m\n"),
      s(:str, "  $ans\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[10, main]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  $nested = false\n"),
      s(:str, "  $ans = []\n"),
      s(:str, "  $pr = proc{\n"),
      s(:str, "    $ans << self\n"),
      s(:str, "    unless $nested\n"),
      s(:str, "      $nested = true\n"),
      s(:str, "      $pr.call\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"),
      s(:str, "  class C\n"),
      s(:str, "    def initialize &b\n"),
      s(:str, "      10.instance_eval(&b)\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  C.new(&$pr)\n"),
      s(:str, "  $ans\n"))),
  s(:block,
    s(:send,
      s(:array,
        s(:str, "break"),
        s(:str, "next"),
        s(:str, "redo")), :each),
    s(:args,
      s(:arg, :keyword)),
    s(:send, nil, :assert_match,
      s(:regexp,
        s(:str, "Can't escape from eval with "),
        s(:begin,
          s(:lvar, :keyword)),
        s(:str, "\\z"),
        s(:regopt)),
      s(:dstr,
        s(:str, "\n"),
        s(:str, "    begin\n"),
        s(:str, "      eval \"0 rescue "),
        s(:begin,
          s(:lvar, :keyword)),
        s(:str, "\"\n"),
        s(:str, "    rescue SyntaxError => e\n"),
        s(:str, "      e.message\n"),
        s(:str, "    end\n"),
        s(:str, "  ")),
      s(:str, "[ruby-dev:31372]"))),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  STDERR.reopen(STDOUT)\n"),
      s(:str, "  class Foo\n"),
      s(:str, "     def self.add_method\n"),
      s(:str, "       class_eval(\"def some-bad-name; puts 'hello' unless @some_variable.some_function(''); end\")\n"),
      s(:str, "     end\n"),
      s(:str, "  end\n"),
      s(:str, "  Foo.add_method\n")),
    s(:str, "[ruby-core:14556] reported by Frederick Cheung")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class Module\n"),
      s(:str, "    def my_module_eval(&block)\n"),
      s(:str, "      module_eval(&block)\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  class String\n"),
      s(:str, "    Integer.my_module_eval do\n"),
      s(:str, "      def hoge; end\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  if Integer.instance_methods(false).map{|m|m.to_sym}.include?(:hoge) &&\n"),
      s(:str, "     !String.instance_methods(false).map{|m|m.to_sym}.include?(:hoge)\n"),
      s(:str, "    :ok\n"),
      s(:str, "  else\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-dev:34236]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    eval(\"class nil::Foo; end\")\n"),
      s(:str, "    :ng\n"),
      s(:str, "  rescue Exception\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    0.instance_eval { def m() :m end }\n"),
      s(:str, "    1.m\n"),
      s(:str, "    :ng\n"),
      s(:str, "  rescue Exception\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-dev:34579]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    12.instance_eval { @@a }\n"),
      s(:str, "  rescue NameError\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:16794]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    12.instance_exec { @@a }\n"),
      s(:str, "  rescue NameError\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:16794]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  nil.instance_eval {\n"),
      s(:str, "    def defd_using_instance_eval() :ok end\n"),
      s(:str, "  }\n"),
      s(:str, "  nil.defd_using_instance_eval\n")),
    s(:str, "[ruby-core:28324]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  nil.instance_exec {\n"),
      s(:str, "    def defd_using_instance_exec() :ok end\n"),
      s(:str, "  }\n"),
      s(:str, "  nil.defd_using_instance_exec\n")),
    s(:str, "[ruby-core:28324]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  eval(\"\", method(:proc).call {}.binding)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, ""),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  b = binding\n"),
      s(:str, "  10.times{\n"),
      s(:str, "    eval('', b)\n"),
      s(:str, "  }\n"),
      s(:str, "  begin\n"),
      s(:str, "    eval('1.times{raise}', b)\n"),
      s(:str, "  rescue => e\n"),
      s(:str, "    e.message\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-dev:35392]")),
  s(:send, nil, :assert_equal,
    s(:str, "[:x]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def kaboom!\n"),
      s(:str, "    yield.eval(\"local_variables\")\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  for x in enum_for(:kaboom!)\n"),
      s(:str, "    binding\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:25125]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  hash = {}\n"),
      s(:str, "  (\"aaaa\"..\"matz\").each_with_index do |s, i|\n"),
      s(:str, "    hash[s] = i\n"),
      s(:str, "  end\n"),
      s(:str, "  begin\n"),
      s(:str, "    eval \"class C; @@h = \#{hash.inspect}; end\"\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:25714]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    eval(\"# encoding:utf-16le\\nfoo\")\n"),
      s(:str, "  rescue Exception => e\n"),
      s(:str, "    p e\n"),
      s(:str, "    RubyVM::InstructionSequence.compile(\"p:hello\")\n"),
      s(:str, "  end\n")),
    s(:str, "check escaping the internal value th->base_block")))
