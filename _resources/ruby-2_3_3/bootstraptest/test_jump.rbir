s(:begin,
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    :ng1\n"),
      s(:str, "    mm{\n"),
      s(:str, "      yield\n"),
      s(:str, "    }\n"),
      s(:str, "    :ng2\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def mm\n"),
      s(:str, "    :ng3\n"),
      s(:str, "    yield\n"),
      s(:str, "    :ng4\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  m{\n"),
      s(:str, "    break :ok\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  3.times{\n"),
      s(:str, "    break :ok\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  catch(:foo){\n"),
      s(:str, "    throw :foo\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "false"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  catch(:foo){\n"),
      s(:str, "    throw :foo, false\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  catch(:foo){\n"),
      s(:str, "    throw :foo, nil\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  catch(:foo){\n"),
      s(:str, "    throw :foo, :ok\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:dstr),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  catch(:foo){\n"),
      s(:str, "    1.times{\n"),
      s(:str, "      throw :foo\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  catch(:foo){\n"),
      s(:str, "    1.times{\n"),
      s(:str, "      throw :foo, :ok\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  catch(:foo){\n"),
      s(:str, "    catch(:bar){\n"),
      s(:str, "      throw :foo, :ok\n"),
      s(:str, "    }\n"),
      s(:str, "    :ng\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  catch(:foo){\n"),
      s(:str, "    catch(:bar){\n"),
      s(:str, "      1.times{\n"),
      s(:str, "        throw :foo, :ok\n"),
      s(:str, "      }\n"),
      s(:str, "    }\n"),
      s(:str, "    :ng\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  module Enumerable\n"),
      s(:str, "    def all_?\n"),
      s(:str, "      self.each{|e|\n"),
      s(:str, "        unless yield(e)\n"),
      s(:str, "          return false\n"),
      s(:str, "        end\n"),
      s(:str, "      }\n"),
      s(:str, "      true\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  xxx = 0\n"),
      s(:str, "  [1,2].each{|bi|\n"),
      s(:str, "    [3,4].each{|bj|\n"),
      s(:str, "      [true, nil, true].all_?{|be| be}\n"),
      s(:str, "      break\n"),
      s(:str, "    }\n"),
      s(:str, "    xxx += 1\n"),
      s(:str, "  }\n"),
      s(:str, "  xxx\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  m{\n"),
      s(:str, "    begin\n"),
      s(:str, "    ensure\n"),
      s(:str, "      break :ok\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"),
      s(:str, "  i=0\n"),
      s(:str, "  m{\n"),
      s(:str, "    if i>10\n"),
      s(:str, "      i*i\n"),
      s(:str, "    else\n"),
      s(:str, "      i+=1\n"),
      s(:str, "      next\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  m{\n"),
      s(:str, "    next :ok\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "131"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield + 10\n"),
      s(:str, "  end\n"),
      s(:str, "  i=0\n"),
      s(:str, "  m{\n"),
      s(:str, "    if i>10\n"),
      s(:str, "      i*i\n"),
      s(:str, "    else\n"),
      s(:str, "      i+=1\n"),
      s(:str, "      redo\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "begin\n"),
      s(:str, "  eval %q{\n"),
      s(:str, "    1.times{\n"),
      s(:str, "      retry\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"),
      s(:str, "rescue SyntaxError\n"),
      s(:str, "  :ok\n"),
      s(:str, "end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "3"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    return 3\n"),
      s(:str, "  end\n"),
      s(:str, "  m\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    :ng1\n"),
      s(:str, "    mm{\n"),
      s(:str, "      return :ok\n"),
      s(:str, "    }\n"),
      s(:str, "    :ng2\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def mm\n"),
      s(:str, "    :ng3\n"),
      s(:str, "    yield\n"),
      s(:str, "    :ng4\n"),
      s(:str, "  end\n"),
      s(:str, "  m\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "100"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  $i = 0\n"),
      s(:str, "  def m\n"),
      s(:str, "    begin\n"),
      s(:str, "      iter{\n"),
      s(:str, "        return\n"),
      s(:str, "      }\n"),
      s(:str, "    ensure\n"),
      s(:str, "      $i = 100\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "  m\n"),
      s(:str, "  $i\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    begin\n"),
      s(:str, "      raise\n"),
      s(:str, "    rescue\n"),
      s(:str, "      return :ok\n"),
      s(:str, "    end\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n"),
      s(:str, "  m\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    begin\n"),
      s(:str, "      raise\n"),
      s(:str, "    rescue\n"),
      s(:str, "      return 1\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  m\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    begin\n"),
      s(:str, "      #\n"),
      s(:str, "    ensure\n"),
      s(:str, "      return 1\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  m\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    catch {|t| throw t, :ok }\n"),
      s(:str, "  rescue ArgumentError\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-dev:31609]")),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  catch do |t|\n"),
      s(:str, "    begin\n"),
      s(:str, "      throw t, 1\n"),
      s(:str, "      2\n"),
      s(:str, "    ensure\n"),
      s(:str, "      3\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-dev:31698]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  f = 0\n"),
      s(:str, "  1.times do\n"),
      s(:str, "    begin\n"),
      s(:str, "      f += 1\n"),
      s(:str, "    ensure\n"),
      s(:str, "      redo unless f > 2\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  -> do\n"),
      s(:str, "    1.times do\n"),
      s(:str, "      begin\n"),
      s(:str, "        raise\n"),
      s(:str, "      rescue\n"),
      s(:str, "        return\n"),
      s(:str, "      end\n"),
      s(:str, "    end\n"),
      s(:str, "  end.call\n"))),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  while true\n"),
      s(:str, "    begin\n"),
      s(:str, "      raise\n"),
      s(:str, "      next\n"),
      s(:str, "    rescue\n"),
      s(:str, "    end\n"),
      s(:str, "    break\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:28172]")),
  s(:send, nil, :assert_equal,
    s(:str, "true"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class Object\n"),
      s(:str, "    def return_eigenclass\n"),
      s(:str, "      class << self\n"),
      s(:str, "        return self\n"),
      s(:str, "      end\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  s = \"foo\"\n"),
      s(:str, "  s.return_eigenclass == class << s; self; end\n")),
    s(:str, "[ruby-core:21379]")),
  s(:send, nil, :assert_equal,
    s(:str, "true"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class Object\n"),
      s(:str, "    def yield_eigenclass\n"),
      s(:str, "      class << self\n"),
      s(:str, "        yield self\n"),
      s(:str, "      end\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  s = \"foo\"\n"),
      s(:str, "  s.yield_eigenclass {|c| c == class << s; self; end }\n")),
    s(:str, "[ruby-dev:40975]")))
