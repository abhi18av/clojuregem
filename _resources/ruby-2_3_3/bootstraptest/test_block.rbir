s(:begin,
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  1.times{\n"),
      s(:str, "    begin\n"),
      s(:str, "      a = 1\n"),
      s(:str, "    ensure\n"),
      s(:str, "      foo = nil\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  [1,2,3].find{|x| x == 2}\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class E\n"),
      s(:str, "    include Enumerable\n"),
      s(:str, "    def each(&block)\n"),
      s(:str, "      [1, 2, 3].each(&block)\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  E.new.find {|x| x == 2 }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "6"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  sum = 0\n"),
      s(:str, "  for x in [1, 2, 3]\n"),
      s(:str, "    sum += x\n"),
      s(:str, "  end\n"),
      s(:str, "  sum\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "15"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  sum = 0\n"),
      s(:str, "  for x in (1..5)\n"),
      s(:str, "    sum += x\n"),
      s(:str, "  end\n"),
      s(:str, "  sum\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "0"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  sum = 0\n"),
      s(:str, "  for x in []\n"),
      s(:str, "    sum += x\n"),
      s(:str, "  end\n"),
      s(:str, "  sum\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ans = []\n"),
      s(:str, "  1.times{\n"),
      s(:str, "    for n in 1..3\n"),
      s(:str, "      a = n\n"),
      s(:str, "      ans << a\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1..3"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ans = []\n"),
      s(:str, "  for m in 1..3\n"),
      s(:str, "    for n in 1..3\n"),
      s(:str, "      a = [m, n]\n"),
      s(:str, "      ans << a\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[1, 2, 3]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  (1..3).to_a\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[4, 8, 12]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  (1..3).map{|e|\n"),
      s(:str, "    e * 4\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[1, 2, 3]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C\n"),
      s(:str, "    include Enumerable\n"),
      s(:str, "    def each\n"),
      s(:str, "      [1,2,3].each{|e|\n"),
      s(:str, "        yield e\n"),
      s(:str, "      }\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  C.new.to_a\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[4, 5, 6]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C\n"),
      s(:str, "    include Enumerable\n"),
      s(:str, "    def each\n"),
      s(:str, "      [1,2,3].each{|e|\n"),
      s(:str, "        yield e\n"),
      s(:str, "      }\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  C.new.map{|e|\n"),
      s(:str, "    e + 3\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "100"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "  def n\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  m{\n"),
      s(:str, "    n{\n"),
      s(:str, "      100\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "20"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield 1\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  m{|ib|\n"),
      s(:str, "    m{|jb|\n"),
      s(:str, "      i = 20\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield 1\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  m{|ib|\n"),
      s(:str, "    m{|jb|\n"),
      s(:str, "      ib = 20\n"),
      s(:str, "      kb = 2\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "3"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter1\n"),
      s(:str, "    iter2{\n"),
      s(:str, "      yield\n"),
      s(:str, "    }\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def iter2\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  iter1{\n"),
      s(:str, "    jb = 2\n"),
      s(:str, "    iter1{\n"),
      s(:str, "      jb = 3\n"),
      s(:str, "    }\n"),
      s(:str, "    jb\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter1\n"),
      s(:str, "    iter2{\n"),
      s(:str, "      yield\n"),
      s(:str, "    }\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def iter2\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  iter1{\n"),
      s(:str, "    jb = 2\n"),
      s(:str, "    iter1{\n"),
      s(:str, "      jb\n"),
      s(:str, "    }\n"),
      s(:str, "    jb\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield 1\n"),
      s(:str, "  end\n"),
      s(:str, "  m{|ib|\n"),
      s(:str, "    ib*2\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "92580"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield 12345, 67890\n"),
      s(:str, "  end\n"),
      s(:str, "  m{|ib,jb|\n"),
      s(:str, "    ib*2+jb\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[10, nil]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield 10\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  a = nil\n"),
      s(:str, "  [iter{|a|\n"),
      s(:str, "    a\n"),
      s(:str, "  }, a]\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "21"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield 10\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  iter{|a|\n"),
      s(:str, "    iter{|a|\n"),
      s(:str, "      a + 1\n"),
      s(:str, "    } + a\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[10, 20, 30, 40, nil, nil, nil, nil]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield 10, 20, 30, 40\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  a = b = c = d = nil\n"),
      s(:str, "  iter{|a, b, c, d|\n"),
      s(:str, "    [a, b, c, d]\n"),
      s(:str, "  } + [a, b, c, d]\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[10, 20, 30, 40, nil, nil]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield 10, 20, 30, 40\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  a = b = nil\n"),
      s(:str, "  iter{|a, b, c, d|\n"),
      s(:str, "    [a, b, c, d]\n"),
      s(:str, "  } + [a, b]\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[1]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  $a = []\n"),
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield 1\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    x = iter{|x|\n"),
      s(:str, "      $a << x\n"),
      s(:str, "      y = 0\n"),
      s(:str, "    }\n"),
      s(:str, "  end\n"),
      s(:str, "  m\n"),
      s(:str, "  $a\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[1, [2]]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield 1, 2\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  iter{|a, *b|\n"),
      s(:str, "    [a, b]\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[[1, 2]]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield 1, 2\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  iter{|*a|\n"),
      s(:str, "    [a]\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[1, 2, []]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield 1, 2\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  iter{|a, b, *c|\n"),
      s(:str, "    [a, b, c]\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[1, 2, nil, []]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield 1, 2\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  iter{|a, b, c, *d|\n"),
      s(:str, "    [a, b, c, d]\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "  m{\n"),
      s(:str, "    1\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "15129"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield 123\n"),
      s(:str, "  end\n"),
      s(:str, "  m{|ib|\n"),
      s(:str, "    m{|jb|\n"),
      s(:str, "      ib*jb\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "2"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m a\n"),
      s(:str, "    yield a\n"),
      s(:str, "  end\n"),
      s(:str, "  m(1){|ib|\n"),
      s(:str, "    m(2){|jb|\n"),
      s(:str, "      ib*jb\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "9"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  sum = 0\n"),
      s(:str, "  3.times{|ib|\n"),
      s(:str, "    2.times{|jb|\n"),
      s(:str, "      sum += ib + jb\n"),
      s(:str, "    }}\n"),
      s(:str, "  sum\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "10"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  3.times{|bl|\n"),
      s(:str, "    break 10\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[1, 2]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield 1,2,3\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  iter{|i, j|\n"),
      s(:str, "    [i, j]\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[1, nil]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield 1\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  iter{|i, j|\n"),
      s(:str, "    [i, j]\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "0"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "def m()\n"),
      s(:str, "end\n"),
      s(:str, "m {|(v0,*,(*)),|}\n"),
      s(:str, "m {|(*v0,(*)),|}\n"),
      s(:str, "m {|(v0,*v1,(*)),|}\n"),
      s(:str, "m {|((v0,*v1,v2)),|}\n"),
      s(:str, "m {|(v0,*v1,v2),|}\n"),
      s(:str, "m {|(v0,*v1,(v2)),|}\n"),
      s(:str, "m {|((*),*v0,v1),|}\n"),
      s(:str, "m {|((v0),*v1,v2),|}\n"),
      s(:str, "m {|(v0,v1,*v2,v3),|}\n"),
      s(:str, "m {|v0,(v1,*v2,v3),|}\n"),
      s(:str, "m {|(v0,*v1,v2),v3,|}\n"),
      s(:str, "m {|(v0,*v1,v2)|}\n"),
      s(:str, "m {|(v0,*v1,v2),&v3|}\n"),
      s(:str, "m {|(v0,*v1,v2),*|}\n"),
      s(:str, "m {|(v0,*v1,v2),*,&v3|}\n"),
      s(:str, "m {|*,(v0,*v1,v2)|}\n"),
      s(:str, "m {|*,(v0,*v1,v2),&v3|}\n"),
      s(:str, "m {|v0,*,(v1,*v2,v3)|}\n"),
      s(:str, "m {|v0,*,(v1,*v2,v3),&v4|}\n"),
      s(:str, "m {|(v0,*v1,v2),*,v3|}\n"),
      s(:str, "m {|(v0,*v1,v2),*,v3,&v4|}\n"),
      s(:str, "m {|(v0, *v1, v2)|}\n"),
      s(:str, "m {|(*,v)|}\n"),
      s(:str, "0\n")),
    s(:str, "block parameter (shouldn't SEGV: [ruby-dev:31143])")),
  s(:send, nil, :assert_equal,
    s(:str, "nil"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "  m{|&b| b}.inspect\n")),
    s(:str, "[ruby-dev:31147]")),
  s(:send, nil, :assert_equal,
    s(:str, "nil"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m()\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "  m {|(v,(*))|}.inspect\n")),
    s(:str, "[ruby-dev:31160]")),
  s(:send, nil, :assert_equal,
    s(:str, "nil"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m()\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "  m {|(*,a,b)|}.inspect\n")),
    s(:str, "[ruby-dev:31153]")),
  s(:send, nil, :assert_equal,
    s(:str, "nil"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m()\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "  m {|((*))|}.inspect\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[1, 1, [1, nil], [1, nil], [1, nil], [1, nil], [1, 1], 1, [1, nil], [1, nil], [1, nil], [1, nil], [[1, 1], [1, 1]], [1, 1], [1, 1], [1, 1], [1, nil], [1, nil], [[[1, 1], [1, 1]], [[1, 1], [1, 1]]], [[1, 1], [1, 1]], [[1, 1], [1, 1]], [[1, 1], [1, 1]], [1, 1], [1, 1], [[[[1, 1], [1, 1]], [[1, 1], [1, 1]]], [[[1, 1], [1, 1]], [[1, 1], [1, 1]]]], [[[1, 1], [1, 1]], [[1, 1], [1, 1]]], [[[1, 1], [1, 1]], [[1, 1], [1, 1]]], [[[1, 1], [1, 1]], [[1, 1], [1, 1]]], [[1, 1], [1, 1]], [[1, 1], [1, 1]]]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "def m(ary = [])\n"),
      s(:str, "  yield(ary)\n"),
      s(:str, "end\n"),
      s(:str, "\n"),
      s(:str, "$ans = []\n"),
      s(:str, "o = 1\n"),
      s(:str, "5.times{\n"),
      s(:str, "  v,(*) = o; $ans << o\n"),
      s(:str, "  m(o){|(v,(*))| $ans << v}\n"),
      s(:str, "  ((x, y)) = o; $ans << [x, y]\n"),
      s(:str, "  m(o){|((x, y))| $ans << [x, y]}\n"),
      s(:str, "  (((x, y))) = o; $ans << [x, y]\n"),
      s(:str, "  m(o){|(((x, y)))| $ans << [x, y]}\n"),
      s(:str, "  o = [o, o]\n"),
      s(:str, "}; $ans\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "0"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m()\n"),
      s(:str, "    yield [0]\n"),
      s(:str, "  end\n"),
      s(:str, "  m {|*,v| v}.inspect\n")),
    s(:str, "[ruby-dev:31437]")),
  s(:send, nil, :assert_equal,
    s(:str, "[0]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield [0]\n"),
      s(:str, "  end\n"),
      s(:str, "  m{|v, &b| v}.inspect\n")),
    s(:str, "[ruby-dev:31440]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    lambda{|a|}.call(1, 2)\n"),
      s(:str, "  rescue ArgumentError\n"),
      s(:str, "    :ok\n"),
      s(:str, "  else\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-dev:31464]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    lambda{|&b|}.call(3)\n"),
      s(:str, "  rescue ArgumentError\n"),
      s(:str, "    :ok\n"),
      s(:str, "  else\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-dev:31472]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C\n"),
      s(:str, "    def each\n"),
      s(:str, "      yield [1,2]\n"),
      s(:str, "      yield 1,2\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  vs1 = []\n"),
      s(:str, "  C.new.each {|*v| vs1 << v }\n"),
      s(:str, "  vs2 = []\n"),
      s(:str, "  C.new.to_enum.each {|*v| vs2 << v }\n"),
      s(:str, "  vs1 == vs2 ? :ok : :ng\n")),
    s(:str, "[ruby-dev:32329]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  e = [1,2,3].each\n"),
      s(:str, "  10000.times {\n"),
      s(:str, "    e = [e].each\n"),
      s(:str, "  }\n"),
      s(:str, "  Thread.new { GC.start }.join\n")),
    s(:str, "[ruby-dev:32604]")),
  s(:send, nil, :assert_equal,
    s(:str, "[nil, []]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m() yield nil,[] end\n"),
      s(:str, "  l = lambda {|*v| v}\n"),
      s(:str, "  GC.stress=true\n"),
      s(:str, "  r = m(&l)\n"),
      s(:str, "  GC.stress=false\n"),
      s(:str, "  r.inspect\n")),
    s(:str, "[ruby-dev:32567]")),
  s(:send, nil, :assert_equal,
    s(:send,
      s(:const, nil, :NilClass), :to_s),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  r = false; 1.times{|&b| r = b}; r.class\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C\n"),
      s(:str, "    define_method(:foo) do |arg, &block|\n"),
      s(:str, "      if block then block.call else arg end\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  C.new.foo(\"ng\") {\"ok\"}\n")),
    s(:str, "[ruby-talk:266422]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C\n"),
      s(:str, "    define_method(:xyz) do |o, k, &block|\n"),
      s(:str, "      block.call(o, k)\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  C.new.xyz(\"o\",\"k\") {|o, k| o+k}\n")),
    s(:str, "[ruby-core:20544]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C\n"),
      s(:str, "    define_method(:xyz) do |*args, &block|\n"),
      s(:str, "      block.call(*args)\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  C.new.xyz(\"o\",\"k\") {|*args| args.join(\"\")}\n")),
    s(:str, "[ruby-core:20544]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  STDERR.reopen(STDOUT)\n"),
      s(:str, "  class C\n"),
      s(:str, "    define_method(:foo) do |&block|\n"),
      s(:str, "      block.call if block\n"),
      s(:str, "    end\n"),
      s(:str, "    result = \"ng\"\n"),
      s(:str, "    new.foo() {result = \"ok\"}\n"),
      s(:str, "    result\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class Bar\n"),
      s(:str, "    def bar; :ok; end\n"),
      s(:str, "  end\n"),
      s(:str, "  def foo\n"),
      s(:str, "    yield(Bar.new) if block_given?\n"),
      s(:str, "  end\n"),
      s(:str, "  foo(&:bar)\n")),
    s(:str, "[ruby-core:14279]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class Controller\n"),
      s(:str, "    def respond_to(&block)\n"),
      s(:str, "      responder = Responder.new\n"),
      s(:str, "      block.call(responder)\n"),
      s(:str, "      responder.respond\n"),
      s(:str, "    end\n"),
      s(:str, "    def test_for_bug\n"),
      s(:str, "      respond_to{|format|\n"),
      s(:str, "        format.js{\n"),
      s(:str, "          puts \"in test\"\n"),
      s(:str, "          render{|obj|\n"),
      s(:str, "            puts obj\n"),
      s(:str, "          }\n"),
      s(:str, "        }\n"),
      s(:str, "      }\n"),
      s(:str, "    end\n"),
      s(:str, "    def render(&block)\n"),
      s(:str, "      puts \"in render\"\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  class Responder\n"),
      s(:str, "    def method_missing(symbol, &block)\n"),
      s(:str, "      puts \"enter method_missing\"\n"),
      s(:str, "      @response = Proc.new{\n"),
      s(:str, "        puts 'in method missing'\n"),
      s(:str, "        block.call\n"),
      s(:str, "      }\n"),
      s(:str, "      puts \"leave method_missing\"\n"),
      s(:str, "    end\n"),
      s(:str, "    def respond\n"),
      s(:str, "      @response.call\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  t = Controller.new\n"),
      s(:str, "  t.test_for_bug\n")),
    s(:str, "[ruby-core:14395]")),
  s(:send, nil, :assert_equal,
    s(:str, "true"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C0\n"),
      s(:str, "    def foo\n"),
      s(:str, "      block_given?\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  class C1 < C0\n"),
      s(:str, "    def foo\n"),
      s(:str, "      super\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  C1.new.foo{}\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "true"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C0\n"),
      s(:str, "    def foo\n"),
      s(:str, "      block_given?\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  class C1 < C0\n"),
      s(:str, "    def foo\n"),
      s(:str, "      super()\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  C1.new.foo{}\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  1.times do\n"),
      s(:str, "    begin\n"),
      s(:str, "      raise\n"),
      s(:str, "    rescue\n"),
      s(:str, "      begin\n"),
      s(:str, "        raise\n"),
      s(:str, "      rescue\n"),
      s(:str, "        break\n"),
      s(:str, "      end\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "  'ok'\n"))))
