s(:begin,
  s(:send, nil, :assert_equal,
    s(:str, "[1, 2, 3]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def getproc &b\n"),
      s(:str, "    b\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  m{\n"),
      s(:str, "    i = 1\n"),
      s(:str, "    m{\n"),
      s(:str, "      j = 2\n"),
      s(:str, "      m{\n"),
      s(:str, "        k = 3\n"),
      s(:str, "        getproc{\n"),
      s(:str, "          [i, j, k]\n"),
      s(:str, "        }\n"),
      s(:str, "      }\n"),
      s(:str, "    }\n"),
      s(:str, "  }.call\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "7"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def make_proc(&b)\n"),
      s(:str, "    b\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def make_closure\n"),
      s(:str, "    a = 0\n"),
      s(:str, "    make_proc{\n"),
      s(:str, "      a+=1\n"),
      s(:str, "    }\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  cl = make_closure\n"),
      s(:str, "  cl.call + cl.call * cl.call\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class C\n"),
      s(:str, "    def foo\n"),
      s(:str, "      :ok\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def block\n"),
      s(:str, "    C.method(:new).to_proc\n"),
      s(:str, "  end\n"),
      s(:str, "  b = block()\n"),
      s(:str, "  b.call.foo\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[0, 1, :last, 0, 2, :last]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def proc &b\n"),
      s(:str, "    b\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  pr = []\n"),
      s(:str, "  proc{|i_b|\n"),
      s(:str, "    p3 = proc{|j_b|\n"),
      s(:str, "      pr << proc{|k_b|\n"),
      s(:str, "        [i_b, j_b, k_b]\n"),
      s(:str, "      }\n"),
      s(:str, "    }\n"),
      s(:str, "    p3.call(1)\n"),
      s(:str, "    p3.call(2)\n"),
      s(:str, "  }.call(0)\n"),
      s(:str, "\n"),
      s(:str, "  pr[0].call(:last).concat pr[1].call(:last)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "12"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def getproc &b\n"),
      s(:str, "    b\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  iter{\n"),
      s(:str, "    bvar = 3\n"),
      s(:str, "    getproc{\n"),
      s(:str, "      bvar2 = 4\n"),
      s(:str, "      bvar * bvar2\n"),
      s(:str, "    }\n"),
      s(:str, "  }.call\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "200"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def iter\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def getproc &b\n"),
      s(:str, "    b\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  loc1 = 0\n"),
      s(:str, "  pr1 = iter{\n"),
      s(:str, "    bl1 = 1\n"),
      s(:str, "    getproc{\n"),
      s(:str, "      loc1 += 1\n"),
      s(:str, "      bl1  += 1\n"),
      s(:str, "      loc1 + bl1\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"),
      s(:str, "\n"),
      s(:str, "  pr2 = iter{\n"),
      s(:str, "    bl1 = 1\n"),
      s(:str, "    getproc{\n"),
      s(:str, "      loc1 += 1\n"),
      s(:str, "      bl1  += 1\n"),
      s(:str, "      loc1 + bl1\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"),
      s(:str, "\n"),
      s(:str, "  pr1.call; pr2.call\n"),
      s(:str, "  pr1.call; pr2.call\n"),
      s(:str, "  pr1.call; pr2.call\n"),
      s(:str, "  (pr1.call + pr2.call) * loc1\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[1, 2]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def proc(&pr)\n"),
      s(:str, "    pr\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    a = 1\n"),
      s(:str, "    m2{\n"),
      s(:str, "      a\n"),
      s(:str, "    }\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def m2\n"),
      s(:str, "    b = 2\n"),
      s(:str, "    proc{\n"),
      s(:str, "      [yield, b]\n"),
      s(:str, "    }\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  pr = m\n"),
      s(:str, "  x = ['a', 1,2,3,4,5,6,7,8,9,0,\n"),
      s(:str, "            1,2,3,4,5,6,7,8,9,0,\n"),
      s(:str, "            1,2,3,4,5,6,7,8,9,0,\n"),
      s(:str, "            1,2,3,4,5,6,7,8,9,0,\n"),
      s(:str, "            1,2,3,4,5,6,7,8,9,0,]\n"),
      s(:str, "  pr.call\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def proc(&pr)\n"),
      s(:str, "    pr\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    a = 1\n"),
      s(:str, "    m2{\n"),
      s(:str, "      a\n"),
      s(:str, "    }\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def m2\n"),
      s(:str, "    b = 2\n"),
      s(:str, "    proc{\n"),
      s(:str, "      [yield, b]\n"),
      s(:str, "    }\n"),
      s(:str, "    100000.times{|x|\n"),
      s(:str, "      \"\#{x}\"\n"),
      s(:str, "    }\n"),
      s(:str, "    yield\n"),
      s(:str, "  end\n"),
      s(:str, "  m\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[:C, :C]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Const = :top\n"),
      s(:str, "  class C\n"),
      s(:str, "    Const = :C\n"),
      s(:str, "    $pr = proc{\n"),
      s(:str, "      (1..2).map{\n"),
      s(:str, "        Const\n"),
      s(:str, "      }\n"),
      s(:str, "    }\n"),
      s(:str, "  end\n"),
      s(:str, "  $pr.call\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "top"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Const = :top\n"),
      s(:str, "  class C\n"),
      s(:str, "    Const = :C\n"),
      s(:str, "  end\n"),
      s(:str, "  pr = proc{\n"),
      s(:str, "    Const\n"),
      s(:str, "  }\n"),
      s(:str, "  C.class_eval %q{\n"),
      s(:str, "    pr.call\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m(&b)\n"),
      s(:str, "    b\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  m{|e_proctest| e_proctest}.call(1)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "12"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m(&b)\n"),
      s(:str, "    b\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  m{|e_proctest1, e_proctest2|\n"),
      s(:str, "    a = e_proctest1 * e_proctest2 * 2\n"),
      s(:str, "    a * 3\n"),
      s(:str, "  }.call(1, 2)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[[], [1], [1, 2], [1, 2, 3]]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  [\n"),
      s(:str, "  Proc.new{|*args| args}.call(),\n"),
      s(:str, "  Proc.new{|*args| args}.call(1),\n"),
      s(:str, "  Proc.new{|*args| args}.call(1, 2),\n"),
      s(:str, "  Proc.new{|*args| args}.call(1, 2, 3),\n"),
      s(:str, "  ]\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[[nil, []], [1, []], [1, [2]], [1, [2, 3]]]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  [\n"),
      s(:str, "  Proc.new{|a, *b| [a, b]}.call(),\n"),
      s(:str, "  Proc.new{|a, *b| [a, b]}.call(1),\n"),
      s(:str, "  Proc.new{|a, *b| [a, b]}.call(1, 2),\n"),
      s(:str, "  Proc.new{|a, *b| [a, b]}.call(1, 2, 3),\n"),
      s(:str, "  ]\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "0"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  pr = proc{\n"),
      s(:str, "    $SAFE\n"),
      s(:str, "  }\n"),
      s(:str, "  $SAFE = 1\n"),
      s(:str, "  pr.call\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[1, 0]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  pr = proc{\n"),
      s(:str, "    $SAFE += 1\n"),
      s(:str, "  }\n"),
      s(:str, "  [pr.call, $SAFE]\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "1"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m(&b)\n"),
      s(:str, "    b\n"),
      s(:str, "  end\n"),
      s(:str, "  m{1}.call\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "3"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m(&b)\n"),
      s(:str, "    b\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  m{\n"),
      s(:str, "    a = 1\n"),
      s(:str, "    a + 2\n"),
      s(:str, "  }.call\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok\n"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class A; def get_block; proc {puts \"ok\"} end end\n"),
      s(:str, "  block = A.new.get_block\n"),
      s(:str, "  GC.start\n"),
      s(:str, "  block.call\n")),
    s(:str, "[ruby-core:14885]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  a = lambda {|x, y, &b| b }\n"),
      s(:str, "  b = a.curry[1]\n"),
      s(:str, "  if b.call(2){} == nil\n"),
      s(:str, "    :ng\n"),
      s(:str, "  else\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:15551]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  lambda {\n"),
      s(:str, "    break :ok\n"),
      s(:str, "    :ng\n"),
      s(:str, "  }.call\n")),
    s(:str, "[ruby-dev:34646]")),
  s(:send, nil, :assert_equal,
    s(:str, "[:bar, :foo]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def foo\n"),
      s(:str, "    klass = Class.new do\n"),
      s(:str, "      define_method(:bar) do\n"),
      s(:str, "        return :bar\n"),
      s(:str, "      end\n"),
      s(:str, "    end\n"),
      s(:str, "    [klass.new.bar, :foo]\n"),
      s(:str, "  end\n"),
      s(:str, "  foo\n")),
    s(:str, "[ ruby-Bugs-19304 ]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "   $x = :ok\n"),
      s(:str, "   def def7(x, y)\n"),
      s(:str, "      x[y]\n"),
      s(:str, "      $x = :ng\n"),
      s(:str, "   end\n"),
      s(:str, "   def test_def7\n"),
      s(:str, "      def7(lambda {|x| x.call}, Proc.new {return})\n"),
      s(:str, "      $x = :ng\n"),
      s(:str, "   end\n"),
      s(:str, "   test_def7\n"),
      s(:str, "   $x\n")),
    s(:str, "[ruby-core:17164]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  lambda { a = lambda { return }; $x = :ng; a[]; $x = :ok }.call\n"),
      s(:str, "  $x\n")),
    s(:str, "[ruby-core:17164]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  lambda { a = lambda { break }; $x = :ng; a[]; $x = :ok }.call\n"),
      s(:str, "  $x\n")),
    s(:str, "[ruby-core:17164]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def def8\n"),
      s(:str, "    $x = :ng\n"),
      s(:str, "    lambda { a = Proc.new { return }; a[]}.call\n"),
      s(:str, "    $x = :ok\n"),
      s(:str, "  end\n"),
      s(:str, "  def8\n"),
      s(:str, "  $x\n")),
    s(:str, "[ruby-core:17164]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "   def def9\n"),
      s(:str, "      lambda {|a| $x = :ok; a[]; $x = :ng }.call(Proc.new { return })\n"),
      s(:str, "      $x = :ng\n"),
      s(:str, "   end\n"),
      s(:str, "   def9\n"),
      s(:str, "   $x\n")),
    s(:str, "[ruby-core:17164]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "   def def10\n"),
      s(:str, "     $x = :ng\n"),
      s(:str, "     lambda { 1.times { return } }.call\n"),
      s(:str, "     $x = :ok\n"),
      s(:str, "   end\n"),
      s(:str, "   $x = :ok\n"),
      s(:str, "   def10\n"),
      s(:str, "   $x\n")),
    s(:str, "[ruby-core:17164]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "   def def11\n"),
      s(:str, "      yield\n"),
      s(:str, "   end\n"),
      s(:str, "   begin\n"),
      s(:str, "      lambda { def11 { return } }.call\n"),
      s(:str, "   rescue LocalJumpError\n"),
      s(:str, "      :ng\n"),
      s(:str, "   else\n"),
      s(:str, "      :ok\n"),
      s(:str, "   end\n")),
    s(:str, "[ruby-core:17164]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "   def def12\n"),
      s(:str, "      b = Proc.new { $x = :ng; lambda { return }.call; $x = :ok }.call\n"),
      s(:str, "   end\n"),
      s(:str, "   def12\n"),
      s(:str, "   $x\n")),
    s(:str, "[ruby-core:17164]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    pr = proc{\n"),
      s(:str, "      proc{\n"),
      s(:str, "        return :ok\n"),
      s(:str, "      }\n"),
      s(:str, "    }.call\n"),
      s(:str, "    pr.call\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n"),
      s(:str, "  m()\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class Foo\n"),
      s(:str, "    def call_it\n"),
      s(:str, "      p = Proc.new\n"),
      s(:str, "      p.call\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def give_it\n"),
      s(:str, "    proc { :ok }\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  f = Foo.new\n"),
      s(:str, "  a_proc = give_it\n"),
      s(:str, "  f.call_it(&give_it())\n")),
    s(:str, "[ruby-core:15711]")),
  s(:send, nil, :assert_equal,
    s(:str, "foo!"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  class FooProc < Proc\n"),
      s(:str, "    def initialize\n"),
      s(:str, "      @foo = \"foo!\"\n"),
      s(:str, "    end\n"),
      s(:str, "\n"),
      s(:str, "    def bar\n"),
      s(:str, "      @foo\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  def bar\n"),
      s(:str, "    FooProc.new &lambda{\n"),
      s(:str, "      p 1\n"),
      s(:str, "    }\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  fp = bar(&lambda{\n"),
      s(:str, "    p 2\n"),
      s(:str, "  })\n"),
      s(:str, "\n"),
      s(:str, "  fp.bar\n")),
    s(:str, "Subclass of Proc")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  o = Object.new\n"),
      s(:str, "  def o.write(s); end\n"),
      s(:str, "  $stderr = o\n"),
      s(:str, "  at_exit{\n"),
      s(:str, "    print $!.message\n"),
      s(:str, "  }\n"),
      s(:str, "  raise \"ok\"\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  lambda do\n"),
      s(:str, "    class A\n"),
      s(:str, "      class B\n"),
      s(:str, "        proc{return :ng}.call\n"),
      s(:str, "      end\n"),
      s(:str, "    end\n"),
      s(:str, "  end.call\n"),
      s(:str, "  :ok\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  $proc = proc{return}\n"),
      s(:str, "  begin\n"),
      s(:str, "    lambda do\n"),
      s(:str, "      class A\n"),
      s(:str, "        class B\n"),
      s(:str, "          $proc.call\n"),
      s(:str, "        end\n"),
      s(:str, "      end\n"),
      s(:str, "    end.call\n"),
      s(:str, "    :ng\n"),
      s(:str, "  rescue LocalJumpError\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def x\n"),
      s(:str, "    binding\n"),
      s(:str, "  end\n"),
      s(:str, "  b = x{|a| a }\n"),
      s(:str, "  b.eval('yield(\"ok\")')\n")),
    s(:str, "[Bug #5634]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def x\n"),
      s(:str, "    binding\n"),
      s(:str, "  end\n"),
      s(:str, "  eval(\"x { 'ok' }\").eval \"yield\"\n")),
    s(:str, "[Bug #5634]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def x\n"),
      s(:str, "    binding\n"),
      s(:str, "  end\n"),
      s(:str, "  def m\n"),
      s(:str, "    x{ 'ok' }\n"),
      s(:str, "  end\n"),
      s(:str, "  eval('yield', m)\n")),
    s(:str, "[Bug #5634]")))
