s(:begin,
  s(:send, nil, :assert_equal,
    s(:str, "0"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    GC.stress = true\n"),
      s(:str, "    pid = fork {}\n"),
      s(:str, "    Process.wait pid\n"),
      s(:str, "    $?.to_i\n"),
      s(:str, "  rescue NotImplementedError\n"),
      s(:str, "    0\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-dev:32404]")),
  s(:send, nil, :assert_finish,
    s(:int, 10),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    children = (1..10).map{\n"),
      s(:str, "      Thread.start{fork{}}.value\n"),
      s(:str, "    }\n"),
      s(:str, "    while !children.empty? and pid = Process.wait\n"),
      s(:str, "      children.delete(pid)\n"),
      s(:str, "    end\n"),
      s(:str, "  rescue NotImplementedError\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:22158]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "  main = Thread.current\n"),
      s(:str, "  Thread.new { sleep 0.01 until main.stop?; Thread.kill main }\n"),
      s(:str, "  Process.setrlimit(:NPROC, 1) if defined?(Process::RLIMIT_NPROC)\n"),
      s(:str, "  fork {}\n")),
    s(:str, "[ruby-dev:37934]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    r, w = IO.pipe\n"),
      s(:str, "    if pid1 = fork\n"),
      s(:str, "      w.close\n"),
      s(:str, "      r.read(1)\n"),
      s(:str, "      Process.kill(\"USR1\", pid1)\n"),
      s(:str, "      _, s = Process.wait2(pid1)\n"),
      s(:str, "      s.success? ? :ok : :ng\n"),
      s(:str, "    else\n"),
      s(:str, "      r.close\n"),
      s(:str, "      if pid2 = fork\n"),
      s(:str, "        trap(\"USR1\") { Time.now.to_s; Process.kill(\"USR2\", pid2) }\n"),
      s(:str, "        w.close\n"),
      s(:str, "        Process.wait2(pid2)\n"),
      s(:str, "      else\n"),
      s(:str, "        w.close\n"),
      s(:str, "        sleep 0.2\n"),
      s(:str, "      end\n"),
      s(:str, "      exit true\n"),
      s(:str, "    end\n"),
      s(:str, "  rescue NotImplementedError\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:28924]")),
  s(:send, nil, :assert_equal,
    s(:str, "[1, 2]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  a = []\n"),
      s(:str, "  main = Thread.current\n"),
      s(:str, "  trap(:INT) { a.push(1).size == 2 and main.wakeup }\n"),
      s(:str, "  trap(:TERM) { a.push(2).size == 2 and main.wakeup }\n"),
      s(:str, "  pid = $$\n"),
      s(:str, "  begin\n"),
      s(:str, "    pid = fork do\n"),
      s(:str, "      Process.kill(:INT, pid)\n"),
      s(:str, "      Process.kill(:TERM, pid)\n"),
      s(:str, "    end\n"),
      s(:str, "    Process.wait(pid)\n"),
      s(:str, "    100.times {break if a.size > 1; sleep 0.001}\n"),
      s(:str, "    a.sort\n"),
      s(:str, "  rescue NotImplementedError\n"),
      s(:str, "    [1, 2]\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-dev:44005] [Ruby 1.9 - Bug #4950]")))
