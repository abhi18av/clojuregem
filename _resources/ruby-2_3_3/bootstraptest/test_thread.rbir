s(:begin,
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Thread.new{\n"),
      s(:str, "  }.join\n"),
      s(:str, "  :ok\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Thread.new{\n"),
      s(:str, "    :ok\n"),
      s(:str, "  }.value\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "begin\n"),
      s(:str, "  v = 0\n"),
      s(:str, "  (1..200).map{|i|\n"),
      s(:str, "    Thread.new{\n"),
      s(:str, "      i\n"),
      s(:str, "    }\n"),
      s(:str, "  }.each{|t|\n"),
      s(:str, "    v += t.value\n"),
      s(:str, "  }\n"),
      s(:str, "  v == 20100 ? :ok : v\n"),
      s(:str, "rescue ThreadError => e\n"),
      s(:str, "  :ok if /can't create Thread/ =~ e.message\n"),
      s(:str, "end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "5000"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  5000.times{|e|\n"),
      s(:str, "    (1..2).map{\n"),
      s(:str, "      Thread.new{\n"),
      s(:str, "      }\n"),
      s(:str, "    }.each{|e|\n"),
      s(:str, "      e.join()\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "5000"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  5000.times{|e|\n"),
      s(:str, "    (1..2).map{\n"),
      s(:str, "      Thread.new{\n"),
      s(:str, "      }\n"),
      s(:str, "    }.each{|e|\n"),
      s(:str, "      e.join(1000000000)\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "begin\n"),
      s(:str, "  :ok if 5000 == 5000.times{\n"),
      s(:str, "    t = Thread.new{}\n"),
      s(:str, "    while t.alive?\n"),
      s(:str, "      Thread.pass\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"),
      s(:str, "rescue NoMemoryError\n"),
      s(:str, "  :ok\n"),
      s(:str, "end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "100"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  100.times{\n"),
      s(:str, "    Thread.new{loop{Thread.pass}}\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Thread.new{\n"),
      s(:str, "    :ok\n"),
      s(:str, "  }.join.value\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    Thread.new{\n"),
      s(:str, "      raise \"ok\"\n"),
      s(:str, "    }.join\n"),
      s(:str, "  rescue => e\n"),
      s(:str, "    e\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ans = nil\n"),
      s(:str, "  t = Thread.new{\n"),
      s(:str, "    begin\n"),
      s(:str, "      sleep 0.5\n"),
      s(:str, "    ensure\n"),
      s(:str, "      ans = :ok\n"),
      s(:str, "    end\n"),
      s(:str, "  }\n"),
      s(:str, "  Thread.pass until t.stop?\n"),
      s(:str, "  t.kill\n"),
      s(:str, "  t.join\n"),
      s(:str, "  ans\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  t = Thread.new{\n"),
      s(:str, "    sleep\n"),
      s(:str, "  }\n"),
      s(:str, "  sleep 0.1\n"),
      s(:str, "  t.raise\n"),
      s(:str, "  begin\n"),
      s(:str, "    t.join\n"),
      s(:str, "    :ng\n"),
      s(:str, "  rescue\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  t = Thread.new{\n"),
      s(:str, "    loop{}\n"),
      s(:str, "  }\n"),
      s(:str, "  Thread.pass\n"),
      s(:str, "  t.raise\n"),
      s(:str, "  begin\n"),
      s(:str, "    t.join\n"),
      s(:str, "    :ng\n"),
      s(:str, "  rescue\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  t = Thread.new{\n"),
      s(:str, "  }\n"),
      s(:str, "  Thread.pass\n"),
      s(:str, "  t.join\n"),
      s(:str, "  t.raise # raise to exited thread\n"),
      s(:str, "  begin\n"),
      s(:str, "    t.join\n"),
      s(:str, "    :ok\n"),
      s(:str, "  rescue\n"),
      s(:str, "    :ng\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "run"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  t = Thread.new{\n"),
      s(:str, "    loop{}\n"),
      s(:str, "  }\n"),
      s(:str, "  st = t.status\n"),
      s(:str, "  t.kill\n"),
      s(:str, "  st\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "sleep"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  t = Thread.new{\n"),
      s(:str, "    sleep\n"),
      s(:str, "  }\n"),
      s(:str, "  sleep 0.1\n"),
      s(:str, "  st = t.status\n"),
      s(:str, "  t.kill\n"),
      s(:str, "  st\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "false"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  t = Thread.new{\n"),
      s(:str, "  }\n"),
      s(:str, "  t.kill\n"),
      s(:str, "  sleep 0.1\n"),
      s(:str, "  t.status\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[ThreadGroup, true]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  ptg = Thread.current.group\n"),
      s(:str, "  Thread.new{\n"),
      s(:str, "    ctg = Thread.current.group\n"),
      s(:str, "    [ctg.class, ctg == ptg]\n"),
      s(:str, "  }.value\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[1, 1]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  thg = ThreadGroup.new\n"),
      s(:str, "\n"),
      s(:str, "  t = Thread.new{\n"),
      s(:str, "    thg.add Thread.current\n"),
      s(:str, "    sleep\n"),
      s(:str, "  }\n"),
      s(:str, "  sleep 0.1\n"),
      s(:str, "  [thg.list.size, ThreadGroup::Default.list.size]\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "true"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  thg = ThreadGroup.new\n"),
      s(:str, "\n"),
      s(:str, "  t = Thread.new{sleep 5}\n"),
      s(:str, "  thg.add t\n"),
      s(:str, "  thg.list.include?(t)\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "[true, nil, true]"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  /a/ =~ 'a'\n"),
      s(:str, "  $a = $~\n"),
      s(:str, "  Thread.new{\n"),
      s(:str, "    $b = $~\n"),
      s(:str, "    /b/ =~ 'b'\n"),
      s(:str, "    $c = $~\n"),
      s(:str, "  }.join\n"),
      s(:str, "  $d = $~\n"),
      s(:str, "  [$a == $d, $b, $c != $d]\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "11"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Thread.current[:a] = 1\n"),
      s(:str, "  Thread.new{\n"),
      s(:str, "    Thread.current[:a] = 10\n"),
      s(:str, "    Thread.pass\n"),
      s(:str, "    Thread.current[:a]\n"),
      s(:str, "  }.value + Thread.current[:a]\n"))),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    100.times do |i|\n"),
      s(:str, "      begin\n"),
      s(:str, "        th = Thread.start(Thread.current) {|u| u.raise }\n"),
      s(:str, "        raise\n"),
      s(:str, "      rescue\n"),
      s(:str, "      ensure\n"),
      s(:str, "        th.join\n"),
      s(:str, "      end\n"),
      s(:str, "    end\n"),
      s(:str, "  rescue\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-dev:31371]")),
  s(:send, nil, :assert_equal,
    s(:str, "true"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  t = Thread.new { loop {} }\n"),
      s(:str, "  begin\n"),
      s(:str, "    pid = fork {\n"),
      s(:str, "      exit t.status != \"run\"\n"),
      s(:str, "    }\n"),
      s(:str, "    Process.wait pid\n"),
      s(:str, "    $?.success?\n"),
      s(:str, "  rescue NotImplementedError\n"),
      s(:str, "    true\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  open(\"zzz.rb\", \"w\") do |f|\n"),
      s(:str, "    f.puts <<-END\n"),
      s(:str, "      begin\n"),
      s(:str, "        Thread.new { fork { GC.start } }.join\n"),
      s(:str, "        pid, status = Process.wait2\n"),
      s(:str, "        $result = status.success? ? :ok : :ng\n"),
      s(:str, "      rescue NotImplementedError\n"),
      s(:str, "        $result = :ok\n"),
      s(:str, "      end\n"),
      s(:str, "    END\n"),
      s(:str, "  end\n"),
      s(:str, "  require \"./zzz.rb\"\n"),
      s(:str, "  $result\n"))),
  s(:send, nil, :assert_finish,
    s(:int, 3),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  th = Thread.new {sleep 0.2}\n"),
      s(:str, "  th.join(0.1)\n"),
      s(:str, "  th.join\n"))),
  s(:send, nil, :assert_finish,
    s(:int, 3),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  require 'timeout'\n"),
      s(:str, "  th = Thread.new {sleep 0.2}\n"),
      s(:str, "  begin\n"),
      s(:str, "    Timeout.timeout(0.1) {th.join}\n"),
      s(:str, "  rescue Timeout::Error\n"),
      s(:str, "  end\n"),
      s(:str, "  th.join\n"))),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  STDERR.reopen(STDOUT)\n"),
      s(:str, "  exec \"/\"\n"))),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  (0..10).map {\n"),
      s(:str, "    Thread.new {\n"),
      s(:str, "     10000.times {\n"),
      s(:str, "        Object.new.to_s\n"),
      s(:str, "      }\n"),
      s(:str, "    }\n"),
      s(:str, "  }.each {|t|\n"),
      s(:str, "    t.join\n"),
      s(:str, "  }\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  def m\n"),
      s(:str, "    t = Thread.new { while true; // =~ \"\" end }\n"),
      s(:str, "    sleep 0.01\n"),
      s(:str, "    10.times {\n"),
      s(:str, "      if /((ab)*(ab)*)*(b)/ =~ \"ab\"*7\n"),
      s(:str, "        return :ng if !$4\n"),
      s(:str, "        return :ng if $~.size != 5\n"),
      s(:str, "      end\n"),
      s(:str, "    }\n"),
      s(:str, "    :ok\n"),
      s(:str, "  ensure\n"),
      s(:str, "    Thread.kill t\n"),
      s(:str, "  end\n"),
      s(:str, "  m\n")),
    s(:str, "[ruby-dev:34492]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  at_exit { Fiber.new{}.resume }\n"))),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  g = enum_for(:local_variables)\n"),
      s(:str, "  loop { g.next }\n")),
    s(:str, "[ruby-dev:34128]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  g = enum_for(:block_given?)\n"),
      s(:str, "  loop { g.next }\n")),
    s(:str, "[ruby-dev:34128]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  g = enum_for(:binding)\n"),
      s(:str, "  loop { g.next }\n")),
    s(:str, "[ruby-dev:34128]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  g = \"abc\".enum_for(:scan, /./)\n"),
      s(:str, "  loop { g.next }\n")),
    s(:str, "[ruby-dev:34128]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  g = Module.enum_for(:new)\n"),
      s(:str, "  loop { g.next }\n")),
    s(:str, "[ruby-dev:34128]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Fiber.new(&Object.method(:class_eval)).resume(\"foo\")\n")),
    s(:str, "[ruby-dev:34128]")),
  s(:send, nil, :assert_normal_exit,
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  Thread.new(\"foo\", &Object.method(:class_eval)).join\n")),
    s(:str, "[ruby-dev:34128]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    Thread.new { Thread.stop }\n"),
      s(:str, "    Thread.stop\n"),
      s(:str, "    :ng\n"),
      s(:str, "  rescue Exception\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    m1, m2 = Mutex.new, Mutex.new\n"),
      s(:str, "    f1 = f2 = false\n"),
      s(:str, "    Thread.new { m1.lock; f2 = true; sleep 0.001 until f1; m2.lock }\n"),
      s(:str, "    m2.lock; f1 = true; sleep 0.001 until f2; m1.lock\n"),
      s(:str, "    :ng\n"),
      s(:str, "  rescue Exception\n"),
      s(:str, "    :ok\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  m = Mutex.new\n"),
      s(:str, "  Thread.new { m.lock }; sleep 0.1; m.lock\n"),
      s(:str, "  :ok\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  m = Mutex.new\n"),
      s(:str, "  Thread.new { m.lock }; m.lock\n"),
      s(:str, "  :ok\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  m = Mutex.new\n"),
      s(:str, "  Thread.new { m.lock }.join; m.lock\n"),
      s(:str, "  :ok\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  m = Mutex.new\n"),
      s(:str, "  Thread.new { m.lock; sleep 0.2 }\n"),
      s(:str, "  sleep 0.1; m.lock\n"),
      s(:str, "  :ok\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  m = Mutex.new\n"),
      s(:str, "  Thread.new { m.lock; sleep 0.2; m.unlock }\n"),
      s(:str, "  sleep 0.1; m.lock\n"),
      s(:str, "  :ok\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  t = Thread.new {`echo`}\n"),
      s(:str, "  t.join\n"),
      s(:str, "  $? ? :ng : :ok\n")),
    s(:str, "[ruby-dev:35414]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    100.times{\n"),
      s(:str, "      (1..100).map{ Thread.new(true) {|x| x == false } }.each{|th| th.join}\n"),
      s(:str, "    }\n"),
      s(:str, "  rescue NoMemoryError, StandardError\n"),
      s(:str, "  end\n"),
      s(:str, "  :ok\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  open(\"zzz.rb\", \"w\") do |f|\n"),
      s(:str, "    f.puts <<-'end;' # do\n"),
      s(:str, "      begin\n"),
      s(:str, "        m = Mutex.new\n"),
      s(:str, "        parent = Thread.current\n"),
      s(:str, "        th1 = Thread.new { m.lock; sleep }\n"),
      s(:str, "        sleep 0.01 until th1.stop?\n"),
      s(:str, "        Thread.new do\n"),
      s(:str, "          sleep 0.01 until parent.stop?\n"),
      s(:str, "          begin\n"),
      s(:str, "            fork { GC.start }\n"),
      s(:str, "          rescue Exception\n"),
      s(:str, "            parent.raise $!\n"),
      s(:str, "          end\n"),
      s(:str, "          th1.run\n"),
      s(:str, "        end\n"),
      s(:str, "        m.lock\n"),
      s(:str, "        pid, status = Process.wait2\n"),
      s(:str, "        $result = status.success? ? :ok : :ng\n"),
      s(:str, "      rescue NotImplementedError\n"),
      s(:str, "        $result = :ok\n"),
      s(:str, "      end\n"),
      s(:str, "    end;\n"),
      s(:str, "  end\n"),
      s(:str, "  require \"./zzz.rb\"\n"),
      s(:str, "  $result\n"))),
  s(:send, nil, :assert_finish,
    s(:int, 3),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  require 'thread'\n"),
      s(:str, "\n"),
      s(:str, "  lock = Mutex.new\n"),
      s(:str, "  cond = ConditionVariable.new\n"),
      s(:str, "  t = Thread.new do\n"),
      s(:str, "    lock.synchronize do\n"),
      s(:str, "      cond.wait(lock)\n"),
      s(:str, "    end\n"),
      s(:str, "  end\n"),
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    pid = fork do\n"),
      s(:str, "      # Child\n"),
      s(:str, "      STDOUT.write \"This is the child process.\\n\"\n"),
      s(:str, "      STDOUT.write \"Child process exiting.\\n\"\n"),
      s(:str, "    end\n"),
      s(:str, "    Process.waitpid(pid)\n"),
      s(:str, "  rescue NotImplementedError\n"),
      s(:str, "  end\n")),
    s(:str, "[ruby-core:23572]")),
  s(:send, nil, :assert_equal,
    s(:str, "ok"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  begin\n"),
      s(:str, "    Process.waitpid2(fork {})[1].success? ? 'ok' : 'ng'\n"),
      s(:str, "  rescue NotImplementedError\n"),
      s(:str, "    'ok'\n"),
      s(:str, "  end\n"))),
  s(:send, nil, :assert_equal,
    s(:str, "foo"),
    s(:dstr,
      s(:str, "\n"),
      s(:str, "  i = 0\n"),
      s(:str, "  Thread.start {sleep 1; exit!}\n"),
      s(:str, "  f = proc {|s, c| /\#{c.call; s}/o }\n"),
      s(:str, "  th2 = Thread.new {\n"),
      s(:str, "    sleep 0.01 until i == 1\n"),
      s(:str, "    i = 2\n"),
      s(:str, "    f.call(\"bar\", proc {sleep 2});\n"),
      s(:str, "    nil\n"),
      s(:str, "  }\n"),
      s(:str, "  th1 = Thread.new {\n"),
      s(:str, "    f.call(\"foo\", proc {i = 1; sleep 0.01 until i == 2; sleep 0.01})\n"),
      s(:str, "    nil\n"),
      s(:str, "  }\n"),
      s(:str, "  [th1, th2].each {|t| t.join }\n"),
      s(:str, "  GC.start\n"),
      s(:str, "  f.call.source\n"))))
