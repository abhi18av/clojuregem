s(:class,
  s(:const,
    s(:const, nil, :RDoc), :CrossReference), nil,
  s(:begin,
    s(:casgn, nil, :CLASS_REGEXP_STR,
      s(:str, "\\\\?((?:\\:{2})?[A-Z]\\w*(?:\\:\\:\\w+)*)")),
    s(:casgn, nil, :METHOD_REGEXP_STR,
      s(:str, "([a-z]\\w*[!?=]?|%|===|\\[\\]=?|<<|>>)(?:\\([\\w.+*/=<>-]*\\))?")),
    s(:casgn, nil, :CROSSREF_REGEXP,
      s(:regexp,
        s(:str, "(?:^|\\s)\n"),
        s(:str, "                     (\n"),
        s(:str, "                      (?:\n"),
        s(:str, "                       # A::B::C.meth\n"),
        s(:str, "                       "),
        s(:begin,
          s(:const, nil, :CLASS_REGEXP_STR)),
        s(:str, "(?:[.#]|::)"),
        s(:begin,
          s(:const, nil, :METHOD_REGEXP_STR)),
        s(:str, "\n"),
        s(:str, "\n"),
        s(:str, "                       # Stand-alone method (preceded by a #)\n"),
        s(:str, "                       | \\\\?\\#"),
        s(:begin,
          s(:const, nil, :METHOD_REGEXP_STR)),
        s(:str, "\n"),
        s(:str, "\n"),
        s(:str, "                       # Stand-alone method (preceded by ::)\n"),
        s(:str, "                       | ::"),
        s(:begin,
          s(:const, nil, :METHOD_REGEXP_STR)),
        s(:str, "\n"),
        s(:str, "\n"),
        s(:str, "                       # A::B::C\n"),
        s(:str, "                       # The stuff after CLASS_REGEXP_STR is a\n"),
        s(:str, "                       # nasty hack.  CLASS_REGEXP_STR unfortunately matches\n"),
        s(:str, "                       # words like dog and cat (these are legal \"class\"\n"),
        s(:str, "                       # names in Fortran 95).  When a word is flagged as a\n"),
        s(:str, "                       # potential cross-reference, limitations in the markup\n"),
        s(:str, "                       # engine suppress other processing, such as typesetting.\n"),
        s(:str, "                       # This is particularly noticeable for contractions.\n"),
        s(:str, "                       # In order that words like \"can't\" not\n"),
        s(:str, "                       # be flagged as potential cross-references, only\n"),
        s(:str, "                       # flag potential class cross-references if the character\n"),
        s(:str, "                       # after the cross-reference is a space, sentence\n"),
        s(:str, "                       # punctuation, tag start character, or attribute\n"),
        s(:str, "                       # marker.\n"),
        s(:str, "                       | "),
        s(:begin,
          s(:const, nil, :CLASS_REGEXP_STR)),
        s(:str, "(?=[@\\s).?!,;<\\000]|\\z)\n"),
        s(:str, "\n"),
        s(:str, "                       # Things that look like filenames\n"),
        s(:str, "                       # The key thing is that there must be at least\n"),
        s(:str, "                       # one special character (period, slash, or\n"),
        s(:str, "                       # underscore).\n"),
        s(:str, "                       | (?:\\.\\./)*[-/\\w]+[_/.][-\\w/.]+\n"),
        s(:str, "\n"),
        s(:str, "                       # Things that have markup suppressed\n"),
        s(:str, "                       # Don't process things like '\\<' in \\<tt>, though.\n"),
        s(:str, "                       # TODO: including < is a hack, not very satisfying.\n"),
        s(:str, "                       | \\\\[^\\s<]\n"),
        s(:str, "                      )\n"),
        s(:str, "\n"),
        s(:str, "                      # labels for headings\n"),
        s(:str, "                      (?:@[\\w+%-]+(?:\\.[\\w|%-]+)?)?\n"),
        s(:str, "                     )"),
        s(:regopt, :x))),
    s(:casgn, nil, :ALL_CROSSREF_REGEXP,
      s(:regexp,
        s(:str, "\n"),
        s(:str, "                     (?:^|\\s)\n"),
        s(:str, "                     (\n"),
        s(:str, "                      (?:\n"),
        s(:str, "                       # A::B::C.meth\n"),
        s(:str, "                       "),
        s(:begin,
          s(:const, nil, :CLASS_REGEXP_STR)),
        s(:str, "(?:[.#]|::)"),
        s(:begin,
          s(:const, nil, :METHOD_REGEXP_STR)),
        s(:str, "\n"),
        s(:str, "\n"),
        s(:str, "                       # Stand-alone method\n"),
        s(:str, "                       | \\\\?"),
        s(:begin,
          s(:const, nil, :METHOD_REGEXP_STR)),
        s(:str, "\n"),
        s(:str, "\n"),
        s(:str, "                       # A::B::C\n"),
        s(:str, "                       | "),
        s(:begin,
          s(:const, nil, :CLASS_REGEXP_STR)),
        s(:str, "(?=[@\\s).?!,;<\\000]|\\z)\n"),
        s(:str, "\n"),
        s(:str, "                       # Things that look like filenames\n"),
        s(:str, "                       | (?:\\.\\./)*[-/\\w]+[_/.][-\\w/.]+\n"),
        s(:str, "\n"),
        s(:str, "                       # Things that have markup suppressed\n"),
        s(:str, "                       | \\\\[^\\s<]\n"),
        s(:str, "                      )\n"),
        s(:str, "\n"),
        s(:str, "                      # labels for headings\n"),
        s(:str, "                      (?:@[\\w+%-]+)?\n"),
        s(:str, "                     )"),
        s(:regopt, :x))),
    s(:send, nil, :attr_accessor,
      s(:sym, :seen)),
    s(:def, :initialize,
      s(:args,
        s(:arg, :context)),
      s(:begin,
        s(:ivasgn, :@context,
          s(:lvar, :context)),
        s(:ivasgn, :@store,
          s(:send,
            s(:lvar, :context), :store)),
        s(:ivasgn, :@seen,
          s(:hash)))),
    s(:def, :resolve,
      s(:args,
        s(:arg, :name),
        s(:arg, :text)),
      s(:begin,
        s(:if,
          s(:send,
            s(:ivar, :@seen), :include?,
            s(:lvar, :name)),
          s(:return,
            s(:send,
              s(:ivar, :@seen), :[],
              s(:lvar, :name))), nil),
        s(:if,
          s(:send,
            s(:regexp,
              s(:begin,
                s(:const, nil, :CLASS_REGEXP_STR)),
              s(:str, "([.#]|::)"),
              s(:begin,
                s(:const, nil, :METHOD_REGEXP_STR)),
              s(:regopt, :o)), :=~,
            s(:lvar, :name)),
          s(:begin,
            s(:lvasgn, :type,
              s(:nth_ref, 2)),
            s(:if,
              s(:send,
                s(:lvar, :type), :==,
                s(:str, ".")),
              s(:lvasgn, :type,
                s(:str, "")), nil),
            s(:lvasgn, :method,
              s(:dstr,
                s(:begin,
                  s(:lvar, :type)),
                s(:begin,
                  s(:nth_ref, 3)))),
            s(:lvasgn, :container,
              s(:send,
                s(:ivar, :@context), :find_symbol_module,
                s(:nth_ref, 1)))),
          s(:if,
            s(:send,
              s(:regexp,
                s(:str, "^([.#]|::)"),
                s(:begin,
                  s(:const, nil, :METHOD_REGEXP_STR)),
                s(:regopt, :o)), :=~,
              s(:lvar, :name)),
            s(:begin,
              s(:lvasgn, :type,
                s(:nth_ref, 1)),
              s(:if,
                s(:send,
                  s(:lvar, :type), :==,
                  s(:str, ".")),
                s(:lvasgn, :type,
                  s(:str, "")), nil),
              s(:lvasgn, :method,
                s(:dstr,
                  s(:begin,
                    s(:lvar, :type)),
                  s(:begin,
                    s(:nth_ref, 2)))),
              s(:lvasgn, :container,
                s(:ivar, :@context))),
            s(:lvasgn, :container,
              s(:nil)))),
        s(:if,
          s(:lvar, :container),
          s(:begin,
            s(:lvasgn, :ref,
              s(:send,
                s(:lvar, :container), :find_local_symbol,
                s(:lvar, :method))),
            s(:if,
              s(:or,
                s(:lvar, :ref),
                s(:send,
                  s(:const,
                    s(:const, nil, :RDoc), :TopLevel), :===,
                  s(:lvar, :container))), nil,
              s(:lvasgn, :ref,
                s(:send,
                  s(:lvar, :container), :find_ancestor_local_symbol,
                  s(:lvar, :method))))), nil),
        s(:if,
          s(:lvar, :ref), nil,
          s(:lvasgn, :ref,
            s(:case,
              s(:lvar, :name),
              s(:when,
                s(:regexp,
                  s(:str, "^\\\\("),
                  s(:begin,
                    s(:const, nil, :CLASS_REGEXP_STR)),
                  s(:str, ")$"),
                  s(:regopt, :o)),
                s(:send,
                  s(:ivar, :@context), :find_symbol,
                  s(:nth_ref, 1))),
              s(:send,
                s(:ivar, :@context), :find_symbol,
                s(:lvar, :name))))),
        s(:if,
          s(:and,
            s(:send,
              s(:lvar, :ref), :!),
            s(:send,
              s(:lvar, :name), :=~,
              s(:regexp,
                s(:str, "^\\w+$"),
                s(:regopt)))),
          s(:lvasgn, :ref,
            s(:send,
              s(:ivar, :@store), :page,
              s(:lvar, :name))), nil),
        s(:if,
          s(:send,
            s(:const,
              s(:const, nil, :RDoc), :Alias), :===,
            s(:lvar, :ref)),
          s(:lvasgn, :ref,
            s(:nil)), nil),
        s(:lvasgn, :out,
          s(:if,
            s(:send,
              s(:lvar, :name), :==,
              s(:str, "\\")),
            s(:lvar, :name),
            s(:if,
              s(:send,
                s(:lvar, :name), :=~,
                s(:regexp,
                  s(:str, "^\\\\"),
                  s(:regopt))),
              s(:if,
                s(:lvar, :ref),
                s(:back_ref, :$'),
                s(:lvar, :name)),
              s(:if,
                s(:lvar, :ref),
                s(:if,
                  s(:send,
                    s(:lvar, :ref), :display?),
                  s(:lvar, :ref),
                  s(:lvar, :text)),
                s(:lvar, :text))))),
        s(:send,
          s(:ivar, :@seen), :[]=,
          s(:lvar, :name),
          s(:lvar, :out)),
        s(:lvar, :out)))))
