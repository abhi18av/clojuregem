s(:begin,
  s(:class,
    s(:const,
      s(:const, nil, :RDoc), :Parser), nil,
    s(:begin,
      s(:ivasgn, :@parsers,
        s(:array)),
      s(:sclass,
        s(:self),
        s(:send, nil, :attr_reader,
          s(:sym, :parsers))),
      s(:send, nil, :attr_reader,
        s(:sym, :file_name)),
      s(:defs,
        s(:self), :alias_extension,
        s(:args,
          s(:arg, :old_ext),
          s(:arg, :new_ext)),
        s(:begin,
          s(:lvasgn, :old_ext,
            s(:send,
              s(:lvar, :old_ext), :sub,
              s(:regexp,
                s(:str, "^\\.(.*)"),
                s(:regopt)),
              s(:str, "\\1"))),
          s(:lvasgn, :new_ext,
            s(:send,
              s(:lvar, :new_ext), :sub,
              s(:regexp,
                s(:str, "^\\.(.*)"),
                s(:regopt)),
              s(:str, "\\1"))),
          s(:lvasgn, :parser,
            s(:send, nil, :can_parse_by_name,
              s(:dstr,
                s(:str, "xxx."),
                s(:begin,
                  s(:lvar, :old_ext))))),
          s(:if,
            s(:lvar, :parser), nil,
            s(:return,
              s(:false))),
          s(:send,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Parser), :parsers), :unshift,
            s(:array,
              s(:regexp,
                s(:str, "\\."),
                s(:begin,
                  s(:lvar, :new_ext)),
                s(:str, "$"),
                s(:regopt)),
              s(:lvar, :parser))),
          s(:true))),
      s(:defs,
        s(:self), :binary?,
        s(:args,
          s(:arg, :file)),
        s(:begin,
          s(:if,
            s(:send,
              s(:lvar, :file), :=~,
              s(:regexp,
                s(:str, "\\.(rdoc|txt)$"),
                s(:regopt))),
            s(:return,
              s(:false)), nil),
          s(:or,
            s(:lvasgn, :s,
              s(:send,
                s(:const, nil, :File), :read,
                s(:lvar, :file),
                s(:int, 1024))),
            s(:return,
              s(:false))),
          s(:lvasgn, :have_encoding,
            s(:send,
              s(:lvar, :s), :respond_to?,
              s(:sym, :encoding))),
          s(:if,
            s(:or,
              s(:send,
                s(:send,
                  s(:lvar, :s), :[],
                  s(:int, 0),
                  s(:int, 2)), :==,
                s(:send,
                  s(:send,
                    s(:const, nil, :Marshal), :dump,
                    s(:str, "")), :[],
                  s(:int, 0),
                  s(:int, 2))),
              s(:send,
                s(:lvar, :s), :index,
                s(:str, "\u0000"))),
            s(:return,
              s(:true)), nil),
          s(:if,
            s(:lvar, :have_encoding),
            s(:begin,
              s(:lvasgn, :mode,
                s(:str, "r")),
              s(:send,
                s(:lvar, :s), :sub!,
                s(:regexp,
                  s(:str, "\\A#!.*\\n"),
                  s(:regopt)),
                s(:str, "")),
              s(:lvasgn, :encoding,
                s(:send,
                  s(:lvar, :s), :[],
                  s(:regexp,
                    s(:str, "^\\s*\\#\\s*(?:-\\*-\\s*)?(?:en)?coding:\\s*([^\\s;]+?)(?:-\\*-|[\\s;])"),
                    s(:regopt)),
                  s(:int, 1))),
              s(:if,
                s(:lvar, :encoding),
                s(:lvasgn, :mode,
                  s(:dstr,
                    s(:str, "rb:"),
                    s(:begin,
                      s(:lvar, :encoding)))), nil),
              s(:lvasgn, :s,
                s(:block,
                  s(:send,
                    s(:const, nil, :File), :open,
                    s(:lvar, :file),
                    s(:lvar, :mode)),
                  s(:args,
                    s(:arg, :f)),
                  s(:send,
                    s(:lvar, :f), :gets,
                    s(:nil),
                    s(:int, 1024)))),
              s(:send,
                s(:send,
                  s(:lvar, :s), :valid_encoding?), :!)),
            s(:if,
              s(:send,
                s(:int, 0), :respond_to?,
                s(:sym, :fdiv)),
              s(:send,
                s(:send,
                  s(:send,
                    s(:lvar, :s), :count,
                    s(:str, "\u0000-\u007F"),
                    s(:str, "^ -~\t\r\n")), :fdiv,
                  s(:send,
                    s(:lvar, :s), :size)), :>,
                s(:float, 0.3)),
              s(:send,
                s(:begin,
                  s(:send,
                    s(:send,
                      s(:send,
                        s(:lvar, :s), :count,
                        s(:str, "\u0000-\u007F"),
                        s(:str, "^ -~\t\r\n")), :to_f), :/,
                    s(:send,
                      s(:lvar, :s), :size))), :>,
                s(:float, 0.3)))))),
      s(:defs,
        s(:self), :process_directive,
        s(:args,
          s(:arg, :code_object),
          s(:arg, :directive),
          s(:arg, :value)),
        s(:begin,
          s(:if,
            s(:gvar, :$-w),
            s(:send, nil, :warn,
              s(:str, "RDoc::Parser::process_directive is deprecated and wil be removed in RDoc 4.  Use RDoc::Markup::PreProcess#handle_directive instead")), nil),
          s(:case,
            s(:lvar, :directive),
            s(:when,
              s(:str, "nodoc"),
              s(:begin,
                s(:send,
                  s(:lvar, :code_object), :document_self=,
                  s(:nil)),
                s(:send,
                  s(:lvar, :code_object), :document_children=,
                  s(:send,
                    s(:send,
                      s(:lvar, :value), :downcase), :!=,
                    s(:str, "all"))))),
            s(:when,
              s(:str, "doc"),
              s(:begin,
                s(:send,
                  s(:lvar, :code_object), :document_self=,
                  s(:true)),
                s(:send,
                  s(:lvar, :code_object), :force_documentation=,
                  s(:true)))),
            s(:when,
              s(:str, "yield"),
              s(:str, "yields"),
              s(:begin,
                s(:if,
                  s(:send,
                    s(:lvar, :code_object), :params),
                  s(:send,
                    s(:send,
                      s(:lvar, :code_object), :params), :sub!,
                    s(:regexp,
                      s(:str, ",?\\s*&\\w+"),
                      s(:regopt)),
                    s(:str, "")), nil),
                s(:send,
                  s(:lvar, :code_object), :block_params=,
                  s(:lvar, :value)))),
            s(:when,
              s(:str, "arg"),
              s(:str, "args"),
              s(:send,
                s(:lvar, :code_object), :params=,
                s(:lvar, :value))), nil))),
      s(:defs,
        s(:self), :zip?,
        s(:args,
          s(:arg, :file)),
        s(:rescue,
          s(:begin,
            s(:lvasgn, :zip_signature,
              s(:send,
                s(:const, nil, :File), :read,
                s(:lvar, :file),
                s(:int, 4))),
            s(:or,
              s(:or,
                s(:send,
                  s(:lvar, :zip_signature), :==,
                  s(:str, "PK\u0003\u0004")),
                s(:send,
                  s(:lvar, :zip_signature), :==,
                  s(:str, "PK\u0005\u0006"))),
              s(:send,
                s(:lvar, :zip_signature), :==,
                s(:str, "PK\a\b")))),
          s(:resbody, nil, nil,
            s(:false)), nil)),
      s(:defs,
        s(:self), :can_parse,
        s(:args,
          s(:arg, :file_name)),
        s(:begin,
          s(:lvasgn, :parser,
            s(:send, nil, :can_parse_by_name,
              s(:lvar, :file_name))),
          s(:if,
            s(:and,
              s(:send,
                s(:lvar, :parser), :==,
                s(:const,
                  s(:const,
                    s(:const, nil, :RDoc), :Parser), :Simple)),
              s(:send, nil, :zip?,
                s(:lvar, :file_name))),
            s(:return), nil),
          s(:lvar, :parser))),
      s(:defs,
        s(:self), :can_parse_by_name,
        s(:args,
          s(:arg, :file_name)),
        s(:rescue,
          s(:begin,
            s(:masgn,
              s(:mlhs,
                s(:lvasgn, :_),
                s(:lvasgn, :parser)),
              s(:block,
                s(:send,
                  s(:send,
                    s(:const,
                      s(:const, nil, :RDoc), :Parser), :parsers), :find),
                s(:args,
                  s(:arg, :regexp)),
                s(:send,
                  s(:lvar, :regexp), :=~,
                  s(:lvar, :file_name)))),
            s(:lvasgn, :ext_name,
              s(:send,
                s(:const, nil, :File), :extname,
                s(:lvar, :file_name))),
            s(:if,
              s(:send,
                s(:lvar, :ext_name), :empty?),
              s(:return,
                s(:lvar, :parser)), nil),
            s(:if,
              s(:and,
                s(:send,
                  s(:lvar, :parser), :==,
                  s(:const,
                    s(:const,
                      s(:const, nil, :RDoc), :Parser), :Simple)),
                s(:send,
                  s(:lvar, :ext_name), :!~,
                  s(:regexp,
                    s(:str, "txt|rdoc"),
                    s(:regopt)))),
              s(:case,
                s(:send, nil, :check_modeline,
                  s(:lvar, :file_name)),
                s(:when,
                  s(:nil),
                  s(:str, "rdoc"), nil),
                s(:return,
                  s(:nil))), nil),
            s(:lvar, :parser)),
          s(:resbody,
            s(:array,
              s(:const,
                s(:const, nil, :Errno), :EACCES)), nil, nil), nil)),
      s(:defs,
        s(:self), :check_modeline,
        s(:args,
          s(:arg, :file_name)),
        s(:rescue,
          s(:begin,
            s(:lvasgn, :line,
              s(:block,
                s(:send, nil, :open,
                  s(:lvar, :file_name)),
                s(:args,
                  s(:arg, :io)),
                s(:send,
                  s(:lvar, :io), :gets))),
            s(:match_with_lvasgn,
              s(:regexp,
                s(:str, "-\\*-\\s*(.*?\\S)\\s*-\\*-"),
                s(:regopt)),
              s(:lvar, :line)),
            s(:if,
              s(:lvasgn, :type,
                s(:nth_ref, 1)), nil,
              s(:return,
                s(:nil))),
            s(:if,
              s(:match_with_lvasgn,
                s(:regexp,
                  s(:str, ";"),
                  s(:regopt)),
                s(:lvar, :type)),
              s(:begin,
                s(:if,
                  s(:match_with_lvasgn,
                    s(:regexp,
                      s(:str, "(?:\\s|\\A)mode:\\s*([^\\s;]+)"),
                      s(:regopt, :i)),
                    s(:lvar, :type)), nil,
                  s(:return,
                    s(:nil))),
                s(:lvasgn, :type,
                  s(:nth_ref, 1))), nil),
            s(:if,
              s(:match_with_lvasgn,
                s(:regexp,
                  s(:str, "coding:"),
                  s(:regopt, :i)),
                s(:lvar, :type)),
              s(:return,
                s(:nil)), nil),
            s(:send,
              s(:lvar, :type), :downcase)),
          s(:resbody,
            s(:array,
              s(:const, nil, :ArgumentError)), nil, nil), nil)),
      s(:defs,
        s(:self), :for,
        s(:args,
          s(:arg, :top_level),
          s(:arg, :file_name),
          s(:arg, :content),
          s(:arg, :options),
          s(:arg, :stats)),
        s(:rescue,
          s(:begin,
            s(:if,
              s(:send, nil, :binary?,
                s(:lvar, :file_name)),
              s(:return), nil),
            s(:lvasgn, :parser,
              s(:send, nil, :use_markup,
                s(:lvar, :content))),
            s(:if,
              s(:lvar, :parser), nil,
              s(:begin,
                s(:lvasgn, :parse_name,
                  s(:lvar, :file_name)),
                s(:if,
                  s(:and,
                    s(:send,
                      s(:lvar, :file_name), :!~,
                      s(:regexp,
                        s(:str, "\\.\\w+$"),
                        s(:regopt))),
                    s(:send,
                      s(:lvar, :content), :=~,
                      s(:regexp,
                        s(:str, "\\A#!(.+)"),
                        s(:regopt)))),
                  s(:begin,
                    s(:lvasgn, :shebang,
                      s(:nth_ref, 1)),
                    s(:case,
                      s(:lvar, :shebang),
                      s(:when,
                        s(:regexp,
                          s(:str, "env\\s+ruby"),
                          s(:regopt)),
                        s(:regexp,
                          s(:str, "/ruby"),
                          s(:regopt)),
                        s(:lvasgn, :parse_name,
                          s(:str, "dummy.rb"))), nil)), nil),
                s(:lvasgn, :parser,
                  s(:send, nil, :can_parse,
                    s(:lvar, :parse_name))))),
            s(:if,
              s(:lvar, :parser), nil,
              s(:return)),
            s(:lvasgn, :content,
              s(:send, nil, :remove_modeline,
                s(:lvar, :content))),
            s(:send,
              s(:lvar, :parser), :new,
              s(:lvar, :top_level),
              s(:lvar, :file_name),
              s(:lvar, :content),
              s(:lvar, :options),
              s(:lvar, :stats))),
          s(:resbody,
            s(:array,
              s(:const, nil, :SystemCallError)), nil,
            s(:nil)), nil)),
      s(:defs,
        s(:self), :parse_files_matching,
        s(:args,
          s(:arg, :regexp)),
        s(:send,
          s(:send,
            s(:const,
              s(:const, nil, :RDoc), :Parser), :parsers), :unshift,
          s(:array,
            s(:lvar, :regexp),
            s(:self)))),
      s(:defs,
        s(:self), :remove_modeline,
        s(:args,
          s(:arg, :content)),
        s(:send,
          s(:lvar, :content), :sub,
          s(:regexp,
            s(:str, "\\A.*-\\*-\\s*(.*?\\S)\\s*-\\*-.*\\r?\\n"),
            s(:regopt)),
          s(:str, ""))),
      s(:defs,
        s(:self), :use_markup,
        s(:args,
          s(:arg, :content)),
        s(:begin,
          s(:lvasgn, :markup,
            s(:send,
              s(:block,
                s(:send,
                  s(:send,
                    s(:send,
                      s(:lvar, :content), :lines), :first,
                    s(:int, 3)), :grep,
                  s(:regexp,
                    s(:str, "markup:\\s+(\\w+)"),
                    s(:regopt))),
                s(:args),
                s(:nth_ref, 1)), :first)),
          s(:if,
            s(:lvar, :markup), nil,
            s(:return)),
          s(:if,
            s(:send,
              s(:array,
                s(:str, "tomdoc"),
                s(:str, "markdown")), :include?,
              s(:lvar, :markup)),
            s(:return,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Parser), :Ruby)), nil),
          s(:lvasgn, :markup,
            s(:send,
              s(:const, nil, :Regexp), :escape,
              s(:lvar, :markup))),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :_),
              s(:lvasgn, :selected)),
            s(:block,
              s(:send,
                s(:send,
                  s(:const,
                    s(:const, nil, :RDoc), :Parser), :parsers), :find),
              s(:args,
                s(:arg, :_),
                s(:arg, :parser)),
              s(:send,
                s(:regexp,
                  s(:str, "^"),
                  s(:begin,
                    s(:lvar, :markup)),
                  s(:str, "$"),
                  s(:regopt, :i)), :=~,
                s(:send,
                  s(:send,
                    s(:lvar, :parser), :name), :sub,
                  s(:regexp,
                    s(:str, ".*:"),
                    s(:regopt)),
                  s(:str, ""))))),
          s(:lvar, :selected))),
      s(:def, :initialize,
        s(:args,
          s(:arg, :top_level),
          s(:arg, :file_name),
          s(:arg, :content),
          s(:arg, :options),
          s(:arg, :stats)),
        s(:begin,
          s(:ivasgn, :@top_level,
            s(:lvar, :top_level)),
          s(:send,
            s(:ivar, :@top_level), :parser=,
            s(:send,
              s(:self), :class)),
          s(:ivasgn, :@store,
            s(:send,
              s(:ivar, :@top_level), :store)),
          s(:ivasgn, :@file_name,
            s(:lvar, :file_name)),
          s(:ivasgn, :@content,
            s(:lvar, :content)),
          s(:ivasgn, :@options,
            s(:lvar, :options)),
          s(:ivasgn, :@stats,
            s(:lvar, :stats)),
          s(:ivasgn, :@preprocess,
            s(:send,
              s(:const,
                s(:const,
                  s(:const, nil, :RDoc), :Markup), :PreProcess), :new,
              s(:ivar, :@file_name),
              s(:send,
                s(:ivar, :@options), :rdoc_include))),
          s(:send,
            s(:ivar, :@preprocess), :options=,
            s(:ivar, :@options)))),
      s(:send, nil, :autoload,
        s(:sym, :RubyTools),
        s(:str, "rdoc/parser/ruby_tools")),
      s(:send, nil, :autoload,
        s(:sym, :Text),
        s(:str, "rdoc/parser/text")))),
  s(:send, nil, :require,
    s(:str, "rdoc/parser/simple")),
  s(:send, nil, :require,
    s(:str, "rdoc/parser/c")),
  s(:send, nil, :require,
    s(:str, "rdoc/parser/changelog")),
  s(:send, nil, :require,
    s(:str, "rdoc/parser/markdown")),
  s(:send, nil, :require,
    s(:str, "rdoc/parser/rd")),
  s(:send, nil, :require,
    s(:str, "rdoc/parser/ruby")))
