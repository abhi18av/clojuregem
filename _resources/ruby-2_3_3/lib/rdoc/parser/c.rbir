s(:begin,
  s(:send, nil, :require,
    s(:str, "tsort")),
  s(:class,
    s(:const,
      s(:const,
        s(:const, nil, :RDoc), :Parser), :C),
    s(:const,
      s(:const, nil, :RDoc), :Parser),
    s(:begin,
      s(:send, nil, :parse_files_matching,
        s(:regexp,
          s(:str, "\\.(?:([CcHh])\\1?|c([+xp])\\2|y)\\z"),
          s(:regopt))),
      s(:send, nil, :include,
        s(:const,
          s(:const, nil, :RDoc), :Text)),
      s(:send, nil, :attr_reader,
        s(:sym, :classes)),
      s(:send, nil, :attr_accessor,
        s(:sym, :content)),
      s(:send, nil, :attr_reader,
        s(:sym, :enclosure_dependencies)),
      s(:send, nil, :attr_reader,
        s(:sym, :known_classes)),
      s(:send, nil, :attr_reader,
        s(:sym, :missing_dependencies)),
      s(:send, nil, :attr_reader,
        s(:sym, :singleton_classes)),
      s(:send, nil, :attr_reader,
        s(:sym, :top_level)),
      s(:def, :initialize,
        s(:args,
          s(:arg, :top_level),
          s(:arg, :file_name),
          s(:arg, :content),
          s(:arg, :options),
          s(:arg, :stats)),
        s(:begin,
          s(:zsuper),
          s(:ivasgn, :@known_classes,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :KNOWN_CLASSES), :dup)),
          s(:ivasgn, :@content,
            s(:send, nil, :handle_tab_width,
              s(:send, nil, :handle_ifdefs_in,
                s(:ivar, :@content)))),
          s(:ivasgn, :@file_dir,
            s(:send,
              s(:const, nil, :File), :dirname,
              s(:ivar, :@file_name))),
          s(:ivasgn, :@classes,
            s(:send, nil, :load_variable_map,
              s(:sym, :c_class_variables))),
          s(:ivasgn, :@singleton_classes,
            s(:send, nil, :load_variable_map,
              s(:sym, :c_singleton_class_variables))),
          s(:ivasgn, :@methods,
            s(:block,
              s(:send,
                s(:const, nil, :Hash), :new),
              s(:args,
                s(:arg, :h),
                s(:arg, :f)),
              s(:send,
                s(:lvar, :h), :[]=,
                s(:lvar, :f),
                s(:block,
                  s(:send,
                    s(:const, nil, :Hash), :new),
                  s(:args,
                    s(:arg, :i),
                    s(:arg, :m)),
                  s(:send,
                    s(:lvar, :i), :[]=,
                    s(:lvar, :m),
                    s(:array)))))),
          s(:ivasgn, :@missing_dependencies,
            s(:hash)),
          s(:ivasgn, :@enclosure_dependencies,
            s(:block,
              s(:send,
                s(:const, nil, :Hash), :new),
              s(:args,
                s(:arg, :h),
                s(:arg, :k)),
              s(:send,
                s(:lvar, :h), :[]=,
                s(:lvar, :k),
                s(:array)))),
          s(:send,
            s(:ivar, :@enclosure_dependencies), :instance_variable_set,
            s(:sym, :@missing_dependencies),
            s(:ivar, :@missing_dependencies)),
          s(:send,
            s(:ivar, :@enclosure_dependencies), :extend,
            s(:const, nil, :TSort)),
          s(:defs,
            s(:ivar, :@enclosure_dependencies), :tsort_each_node,
            s(:args,
              s(:blockarg, :block)),
            s(:rescue,
              s(:send, nil, :each_key,
                s(:block_pass,
                  s(:lvar, :block))),
              s(:resbody,
                s(:array,
                  s(:const,
                    s(:const, nil, :TSort), :Cyclic)),
                s(:lvasgn, :e),
                s(:begin,
                  s(:lvasgn, :cycle_vars,
                    s(:send,
                      s(:send,
                        s(:send,
                          s(:lvar, :e), :message), :scan,
                        s(:regexp,
                          s(:str, "\"(.*?)\""),
                          s(:regopt))), :flatten)),
                  s(:lvasgn, :cycle,
                    s(:send,
                      s(:block,
                        s(:send,
                          s(:send,
                            s(:lvar, :cycle_vars), :sort), :map),
                        s(:args,
                          s(:arg, :var_name)),
                        s(:begin,
                          s(:send, nil, :delete,
                            s(:lvar, :var_name)),
                          s(:masgn,
                            s(:mlhs,
                              s(:lvasgn, :var_name),
                              s(:lvasgn, :type),
                              s(:lvasgn, :mod_name)),
                            s(:send,
                              s(:ivar, :@missing_dependencies), :[],
                              s(:lvar, :var_name))),
                          s(:dstr,
                            s(:begin,
                              s(:lvar, :type)),
                            s(:str, " "),
                            s(:begin,
                              s(:lvar, :mod_name)),
                            s(:str, " ("),
                            s(:begin,
                              s(:lvar, :var_name)),
                            s(:str, ")")))), :join,
                      s(:str, ", "))),
                  s(:send, nil, :warn,
                    s(:dstr,
                      s(:str, "Unable to create "),
                      s(:begin,
                        s(:lvar, :cycle)),
                      s(:str, " due to a cyclic class or module creation"))),
                  s(:retry))), nil)),
          s(:defs,
            s(:ivar, :@enclosure_dependencies), :tsort_each_child,
            s(:args,
              s(:arg, :node),
              s(:blockarg, :block)),
            s(:send,
              s(:send, nil, :fetch,
                s(:lvar, :node),
                s(:array)), :each,
              s(:block_pass,
                s(:lvar, :block)))))),
      s(:def, :deduplicate_call_seq,
        s(:args),
        s(:block,
          s(:send,
            s(:ivar, :@methods), :each),
          s(:args,
            s(:arg, :var_name),
            s(:arg, :functions)),
          s(:begin,
            s(:lvasgn, :class_name,
              s(:send,
                s(:ivar, :@known_classes), :[],
                s(:lvar, :var_name))),
            s(:lvasgn, :class_obj,
              s(:send, nil, :find_class,
                s(:lvar, :var_name),
                s(:lvar, :class_name))),
            s(:block,
              s(:send,
                s(:lvar, :functions), :each_value),
              s(:args,
                s(:arg, :method_names)),
              s(:begin,
                s(:if,
                  s(:send,
                    s(:send,
                      s(:lvar, :method_names), :length), :==,
                    s(:int, 1)),
                  s(:next), nil),
                s(:block,
                  s(:send,
                    s(:lvar, :method_names), :each),
                  s(:args,
                    s(:arg, :method_name)),
                  s(:send, nil, :deduplicate_method_name,
                    s(:lvar, :class_obj),
                    s(:lvar, :method_name)))))))),
      s(:def, :deduplicate_method_name,
        s(:args,
          s(:arg, :class_obj),
          s(:arg, :method_name)),
        s(:begin,
          s(:if,
            s(:lvasgn, :method,
              s(:block,
                s(:send,
                  s(:send,
                    s(:lvar, :class_obj), :method_list), :find),
                s(:args,
                  s(:arg, :m)),
                s(:send,
                  s(:send,
                    s(:lvar, :m), :name), :==,
                  s(:lvar, :method_name)))), nil,
            s(:return)),
          s(:if,
            s(:lvasgn, :call_seq,
              s(:send,
                s(:lvar, :method), :call_seq)), nil,
            s(:return)),
          s(:if,
            s(:send,
              s(:lvar, :method_name), :=~,
              s(:regexp,
                s(:str, "\\A\\["),
                s(:regopt))),
            s(:lvasgn, :method_name,
              s(:send,
                s(:lvar, :method_name), :[],
                s(:int, 0),
                s(:int, 1))), nil),
          s(:lvasgn, :entries,
            s(:send,
              s(:lvar, :call_seq), :split,
              s(:str, "\n"))),
          s(:lvasgn, :matching,
            s(:block,
              s(:send,
                s(:lvar, :entries), :select),
              s(:args,
                s(:arg, :entry)),
              s(:or,
                s(:send,
                  s(:lvar, :entry), :=~,
                  s(:regexp,
                    s(:str, "^\\w*\\.?"),
                    s(:begin,
                      s(:send,
                        s(:const, nil, :Regexp), :escape,
                        s(:lvar, :method_name))),
                    s(:regopt))),
                s(:send,
                  s(:lvar, :entry), :=~,
                  s(:regexp,
                    s(:str, "\\s"),
                    s(:begin,
                      s(:send,
                        s(:const, nil, :Regexp), :escape,
                        s(:lvar, :method_name))),
                    s(:str, "\\s"),
                    s(:regopt)))))),
          s(:send,
            s(:lvar, :method), :call_seq=,
            s(:send,
              s(:lvar, :matching), :join,
              s(:str, "\n"))))),
      s(:def, :do_aliases,
        s(:args),
        s(:block,
          s(:send,
            s(:ivar, :@content), :scan,
            s(:regexp,
              s(:str, "rb_define_alias\\s*\\(\n"),
              s(:str, "                   \\s*(\\w+),\n"),
              s(:str, "                   \\s*\"(.+?)\",\n"),
              s(:str, "                   \\s*\"(.+?)\"\n"),
              s(:str, "                   \\s*\\)"),
              s(:regopt, :m, :x))),
          s(:args,
            s(:arg, :var_name),
            s(:arg, :new_name),
            s(:arg, :old_name)),
          s(:begin,
            s(:lvasgn, :class_name,
              s(:send,
                s(:ivar, :@known_classes), :[],
                s(:lvar, :var_name))),
            s(:if,
              s(:lvar, :class_name), nil,
              s(:begin,
                s(:send,
                  s(:ivar, :@options), :warn,
                  s(:send,
                    s(:str, "Enclosing class or module %p for alias %s %s is not known"), :%,
                    s(:array,
                      s(:lvar, :var_name),
                      s(:lvar, :new_name),
                      s(:lvar, :old_name)))),
                s(:next))),
            s(:lvasgn, :class_obj,
              s(:send, nil, :find_class,
                s(:lvar, :var_name),
                s(:lvar, :class_name))),
            s(:lvasgn, :al,
              s(:send,
                s(:const,
                  s(:const, nil, :RDoc), :Alias), :new,
                s(:str, ""),
                s(:lvar, :old_name),
                s(:lvar, :new_name),
                s(:str, ""))),
            s(:send,
              s(:lvar, :al), :singleton=,
              s(:send,
                s(:ivar, :@singleton_classes), :key?,
                s(:lvar, :var_name))),
            s(:lvasgn, :comment,
              s(:send, nil, :find_alias_comment,
                s(:lvar, :var_name),
                s(:lvar, :new_name),
                s(:lvar, :old_name))),
            s(:send,
              s(:lvar, :comment), :normalize),
            s(:send,
              s(:lvar, :al), :comment=,
              s(:lvar, :comment)),
            s(:send,
              s(:lvar, :al), :record_location,
              s(:ivar, :@top_level)),
            s(:send,
              s(:lvar, :class_obj), :add_alias,
              s(:lvar, :al)),
            s(:send,
              s(:ivar, :@stats), :add_alias,
              s(:lvar, :al))))),
      s(:def, :do_attrs,
        s(:args),
        s(:begin,
          s(:block,
            s(:send,
              s(:ivar, :@content), :scan,
              s(:regexp,
                s(:str, "rb_attr\\s*\\(\n"),
                s(:str, "                   \\s*(\\w+),\n"),
                s(:str, "                   \\s*([\\w\"()]+),\n"),
                s(:str, "                   \\s*([01]),\n"),
                s(:str, "                   \\s*([01]),\n"),
                s(:str, "                   \\s*\\w+\\);"),
                s(:regopt, :m, :x))),
            s(:args,
              s(:arg, :var_name),
              s(:arg, :attr_name),
              s(:arg, :read),
              s(:arg, :write)),
            s(:send, nil, :handle_attr,
              s(:lvar, :var_name),
              s(:lvar, :attr_name),
              s(:lvar, :read),
              s(:lvar, :write))),
          s(:block,
            s(:send,
              s(:ivar, :@content), :scan,
              s(:regexp,
                s(:str, "rb_define_attr\\(\n"),
                s(:str, "                             \\s*([\\w\\.]+),\n"),
                s(:str, "                             \\s*\"([^\"]+)\",\n"),
                s(:str, "                             \\s*(\\d+),\n"),
                s(:str, "                             \\s*(\\d+)\\s*\\);\n"),
                s(:str, "                "),
                s(:regopt, :m, :x))),
            s(:args,
              s(:arg, :var_name),
              s(:arg, :attr_name),
              s(:arg, :read),
              s(:arg, :write)),
            s(:send, nil, :handle_attr,
              s(:lvar, :var_name),
              s(:lvar, :attr_name),
              s(:lvar, :read),
              s(:lvar, :write))))),
      s(:def, :do_boot_defclass,
        s(:args),
        s(:block,
          s(:send,
            s(:ivar, :@content), :scan,
            s(:regexp,
              s(:str, "(\\w+)\\s*=\\s*boot_defclass\\s*\\(\\s*\"(\\w+?)\",\\s*(\\w+?)\\s*\\)"),
              s(:regopt))),
          s(:args,
            s(:arg, :var_name),
            s(:arg, :class_name),
            s(:arg, :parent)),
          s(:begin,
            s(:if,
              s(:send,
                s(:lvar, :parent), :==,
                s(:str, "0")),
              s(:lvasgn, :parent,
                s(:nil)), nil),
            s(:send, nil, :handle_class_module,
              s(:lvar, :var_name),
              s(:sym, :class),
              s(:lvar, :class_name),
              s(:lvar, :parent),
              s(:nil))))),
      s(:def, :do_classes,
        s(:args),
        s(:begin,
          s(:send, nil, :do_boot_defclass),
          s(:send, nil, :do_define_class),
          s(:send, nil, :do_define_class_under),
          s(:send, nil, :do_singleton_class),
          s(:send, nil, :do_struct_define_without_accessor))),
      s(:def, :do_constants,
        s(:args),
        s(:begin,
          s(:block,
            s(:send,
              s(:ivar, :@content), :scan,
              s(:regexp,
                s(:str, "\\Wrb_define_\n"),
                s(:str, "                   ( variable          |\n"),
                s(:str, "                     readonly_variable |\n"),
                s(:str, "                     const             |\n"),
                s(:str, "                     global_const        )\n"),
                s(:str, "               \\s*\\(\n"),
                s(:str, "                 (?:\\s*(\\w+),)?\n"),
                s(:str, "                 \\s*\"(\\w+)\",\n"),
                s(:str, "                 \\s*(.*?)\\s*\\)\\s*;\n"),
                s(:str, "                 "),
                s(:regopt, :m, :x))),
            s(:args,
              s(:arg, :type),
              s(:arg, :var_name),
              s(:arg, :const_name),
              s(:arg, :definition)),
            s(:begin,
              s(:if,
                s(:or,
                  s(:send,
                    s(:lvar, :var_name), :!),
                  s(:send,
                    s(:lvar, :var_name), :==,
                    s(:str, "rb_mKernel"))),
                s(:lvasgn, :var_name,
                  s(:str, "rb_cObject")), nil),
              s(:send, nil, :handle_constants,
                s(:lvar, :type),
                s(:lvar, :var_name),
                s(:lvar, :const_name),
                s(:lvar, :definition)))),
          s(:block,
            s(:send,
              s(:ivar, :@content), :scan,
              s(:regexp,
                s(:str, "\n"),
                s(:str, "                  \\Wrb_curses_define_const\n"),
                s(:str, "                  \\s*\\(\n"),
                s(:str, "                    \\s*\n"),
                s(:str, "                    (\\w+)\n"),
                s(:str, "                    \\s*\n"),
                s(:str, "                  \\)\n"),
                s(:str, "                  \\s*;"),
                s(:regopt, :m, :x))),
            s(:args,
              s(:arg, :consts)),
            s(:begin,
              s(:lvasgn, :const,
                s(:send,
                  s(:lvar, :consts), :first)),
              s(:send, nil, :handle_constants,
                s(:str, "const"),
                s(:str, "mCurses"),
                s(:lvar, :const),
                s(:dstr,
                  s(:str, "UINT2NUM("),
                  s(:begin,
                    s(:lvar, :const)),
                  s(:str, ")"))))),
          s(:block,
            s(:send,
              s(:ivar, :@content), :scan,
              s(:regexp,
                s(:str, "\n"),
                s(:str, "                  \\Wrb_file_const\n"),
                s(:str, "                  \\s*\\(\n"),
                s(:str, "                    \\s*\n"),
                s(:str, "                    \"([^\"]+)\",\n"),
                s(:str, "                    \\s*\n"),
                s(:str, "                    (.*?)\n"),
                s(:str, "                    \\s*\n"),
                s(:str, "                  \\)\n"),
                s(:str, "                  \\s*;"),
                s(:regopt, :m, :x))),
            s(:args,
              s(:arg, :name),
              s(:arg, :value)),
            s(:send, nil, :handle_constants,
              s(:str, "const"),
              s(:str, "rb_mFConst"),
              s(:lvar, :name),
              s(:lvar, :value))))),
      s(:def, :do_define_class,
        s(:args),
        s(:block,
          s(:send,
            s(:ivar, :@content), :scan,
            s(:regexp,
              s(:str, "([\\w\\.]+)\\s* = \\s*rb_define_class\\s*\n"),
              s(:str, "              \\(\n"),
              s(:str, "                 \\s*\"(\\w+)\",\n"),
              s(:str, "                 \\s*(\\w+)\\s*\n"),
              s(:str, "              \\)"),
              s(:regopt, :m, :x))),
          s(:args,
            s(:arg, :var_name),
            s(:arg, :class_name),
            s(:arg, :parent)),
          s(:send, nil, :handle_class_module,
            s(:lvar, :var_name),
            s(:sym, :class),
            s(:lvar, :class_name),
            s(:lvar, :parent),
            s(:nil)))),
      s(:def, :do_define_class_under,
        s(:args),
        s(:block,
          s(:send,
            s(:ivar, :@content), :scan,
            s(:regexp,
              s(:str, "([\\w\\.]+)\\s* =                  # var_name\n"),
              s(:str, "                   \\s*rb_define_class_under\\s*\n"),
              s(:str, "                   \\(\n"),
              s(:str, "                     \\s* (\\w+),                    # under\n"),
              s(:str, "                     \\s* \"(\\w+)\",                  # class_name\n"),
              s(:str, "                     \\s*\n"),
              s(:str, "                     (?:\n"),
              s(:str, "                       ([\\w\\*\\s\\(\\)\\.\\->]+) |      # parent_name\n"),
              s(:str, "                       rb_path2class\\(\"([\\w:]+)\"\\) # path\n"),
              s(:str, "                     )\n"),
              s(:str, "                     \\s*\n"),
              s(:str, "                   \\)\n"),
              s(:str, "                  "),
              s(:regopt, :m, :x))),
          s(:args,
            s(:arg, :var_name),
            s(:arg, :under),
            s(:arg, :class_name),
            s(:arg, :parent_name),
            s(:arg, :path)),
          s(:begin,
            s(:lvasgn, :parent,
              s(:or,
                s(:lvar, :path),
                s(:lvar, :parent_name))),
            s(:send, nil, :handle_class_module,
              s(:lvar, :var_name),
              s(:sym, :class),
              s(:lvar, :class_name),
              s(:lvar, :parent),
              s(:lvar, :under))))),
      s(:def, :do_define_module,
        s(:args),
        s(:block,
          s(:send,
            s(:ivar, :@content), :scan,
            s(:regexp,
              s(:str, "(\\w+)\\s* = \\s*rb_define_module\\s*\\(\\s*\"(\\w+)\"\\s*\\)"),
              s(:regopt, :m, :x))),
          s(:args,
            s(:arg, :var_name),
            s(:arg, :class_name)),
          s(:send, nil, :handle_class_module,
            s(:lvar, :var_name),
            s(:sym, :module),
            s(:lvar, :class_name),
            s(:nil),
            s(:nil)))),
      s(:def, :do_define_module_under,
        s(:args),
        s(:block,
          s(:send,
            s(:ivar, :@content), :scan,
            s(:regexp,
              s(:str, "(\\w+)\\s* = \\s*rb_define_module_under\\s*\n"),
              s(:str, "              \\(\n"),
              s(:str, "                 \\s*(\\w+),\n"),
              s(:str, "                 \\s*\"(\\w+)\"\n"),
              s(:str, "              \\s*\\)"),
              s(:regopt, :m, :x))),
          s(:args,
            s(:arg, :var_name),
            s(:arg, :in_module),
            s(:arg, :class_name)),
          s(:send, nil, :handle_class_module,
            s(:lvar, :var_name),
            s(:sym, :module),
            s(:lvar, :class_name),
            s(:nil),
            s(:lvar, :in_module)))),
      s(:def, :do_includes,
        s(:args),
        s(:block,
          s(:send,
            s(:ivar, :@content), :scan,
            s(:regexp,
              s(:str, "rb_include_module\\s*\\(\\s*(\\w+?),\\s*(\\w+?)\\s*\\)"),
              s(:regopt))),
          s(:args,
            s(:arg, :c),
            s(:arg, :m)),
          s(:begin,
            s(:if,
              s(:lvasgn, :cls,
                s(:send,
                  s(:ivar, :@classes), :[],
                  s(:lvar, :c))), nil,
              s(:next)),
            s(:lvasgn, :m,
              s(:or,
                s(:send,
                  s(:ivar, :@known_classes), :[],
                  s(:lvar, :m)),
                s(:lvar, :m))),
            s(:lvasgn, :comment,
              s(:send,
                s(:const,
                  s(:const, nil, :RDoc), :Comment), :new,
                s(:str, ""),
                s(:ivar, :@top_level))),
            s(:lvasgn, :incl,
              s(:send,
                s(:lvar, :cls), :add_include,
                s(:send,
                  s(:const,
                    s(:const, nil, :RDoc), :Include), :new,
                  s(:lvar, :m),
                  s(:lvar, :comment)))),
            s(:send,
              s(:lvar, :incl), :record_location,
              s(:ivar, :@top_level))))),
      s(:def, :do_methods,
        s(:args),
        s(:begin,
          s(:block,
            s(:send,
              s(:ivar, :@content), :scan,
              s(:regexp,
                s(:str, "rb_define_\n"),
                s(:str, "                   (\n"),
                s(:str, "                      singleton_method |\n"),
                s(:str, "                      method           |\n"),
                s(:str, "                      module_function  |\n"),
                s(:str, "                      private_method\n"),
                s(:str, "                   )\n"),
                s(:str, "                   \\s*\\(\\s*([\\w\\.]+),\n"),
                s(:str, "                     \\s*\"([^\"]+)\",\n"),
                s(:str, "                     \\s*(?:RUBY_METHOD_FUNC\\(|VALUEFUNC\\(|\\(METHOD\\))?(\\w+)\\)?,\n"),
                s(:str, "                     \\s*(-?\\w+)\\s*\\)\n"),
                s(:str, "                   (?:;\\s*/[*/]\\s+in\\s+(\\w+?\\.(?:cpp|c|y)))?\n"),
                s(:str, "                 "),
                s(:regopt, :m, :x))),
            s(:args,
              s(:arg, :type),
              s(:arg, :var_name),
              s(:arg, :meth_name),
              s(:arg, :function),
              s(:arg, :param_count),
              s(:arg, :source_file)),
            s(:begin,
              s(:if,
                s(:send,
                  s(:lvar, :var_name), :==,
                  s(:str, "ruby_top_self")),
                s(:next), nil),
              s(:if,
                s(:send,
                  s(:lvar, :var_name), :==,
                  s(:str, "nstr")),
                s(:next), nil),
              s(:if,
                s(:send,
                  s(:lvar, :var_name), :==,
                  s(:str, "rb_mKernel")),
                s(:lvasgn, :var_name,
                  s(:str, "rb_cObject")), nil),
              s(:send, nil, :handle_method,
                s(:lvar, :type),
                s(:lvar, :var_name),
                s(:lvar, :meth_name),
                s(:lvar, :function),
                s(:lvar, :param_count),
                s(:lvar, :source_file)))),
          s(:block,
            s(:send,
              s(:ivar, :@content), :scan,
              s(:regexp,
                s(:str, "rb_define_global_function\\s*\\(\n"),
                s(:str, "                             \\s*\"([^\"]+)\",\n"),
                s(:str, "                             \\s*(?:RUBY_METHOD_FUNC\\(|VALUEFUNC\\()?(\\w+)\\)?,\n"),
                s(:str, "                             \\s*(-?\\w+)\\s*\\)\n"),
                s(:str, "                (?:;\\s*/[*/]\\s+in\\s+(\\w+?\\.[cy]))?\n"),
                s(:str, "                "),
                s(:regopt, :m, :x))),
            s(:args,
              s(:arg, :meth_name),
              s(:arg, :function),
              s(:arg, :param_count),
              s(:arg, :source_file)),
            s(:send, nil, :handle_method,
              s(:str, "method"),
              s(:str, "rb_mKernel"),
              s(:lvar, :meth_name),
              s(:lvar, :function),
              s(:lvar, :param_count),
              s(:lvar, :source_file))),
          s(:block,
            s(:send,
              s(:ivar, :@content), :scan,
              s(:regexp,
                s(:str, "define_filetest_function\\s*\\(\n"),
                s(:str, "                     \\s*\"([^\"]+)\",\n"),
                s(:str, "                     \\s*(?:RUBY_METHOD_FUNC\\(|VALUEFUNC\\()?(\\w+)\\)?,\n"),
                s(:str, "                     \\s*(-?\\w+)\\s*\\)"),
                s(:regopt, :m, :x))),
            s(:args,
              s(:arg, :meth_name),
              s(:arg, :function),
              s(:arg, :param_count)),
            s(:begin,
              s(:send, nil, :handle_method,
                s(:str, "method"),
                s(:str, "rb_mFileTest"),
                s(:lvar, :meth_name),
                s(:lvar, :function),
                s(:lvar, :param_count)),
              s(:send, nil, :handle_method,
                s(:str, "singleton_method"),
                s(:str, "rb_cFile"),
                s(:lvar, :meth_name),
                s(:lvar, :function),
                s(:lvar, :param_count)))))),
      s(:def, :do_missing,
        s(:args),
        s(:begin,
          s(:if,
            s(:send,
              s(:ivar, :@missing_dependencies), :empty?),
            s(:return), nil),
          s(:block,
            s(:send,
              s(:send,
                s(:ivar, :@enclosure_dependencies), :tsort), :each),
            s(:args,
              s(:arg, :in_module)),
            s(:begin,
              s(:lvasgn, :arguments,
                s(:send,
                  s(:ivar, :@missing_dependencies), :delete,
                  s(:lvar, :in_module))),
              s(:if,
                s(:lvar, :arguments), nil,
                s(:next)),
              s(:send, nil, :handle_class_module,
                s(:splat,
                  s(:lvar, :arguments))))))),
      s(:def, :do_modules,
        s(:args),
        s(:begin,
          s(:send, nil, :do_define_module),
          s(:send, nil, :do_define_module_under))),
      s(:def, :do_singleton_class,
        s(:args),
        s(:block,
          s(:send,
            s(:ivar, :@content), :scan,
            s(:regexp,
              s(:str, "([\\w\\.]+)\\s* = \\s*rb_singleton_class\\s*\n"),
              s(:str, "                  \\(\n"),
              s(:str, "                    \\s*(\\w+)\n"),
              s(:str, "                  \\s*\\)"),
              s(:regopt, :m, :x))),
          s(:args,
            s(:arg, :sclass_var),
            s(:arg, :class_var)),
          s(:send, nil, :handle_singleton,
            s(:lvar, :sclass_var),
            s(:lvar, :class_var)))),
      s(:def, :do_struct_define_without_accessor,
        s(:args),
        s(:block,
          s(:send,
            s(:ivar, :@content), :scan,
            s(:regexp,
              s(:str, "([\\w\\.]+)\\s* = \\s*rb_struct_define_without_accessor\\s*\n"),
              s(:str, "              \\(\n"),
              s(:str, "                 \\s*\"(\\w+)\",  # Class name\n"),
              s(:str, "                 \\s*(\\w+),    # Parent class\n"),
              s(:str, "                 \\s*\\w+,      # Allocation function\n"),
              s(:str, "                 (\\s*\"\\w+\",)* # Attributes\n"),
              s(:str, "                 \\s*NULL\n"),
              s(:str, "              \\)"),
              s(:regopt, :m, :x))),
          s(:args,
            s(:arg, :var_name),
            s(:arg, :class_name),
            s(:arg, :parent)),
          s(:send, nil, :handle_class_module,
            s(:lvar, :var_name),
            s(:sym, :class),
            s(:lvar, :class_name),
            s(:lvar, :parent),
            s(:nil)))),
      s(:def, :find_alias_comment,
        s(:args,
          s(:arg, :class_name),
          s(:arg, :new_name),
          s(:arg, :old_name)),
        s(:begin,
          s(:send,
            s(:send, nil, :content), :=~,
            s(:regexp,
              s(:str, "((?>/\\*.*?\\*/\\s+))\n"),
              s(:str, "                  rb_define_alias\\(\\s*"),
              s(:begin,
                s(:send,
                  s(:const, nil, :Regexp), :escape,
                  s(:lvar, :class_name))),
              s(:str, "\\s*,\n"),
              s(:str, "                                   \\s*\""),
              s(:begin,
                s(:send,
                  s(:const, nil, :Regexp), :escape,
                  s(:lvar, :new_name))),
              s(:str, "\"\\s*,\n"),
              s(:str, "                                   \\s*\""),
              s(:begin,
                s(:send,
                  s(:const, nil, :Regexp), :escape,
                  s(:lvar, :old_name))),
              s(:str, "\"\\s*\\);"),
              s(:regopt, :m, :x))),
          s(:send,
            s(:const,
              s(:const, nil, :RDoc), :Comment), :new,
            s(:or,
              s(:nth_ref, 1),
              s(:str, "")),
            s(:ivar, :@top_level)))),
      s(:def, :find_attr_comment,
        s(:args,
          s(:arg, :var_name),
          s(:arg, :attr_name),
          s(:optarg, :read,
            s(:nil)),
          s(:optarg, :write,
            s(:nil))),
        s(:begin,
          s(:lvasgn, :attr_name,
            s(:send,
              s(:const, nil, :Regexp), :escape,
              s(:lvar, :attr_name))),
          s(:lvasgn, :rw,
            s(:if,
              s(:and,
                s(:lvar, :read),
                s(:lvar, :write)),
              s(:regexp,
                s(:str, "\\s*"),
                s(:begin,
                  s(:lvar, :read)),
                s(:str, "\\s*,\\s*"),
                s(:begin,
                  s(:lvar, :write)),
                s(:str, "\\s*"),
                s(:regopt, :m, :x)),
              s(:regexp,
                s(:str, ".*?"),
                s(:regopt, :m)))),
          s(:lvasgn, :comment,
            s(:if,
              s(:send,
                s(:ivar, :@content), :=~,
                s(:regexp,
                  s(:str, "((?>/\\*.*?\\*/\\s+))\n"),
                  s(:str, "                                rb_define_attr\\((?:\\s*"),
                  s(:begin,
                    s(:lvar, :var_name)),
                  s(:str, ",)?\\s*\n"),
                  s(:str, "                                                \""),
                  s(:begin,
                    s(:lvar, :attr_name)),
                  s(:str, "\"\\s*,\n"),
                  s(:str, "                                                "),
                  s(:begin,
                    s(:lvar, :rw)),
                  s(:str, "\\)\\s*;"),
                  s(:regopt, :m, :x))),
              s(:nth_ref, 1),
              s(:if,
                s(:send,
                  s(:ivar, :@content), :=~,
                  s(:regexp,
                    s(:str, "((?>/\\*.*?\\*/\\s+))\n"),
                    s(:str, "                                   rb_attr\\(\\s*"),
                    s(:begin,
                      s(:lvar, :var_name)),
                    s(:str, "\\s*,\n"),
                    s(:str, "                                            \\s*"),
                    s(:begin,
                      s(:lvar, :attr_name)),
                    s(:str, "\\s*,\n"),
                    s(:str, "                                            "),
                    s(:begin,
                      s(:lvar, :rw)),
                    s(:str, ",.*?\\)\\s*;"),
                    s(:regopt, :m, :x))),
                s(:nth_ref, 1),
                s(:if,
                  s(:send,
                    s(:ivar, :@content), :=~,
                    s(:regexp,
                      s(:str, "(/\\*.*?(?:\\s*\\*\\s*)?)\n"),
                      s(:str, "                                   Document-attr:\\s"),
                      s(:begin,
                        s(:lvar, :attr_name)),
                      s(:str, "\\s*?\\n\n"),
                      s(:str, "                                   ((?>(.|\\n)*?\\*/))"),
                      s(:regopt, :x))),
                  s(:dstr,
                    s(:begin,
                      s(:nth_ref, 1)),
                    s(:str, "\n"),
                    s(:begin,
                      s(:nth_ref, 2))),
                  s(:str, ""))))),
          s(:send,
            s(:const,
              s(:const, nil, :RDoc), :Comment), :new,
            s(:lvar, :comment),
            s(:ivar, :@top_level)))),
      s(:def, :find_body,
        s(:args,
          s(:arg, :class_name),
          s(:arg, :meth_name),
          s(:arg, :meth_obj),
          s(:arg, :file_content),
          s(:optarg, :quiet,
            s(:false))),
        s(:case,
          s(:lvar, :file_content),
          s(:when,
            s(:regexp,
              s(:str, "((?>/\\*.*?\\*/\\s*)?)\n"),
              s(:str, "            ((?:(?:\\w+)\\s+)?\n"),
              s(:str, "             (?:intern\\s+)?VALUE\\s+"),
              s(:begin,
                s(:lvar, :meth_name)),
              s(:str, "\n"),
              s(:str, "             \\s*(\\([^)]*\\))([^;]|$))"),
              s(:regopt, :m, :x)),
            s(:begin,
              s(:lvasgn, :comment,
                s(:send,
                  s(:const,
                    s(:const, nil, :RDoc), :Comment), :new,
                  s(:nth_ref, 1),
                  s(:ivar, :@top_level))),
              s(:lvasgn, :body,
                s(:nth_ref, 2)),
              s(:masgn,
                s(:mlhs,
                  s(:lvasgn, :offset)),
                s(:send,
                  s(:gvar, :$~), :offset,
                  s(:int, 2))),
              s(:if,
                s(:lvar, :comment),
                s(:send,
                  s(:lvar, :comment), :remove_private), nil),
              s(:if,
                s(:send,
                  s(:regexp,
                    s(:begin,
                      s(:send,
                        s(:const, nil, :Regexp), :escape,
                        s(:lvar, :body))),
                    s(:str, "[^(]*?\\{.*?^\\}"),
                    s(:regopt, :m)), :=~,
                  s(:lvar, :file_content)),
                s(:lvasgn, :body,
                  s(:back_ref, :$&)), nil),
              s(:lvasgn, :override_comment,
                s(:send, nil, :find_override_comment,
                  s(:lvar, :class_name),
                  s(:lvar, :meth_obj))),
              s(:if,
                s(:lvar, :override_comment),
                s(:lvasgn, :comment,
                  s(:lvar, :override_comment)), nil),
              s(:send,
                s(:lvar, :comment), :normalize),
              s(:if,
                s(:lvar, :comment),
                s(:send, nil, :find_modifiers,
                  s(:lvar, :comment),
                  s(:lvar, :meth_obj)), nil),
              s(:send,
                s(:lvar, :meth_obj), :start_collecting_tokens),
              s(:lvasgn, :tk,
                s(:send,
                  s(:const,
                    s(:const,
                      s(:const, nil, :RDoc), :RubyToken), :Token), :new,
                  s(:nil),
                  s(:int, 1),
                  s(:int, 1))),
              s(:send,
                s(:lvar, :tk), :set_text,
                s(:lvar, :body)),
              s(:send,
                s(:lvar, :meth_obj), :add_token,
                s(:lvar, :tk)),
              s(:send,
                s(:lvar, :meth_obj), :comment=,
                s(:lvar, :comment)),
              s(:send,
                s(:lvar, :meth_obj), :offset=,
                s(:lvar, :offset)),
              s(:send,
                s(:lvar, :meth_obj), :line=,
                s(:send,
                  s(:send,
                    s(:send,
                      s(:lvar, :file_content), :[],
                      s(:int, 0),
                      s(:lvar, :offset)), :count,
                    s(:str, "\n")), :+,
                  s(:int, 1))),
              s(:lvar, :body))),
          s(:when,
            s(:regexp,
              s(:str, "((?>/\\*.*?\\*/\\s*))^\\s*(\\#\\s*define\\s+"),
              s(:begin,
                s(:lvar, :meth_name)),
              s(:str, "\\s+(\\w+))"),
              s(:regopt, :m)),
            s(:begin,
              s(:lvasgn, :comment,
                s(:send,
                  s(:const,
                    s(:const, nil, :RDoc), :Comment), :new,
                  s(:nth_ref, 1),
                  s(:ivar, :@top_level))),
              s(:lvasgn, :body,
                s(:nth_ref, 2)),
              s(:lvasgn, :offset,
                s(:send,
                  s(:send,
                    s(:gvar, :$~), :offset,
                    s(:int, 2)), :first)),
              s(:send, nil, :find_body,
                s(:lvar, :class_name),
                s(:nth_ref, 3),
                s(:lvar, :meth_obj),
                s(:lvar, :file_content),
                s(:true)),
              s(:send,
                s(:lvar, :comment), :normalize),
              s(:send, nil, :find_modifiers,
                s(:lvar, :comment),
                s(:lvar, :meth_obj)),
              s(:send,
                s(:lvar, :meth_obj), :start_collecting_tokens),
              s(:lvasgn, :tk,
                s(:send,
                  s(:const,
                    s(:const,
                      s(:const, nil, :RDoc), :RubyToken), :Token), :new,
                  s(:nil),
                  s(:int, 1),
                  s(:int, 1))),
              s(:send,
                s(:lvar, :tk), :set_text,
                s(:lvar, :body)),
              s(:send,
                s(:lvar, :meth_obj), :add_token,
                s(:lvar, :tk)),
              s(:send,
                s(:lvar, :meth_obj), :comment=,
                s(:lvar, :comment)),
              s(:send,
                s(:lvar, :meth_obj), :offset=,
                s(:lvar, :offset)),
              s(:send,
                s(:lvar, :meth_obj), :line=,
                s(:send,
                  s(:send,
                    s(:send,
                      s(:lvar, :file_content), :[],
                      s(:int, 0),
                      s(:lvar, :offset)), :count,
                    s(:str, "\n")), :+,
                  s(:int, 1))),
              s(:lvar, :body))),
          s(:when,
            s(:regexp,
              s(:str, "^\\s*\\#\\s*define\\s+"),
              s(:begin,
                s(:lvar, :meth_name)),
              s(:str, "\\s+(\\w+)"),
              s(:regopt, :m)),
            s(:begin,
              s(:lvasgn, :body,
                s(:send, nil, :find_body,
                  s(:lvar, :class_name),
                  s(:nth_ref, 1),
                  s(:lvar, :meth_obj),
                  s(:lvar, :file_content),
                  s(:true))),
              s(:if,
                s(:lvar, :body),
                s(:return,
                  s(:lvar, :body)), nil),
              s(:send,
                s(:ivar, :@options), :warn,
                s(:dstr,
                  s(:str, "No definition for "),
                  s(:begin,
                    s(:lvar, :meth_name)))),
              s(:false))),
          s(:begin,
            s(:lvasgn, :comment,
              s(:send, nil, :find_override_comment,
                s(:lvar, :class_name),
                s(:lvar, :meth_obj))),
            s(:if,
              s(:lvar, :comment),
              s(:begin,
                s(:send,
                  s(:lvar, :comment), :normalize),
                s(:send, nil, :find_modifiers,
                  s(:lvar, :comment),
                  s(:lvar, :meth_obj)),
                s(:send,
                  s(:lvar, :meth_obj), :comment=,
                  s(:lvar, :comment)),
                s(:str, "")),
              s(:begin,
                s(:send,
                  s(:ivar, :@options), :warn,
                  s(:dstr,
                    s(:str, "No definition for "),
                    s(:begin,
                      s(:lvar, :meth_name)))),
                s(:false)))))),
      s(:def, :find_class,
        s(:args,
          s(:arg, :raw_name),
          s(:arg, :name)),
        s(:begin,
          s(:if,
            s(:send,
              s(:ivar, :@classes), :[],
              s(:lvar, :raw_name)), nil,
            s(:begin,
              s(:if,
                s(:send,
                  s(:lvar, :raw_name), :=~,
                  s(:regexp,
                    s(:str, "^rb_m"),
                    s(:regopt))),
                s(:lvasgn, :container,
                  s(:send,
                    s(:ivar, :@top_level), :add_module,
                    s(:const,
                      s(:const, nil, :RDoc), :NormalModule),
                    s(:lvar, :name))),
                s(:lvasgn, :container,
                  s(:send,
                    s(:ivar, :@top_level), :add_class,
                    s(:const,
                      s(:const, nil, :RDoc), :NormalClass),
                    s(:lvar, :name)))),
              s(:send,
                s(:lvar, :container), :record_location,
                s(:ivar, :@top_level)),
              s(:send,
                s(:ivar, :@classes), :[]=,
                s(:lvar, :raw_name),
                s(:lvar, :container)))),
          s(:send,
            s(:ivar, :@classes), :[],
            s(:lvar, :raw_name)))),
      s(:def, :find_class_comment,
        s(:args,
          s(:arg, :class_name),
          s(:arg, :class_mod)),
        s(:begin,
          s(:lvasgn, :comment,
            s(:nil)),
          s(:if,
            s(:send,
              s(:ivar, :@content), :=~,
              s(:regexp,
                s(:str, "\n"),
                s(:str, "        ((?>/\\*.*?\\*/\\s+))\n"),
                s(:str, "        (static\\s+)?\n"),
                s(:str, "        void\\s+\n"),
                s(:str, "        Init_"),
                s(:begin,
                  s(:lvar, :class_name)),
                s(:str, "\\s*(?:_\\(\\s*)?\\(\\s*(?:void\\s*)?\\)"),
                s(:regopt, :i, :m, :x))),
            s(:lvasgn, :comment,
              s(:send,
                s(:nth_ref, 1), :sub,
                s(:regexp,
                  s(:str, "Document-(?:class|module):\\s+"),
                  s(:begin,
                    s(:lvar, :class_name)),
                  s(:regopt)),
                s(:str, ""))),
            s(:if,
              s(:send,
                s(:ivar, :@content), :=~,
                s(:regexp,
                  s(:str, "Document-(?:class|module):\\s+"),
                  s(:begin,
                    s(:lvar, :class_name)),
                  s(:str, "\\s*?\n"),
                  s(:str, "                         (?:<\\s+[:,\\w]+)?\\n((?>.*?\\*/))"),
                  s(:regopt, :m, :x))),
              s(:lvasgn, :comment,
                s(:dstr,
                  s(:str, "/*\n"),
                  s(:begin,
                    s(:nth_ref, 1)))),
              s(:if,
                s(:send,
                  s(:ivar, :@content), :=~,
                  s(:regexp,
                    s(:str, "((?>/\\*.*?\\*/\\s+))\n"),
                    s(:str, "                         ([\\w\\.\\s]+\\s* = \\s+)?rb_define_(class|module)[\\t (]*?\"("),
                    s(:begin,
                      s(:lvar, :class_name)),
                    s(:str, ")\""),
                    s(:regopt, :m, :x))),
                s(:lvasgn, :comment,
                  s(:nth_ref, 1)),
                s(:if,
                  s(:send,
                    s(:ivar, :@content), :=~,
                    s(:regexp,
                      s(:str, "((?>/\\*.*?\\*/\\s+))\n"),
                      s(:str, "                         ([\\w\\. \\t]+ = \\s+)?rb_define_(class|module)_under[\\t\\w, (]*?\"("),
                      s(:begin,
                        s(:send,
                          s(:send,
                            s(:lvar, :class_name), :split,
                            s(:str, "::")), :last)),
                      s(:str, ")\""),
                      s(:regopt, :m, :x))),
                  s(:lvasgn, :comment,
                    s(:nth_ref, 1)),
                  s(:lvasgn, :comment,
                    s(:str, "")))))),
          s(:lvasgn, :comment,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Comment), :new,
              s(:lvar, :comment),
              s(:ivar, :@top_level))),
          s(:send,
            s(:lvar, :comment), :normalize),
          s(:send, nil, :look_for_directives_in,
            s(:lvar, :class_mod),
            s(:lvar, :comment)),
          s(:send,
            s(:lvar, :class_mod), :add_comment,
            s(:lvar, :comment),
            s(:ivar, :@top_level)))),
      s(:def, :find_const_comment,
        s(:args,
          s(:arg, :type),
          s(:arg, :const_name),
          s(:optarg, :class_name,
            s(:nil))),
        s(:begin,
          s(:lvasgn, :comment,
            s(:if,
              s(:send,
                s(:ivar, :@content), :=~,
                s(:regexp,
                  s(:str, "((?>^\\s*/\\*.*?\\*/\\s+))\n"),
                  s(:str, "                             rb_define_"),
                  s(:begin,
                    s(:lvar, :type)),
                  s(:str, "\\((?:\\s*(\\w+),)?\\s*\n"),
                  s(:str, "                                                \""),
                  s(:begin,
                    s(:lvar, :const_name)),
                  s(:str, "\"\\s*,\n"),
                  s(:str, "                                                .*?\\)\\s*;"),
                  s(:regopt, :i, :m, :x))),
              s(:nth_ref, 1),
              s(:if,
                s(:and,
                  s(:lvar, :class_name),
                  s(:send,
                    s(:ivar, :@content), :=~,
                    s(:regexp,
                      s(:str, "Document-(?:const|global|variable):\\s\n"),
                      s(:str, "                                   "),
                      s(:begin,
                        s(:lvar, :class_name)),
                      s(:str, "::"),
                      s(:begin,
                        s(:lvar, :const_name)),
                      s(:str, "\n"),
                      s(:str, "                                   \\s*?\\n((?>.*?\\*/))"),
                      s(:regopt, :m, :x)))),
                s(:dstr,
                  s(:str, "/*\n"),
                  s(:begin,
                    s(:nth_ref, 1))),
                s(:if,
                  s(:send,
                    s(:ivar, :@content), :=~,
                    s(:regexp,
                      s(:str, "Document-(?:const|global|variable):\n"),
                      s(:str, "                                   \\s"),
                      s(:begin,
                        s(:lvar, :const_name)),
                      s(:str, "\n"),
                      s(:str, "                                   \\s*?\\n((?>.*?\\*/))"),
                      s(:regopt, :m, :x))),
                  s(:dstr,
                    s(:str, "/*\n"),
                    s(:begin,
                      s(:nth_ref, 1))),
                  s(:str, ""))))),
          s(:send,
            s(:const,
              s(:const, nil, :RDoc), :Comment), :new,
            s(:lvar, :comment),
            s(:ivar, :@top_level)))),
      s(:def, :find_modifiers,
        s(:args,
          s(:arg, :comment),
          s(:arg, :meth_obj)),
        s(:begin,
          s(:send,
            s(:lvar, :comment), :normalize),
          s(:send,
            s(:lvar, :comment), :extract_call_seq,
            s(:lvar, :meth_obj)),
          s(:send, nil, :look_for_directives_in,
            s(:lvar, :meth_obj),
            s(:lvar, :comment)))),
      s(:def, :find_override_comment,
        s(:args,
          s(:arg, :class_name),
          s(:arg, :meth_obj)),
        s(:begin,
          s(:lvasgn, :name,
            s(:send,
              s(:const, nil, :Regexp), :escape,
              s(:send,
                s(:lvar, :meth_obj), :name))),
          s(:lvasgn, :prefix,
            s(:send,
              s(:const, nil, :Regexp), :escape,
              s(:send,
                s(:lvar, :meth_obj), :name_prefix))),
          s(:lvasgn, :comment,
            s(:if,
              s(:send,
                s(:ivar, :@content), :=~,
                s(:regexp,
                  s(:str, "Document-method:\n"),
                  s(:str, "                                \\s+"),
                  s(:begin,
                    s(:lvar, :class_name)),
                  s(:begin,
                    s(:lvar, :prefix)),
                  s(:begin,
                    s(:lvar, :name)),
                  s(:str, "\n"),
                  s(:str, "                                \\s*?\\n((?>.*?\\*/))"),
                  s(:regopt, :m, :x))),
              s(:dstr,
                s(:str, "/*"),
                s(:begin,
                  s(:nth_ref, 1))),
              s(:if,
                s(:send,
                  s(:ivar, :@content), :=~,
                  s(:regexp,
                    s(:str, "Document-method:\n"),
                    s(:str, "                                   \\s"),
                    s(:begin,
                      s(:lvar, :name)),
                    s(:str, "\\s*?\\n((?>.*?\\*/))"),
                    s(:regopt, :m, :x))),
                s(:dstr,
                  s(:str, "/*"),
                  s(:begin,
                    s(:nth_ref, 1))), nil))),
          s(:if,
            s(:lvar, :comment), nil,
            s(:return)),
          s(:send,
            s(:const,
              s(:const, nil, :RDoc), :Comment), :new,
            s(:lvar, :comment),
            s(:ivar, :@top_level)))),
      s(:def, :handle_attr,
        s(:args,
          s(:arg, :var_name),
          s(:arg, :attr_name),
          s(:arg, :read),
          s(:arg, :write)),
        s(:begin,
          s(:lvasgn, :rw,
            s(:str, "")),
          s(:if,
            s(:send,
              s(:str, "1"), :==,
              s(:lvar, :read)),
            s(:send,
              s(:lvar, :rw), :<<,
              s(:str, "R")), nil),
          s(:if,
            s(:send,
              s(:str, "1"), :==,
              s(:lvar, :write)),
            s(:send,
              s(:lvar, :rw), :<<,
              s(:str, "W")), nil),
          s(:lvasgn, :class_name,
            s(:send,
              s(:ivar, :@known_classes), :[],
              s(:lvar, :var_name))),
          s(:if,
            s(:lvar, :class_name), nil,
            s(:return)),
          s(:lvasgn, :class_obj,
            s(:send, nil, :find_class,
              s(:lvar, :var_name),
              s(:lvar, :class_name))),
          s(:if,
            s(:lvar, :class_obj), nil,
            s(:return)),
          s(:lvasgn, :comment,
            s(:send, nil, :find_attr_comment,
              s(:lvar, :var_name),
              s(:lvar, :attr_name))),
          s(:send,
            s(:lvar, :comment), :normalize),
          s(:lvasgn, :name,
            s(:send,
              s(:lvar, :attr_name), :gsub,
              s(:regexp,
                s(:str, "rb_intern\\(\"([^\"]+)\"\\)"),
                s(:regopt)),
              s(:str, "\\1"))),
          s(:lvasgn, :attr,
            s(:send,
              s(:const,
                s(:const, nil, :RDoc), :Attr), :new,
              s(:str, ""),
              s(:lvar, :name),
              s(:lvar, :rw),
              s(:lvar, :comment))),
          s(:send,
            s(:lvar, :attr), :record_location,
            s(:ivar, :@top_level)),
          s(:send,
            s(:lvar, :class_obj), :add_attribute,
            s(:lvar, :attr)),
          s(:send,
            s(:ivar, :@stats), :add_attribute,
            s(:lvar, :attr)))),
      s(:def, :handle_class_module,
        s(:args,
          s(:arg, :var_name),
          s(:arg, :type),
          s(:arg, :class_name),
          s(:arg, :parent),
          s(:arg, :in_module)),
        s(:begin,
          s(:lvasgn, :parent_name,
            s(:or,
              s(:send,
                s(:ivar, :@known_classes), :[],
                s(:lvar, :parent)),
              s(:lvar, :parent))),
          s(:if,
            s(:lvar, :in_module),
            s(:begin,
              s(:lvasgn, :enclosure,
                s(:or,
                  s(:send,
                    s(:ivar, :@classes), :[],
                    s(:lvar, :in_module)),
                  s(:send,
                    s(:ivar, :@store), :find_c_enclosure,
                    s(:lvar, :in_module)))),
              s(:if,
                s(:and,
                  s(:send,
                    s(:lvar, :enclosure), :nil?),
                  s(:lvasgn, :enclosure,
                    s(:send,
                      s(:ivar, :@known_classes), :[],
                      s(:lvar, :in_module)))),
                s(:begin,
                  s(:lvasgn, :enc_type,
                    s(:if,
                      s(:match_with_lvasgn,
                        s(:regexp,
                          s(:str, "^rb_m"),
                          s(:regopt)),
                        s(:lvar, :in_module)),
                      s(:sym, :module),
                      s(:sym, :class))),
                  s(:send, nil, :handle_class_module,
                    s(:lvar, :in_module),
                    s(:lvar, :enc_type),
                    s(:lvar, :enclosure),
                    s(:nil),
                    s(:nil)),
                  s(:lvasgn, :enclosure,
                    s(:send,
                      s(:ivar, :@classes), :[],
                      s(:lvar, :in_module)))), nil),
              s(:if,
                s(:lvar, :enclosure), nil,
                s(:begin,
                  s(:send,
                    s(:send,
                      s(:ivar, :@enclosure_dependencies), :[],
                      s(:lvar, :in_module)), :<<,
                    s(:lvar, :var_name)),
                  s(:send,
                    s(:ivar, :@missing_dependencies), :[]=,
                    s(:lvar, :var_name),
                    s(:array,
                      s(:lvar, :var_name),
                      s(:lvar, :type),
                      s(:lvar, :class_name),
                      s(:lvar, :parent),
                      s(:lvar, :in_module))),
                  s(:return)))),
            s(:lvasgn, :enclosure,
              s(:ivar, :@top_level))),
          s(:if,
            s(:send,
              s(:lvar, :type), :==,
              s(:sym, :class)),
            s(:begin,
              s(:lvasgn, :full_name,
                s(:if,
                  s(:send,
                    s(:const,
                      s(:const, nil, :RDoc), :ClassModule), :===,
                    s(:lvar, :enclosure)),
                  s(:send,
                    s(:send,
                      s(:lvar, :enclosure), :full_name), :+,
                    s(:dstr,
                      s(:str, "::"),
                      s(:begin,
                        s(:lvar, :class_name)))),
                  s(:lvar, :class_name))),
              s(:if,
                s(:send,
                  s(:ivar, :@content), :=~,
                  s(:regexp,
                    s(:str, "Document-class:\\s+"),
                    s(:begin,
                      s(:lvar, :full_name)),
                    s(:str, "\\s*<\\s+([:,\\w]+)"),
                    s(:regopt))),
                s(:lvasgn, :parent_name,
                  s(:nth_ref, 1)), nil),
              s(:lvasgn, :cm,
                s(:send,
                  s(:lvar, :enclosure), :add_class,
                  s(:const,
                    s(:const, nil, :RDoc), :NormalClass),
                  s(:lvar, :class_name),
                  s(:lvar, :parent_name)))),
            s(:lvasgn, :cm,
              s(:send,
                s(:lvar, :enclosure), :add_module,
                s(:const,
                  s(:const, nil, :RDoc), :NormalModule),
                s(:lvar, :class_name)))),
          s(:send,
            s(:lvar, :cm), :record_location,
            s(:send,
              s(:lvar, :enclosure), :top_level)),
          s(:send, nil, :find_class_comment,
            s(:send,
              s(:lvar, :cm), :full_name),
            s(:lvar, :cm)),
          s(:case,
            s(:lvar, :cm),
            s(:when,
              s(:const,
                s(:const, nil, :RDoc), :NormalClass),
              s(:send,
                s(:ivar, :@stats), :add_class,
                s(:lvar, :cm))),
            s(:when,
              s(:const,
                s(:const, nil, :RDoc), :NormalModule),
              s(:send,
                s(:ivar, :@stats), :add_module,
                s(:lvar, :cm))), nil),
          s(:send,
            s(:ivar, :@classes), :[]=,
            s(:lvar, :var_name),
            s(:lvar, :cm)),
          s(:send,
            s(:ivar, :@known_classes), :[]=,
            s(:lvar, :var_name),
            s(:send,
              s(:lvar, :cm), :full_name)),
          s(:send,
            s(:ivar, :@store), :add_c_enclosure,
            s(:lvar, :var_name),
            s(:lvar, :cm)))),
      s(:def, :handle_constants,
        s(:args,
          s(:arg, :type),
          s(:arg, :var_name),
          s(:arg, :const_name),
          s(:arg, :definition)),
        s(:begin,
          s(:lvasgn, :class_name,
            s(:send,
              s(:ivar, :@known_classes), :[],
              s(:lvar, :var_name))),
          s(:if,
            s(:lvar, :class_name), nil,
            s(:return)),
          s(:lvasgn, :class_obj,
            s(:send, nil, :find_class,
              s(:lvar, :var_name),
              s(:lvar, :class_name))),
          s(:if,
            s(:lvar, :class_obj), nil,
            s(:begin,
              s(:send,
                s(:ivar, :@options), :warn,
                s(:send,
                  s(:str, "Enclosing class or module %p is not known"), :%,
                  s(:array,
                    s(:lvar, :const_name)))),
              s(:return))),
          s(:lvasgn, :comment,
            s(:send, nil, :find_const_comment,
              s(:lvar, :type),
              s(:lvar, :const_name),
              s(:lvar, :class_name))),
          s(:send,
            s(:lvar, :comment), :normalize),
          s(:if,
            s(:send,
              s(:send,
                s(:lvar, :type), :downcase), :==,
              s(:str, "const")),
            s(:begin,
              s(:masgn,
                s(:mlhs,
                  s(:lvasgn, :no_match),
                  s(:lvasgn, :new_definition),
                  s(:lvasgn, :new_comment)),
                s(:send,
                  s(:send,
                    s(:lvar, :comment), :text), :split,
                  s(:regexp,
                    s(:str, "(\\A.*):"),
                    s(:regopt)))),
              s(:if,
                s(:and,
                  s(:lvar, :no_match),
                  s(:send,
                    s(:lvar, :no_match), :empty?)),
                s(:begin,
                  s(:if,
                    s(:send,
                      s(:lvar, :new_definition), :empty?),
                    s(:lvasgn, :new_definition,
                      s(:lvar, :definition)),
                    s(:begin,
                      s(:send,
                        s(:lvar, :new_definition), :gsub!,
                        s(:str, ":"),
                        s(:str, ":")),
                      s(:send,
                        s(:lvar, :new_definition), :gsub!,
                        s(:str, "\\"),
                        s(:str, "\\")))),
                  s(:send,
                    s(:lvar, :new_definition), :sub!,
                    s(:regexp,
                      s(:str, "\\A(\\s+)"),
                      s(:regopt)),
                    s(:str, "")),
                  s(:lvasgn, :new_comment,
                    s(:dstr,
                      s(:begin,
                        s(:nth_ref, 1)),
                      s(:begin,
                        s(:send,
                          s(:lvar, :new_comment), :lstrip)))),
                  s(:lvasgn, :new_comment,
                    s(:send,
                      s(:const,
                        s(:const, nil, :RDoc), :Comment), :new,
                      s(:lvar, :new_comment),
                      s(:ivar, :@top_level))),
                  s(:lvasgn, :con,
                    s(:send,
                      s(:const,
                        s(:const, nil, :RDoc), :Constant), :new,
                      s(:lvar, :const_name),
                      s(:lvar, :new_definition),
                      s(:lvar, :new_comment)))),
                s(:lvasgn, :con,
                  s(:send,
                    s(:const,
                      s(:const, nil, :RDoc), :Constant), :new,
                    s(:lvar, :const_name),
                    s(:lvar, :definition),
                    s(:lvar, :comment))))),
            s(:lvasgn, :con,
              s(:send,
                s(:const,
                  s(:const, nil, :RDoc), :Constant), :new,
                s(:lvar, :const_name),
                s(:lvar, :definition),
                s(:lvar, :comment)))),
          s(:send,
            s(:lvar, :con), :record_location,
            s(:ivar, :@top_level)),
          s(:send,
            s(:ivar, :@stats), :add_constant,
            s(:lvar, :con)),
          s(:send,
            s(:lvar, :class_obj), :add_constant,
            s(:lvar, :con)))),
      s(:def, :handle_ifdefs_in,
        s(:args,
          s(:arg, :body)),
        s(:send,
          s(:lvar, :body), :gsub,
          s(:regexp,
            s(:str, "^#ifdef HAVE_PROTOTYPES.*?#else.*?\\n(.*?)#endif.*?\\n"),
            s(:regopt, :m)),
          s(:str, "\\1"))),
      s(:def, :handle_method,
        s(:args,
          s(:arg, :type),
          s(:arg, :var_name),
          s(:arg, :meth_name),
          s(:arg, :function),
          s(:arg, :param_count),
          s(:optarg, :source_file,
            s(:nil))),
        s(:begin,
          s(:lvasgn, :class_name,
            s(:send,
              s(:ivar, :@known_classes), :[],
              s(:lvar, :var_name))),
          s(:lvasgn, :singleton,
            s(:send,
              s(:ivar, :@singleton_classes), :key?,
              s(:lvar, :var_name))),
          s(:send,
            s(:send,
              s(:send,
                s(:ivar, :@methods), :[],
                s(:lvar, :var_name)), :[],
              s(:lvar, :function)), :<<,
            s(:lvar, :meth_name)),
          s(:if,
            s(:lvar, :class_name), nil,
            s(:return)),
          s(:lvasgn, :class_obj,
            s(:send, nil, :find_class,
              s(:lvar, :var_name),
              s(:lvar, :class_name))),
          s(:if,
            s(:lvar, :class_obj),
            s(:begin,
              s(:if,
                s(:send,
                  s(:lvar, :meth_name), :==,
                  s(:str, "initialize")),
                s(:begin,
                  s(:lvasgn, :meth_name,
                    s(:str, "new")),
                  s(:lvasgn, :singleton,
                    s(:true)),
                  s(:lvasgn, :type,
                    s(:str, "method"))), nil),
              s(:lvasgn, :meth_obj,
                s(:send,
                  s(:const,
                    s(:const, nil, :RDoc), :AnyMethod), :new,
                  s(:str, ""),
                  s(:lvar, :meth_name))),
              s(:send,
                s(:lvar, :meth_obj), :c_function=,
                s(:lvar, :function)),
              s(:send,
                s(:lvar, :meth_obj), :singleton=,
                s(:or,
                  s(:lvar, :singleton),
                  s(:send,
                    s(:array,
                      s(:str, "singleton_method"),
                      s(:str, "module_function")), :include?,
                    s(:lvar, :type)))),
              s(:lvasgn, :p_count,
                s(:rescue,
                  s(:send, nil, :Integer,
                    s(:lvar, :param_count)),
                  s(:resbody, nil, nil,
                    s(:int, -1)), nil)),
              s(:if,
                s(:lvar, :source_file),
                s(:begin,
                  s(:lvasgn, :file_name,
                    s(:send,
                      s(:const, nil, :File), :join,
                      s(:ivar, :@file_dir),
                      s(:lvar, :source_file))),
                  s(:if,
                    s(:send,
                      s(:const, nil, :File), :exist?,
                      s(:lvar, :file_name)),
                    s(:lvasgn, :file_content,
                      s(:send,
                        s(:const, nil, :File), :read,
                        s(:lvar, :file_name))),
                    s(:send,
                      s(:ivar, :@options), :warn,
                      s(:dstr,
                        s(:str, "unknown source "),
                        s(:begin,
                          s(:lvar, :source_file)),
                        s(:str, " for "),
                        s(:begin,
                          s(:lvar, :meth_name)),
                        s(:str, " in "),
                        s(:begin,
                          s(:ivar, :@file_name)))))),
                s(:lvasgn, :file_content,
                  s(:ivar, :@content))),
              s(:lvasgn, :body,
                s(:send, nil, :find_body,
                  s(:lvar, :class_name),
                  s(:lvar, :function),
                  s(:lvar, :meth_obj),
                  s(:lvar, :file_content))),
              s(:if,
                s(:and,
                  s(:lvar, :body),
                  s(:send,
                    s(:lvar, :meth_obj), :document_self)),
                s(:begin,
                  s(:send,
                    s(:lvar, :meth_obj), :params=,
                    s(:if,
                      s(:send,
                        s(:lvar, :p_count), :<,
                        s(:int, -1)),
                      s(:str, "(*args)"),
                      s(:if,
                        s(:send,
                          s(:lvar, :p_count), :==,
                          s(:int, -1)),
                        s(:send, nil, :rb_scan_args,
                          s(:lvar, :body)),
                        s(:dstr,
                          s(:str, "("),
                          s(:begin,
                            s(:send,
                              s(:block,
                                s(:send,
                                  s(:begin,
                                    s(:irange,
                                      s(:int, 1),
                                      s(:lvar, :p_count))), :map),
                                s(:args,
                                  s(:arg, :i)),
                                s(:dstr,
                                  s(:str, "p"),
                                  s(:begin,
                                    s(:lvar, :i)))), :join,
                              s(:str, ", "))),
                          s(:str, ")"))))),
                  s(:send,
                    s(:lvar, :meth_obj), :record_location,
                    s(:ivar, :@top_level)),
                  s(:send,
                    s(:lvar, :class_obj), :add_method,
                    s(:lvar, :meth_obj)),
                  s(:send,
                    s(:ivar, :@stats), :add_method,
                    s(:lvar, :meth_obj)),
                  s(:if,
                    s(:send,
                      s(:str, "private_method"), :==,
                      s(:lvar, :type)),
                    s(:send,
                      s(:lvar, :meth_obj), :visibility=,
                      s(:sym, :private)), nil)), nil)), nil))),
      s(:def, :handle_singleton,
        s(:args,
          s(:arg, :sclass_var),
          s(:arg, :class_var)),
        s(:begin,
          s(:lvasgn, :class_name,
            s(:send,
              s(:ivar, :@known_classes), :[],
              s(:lvar, :class_var))),
          s(:send,
            s(:ivar, :@known_classes), :[]=,
            s(:lvar, :sclass_var),
            s(:lvar, :class_name)),
          s(:send,
            s(:ivar, :@singleton_classes), :[]=,
            s(:lvar, :sclass_var),
            s(:lvar, :class_name)))),
      s(:def, :handle_tab_width,
        s(:args,
          s(:arg, :body)),
        s(:if,
          s(:match_with_lvasgn,
            s(:regexp,
              s(:str, "\\t"),
              s(:regopt)),
            s(:lvar, :body)),
          s(:begin,
            s(:lvasgn, :tab_width,
              s(:send,
                s(:ivar, :@options), :tab_width)),
            s(:send,
              s(:block,
                s(:send,
                  s(:send,
                    s(:lvar, :body), :split,
                    s(:regexp,
                      s(:str, "\\n"),
                      s(:regopt))), :map),
                s(:args,
                  s(:arg, :line)),
                s(:begin,
                  s(:while,
                    s(:and,
                      s(:block,
                        s(:send,
                          s(:lvar, :line), :gsub!,
                          s(:regexp,
                            s(:str, "\\t+"),
                            s(:regopt))),
                        s(:args),
                        s(:send,
                          s(:str, " "), :*,
                          s(:begin,
                            s(:send,
                              s(:send,
                                s(:lvar, :tab_width), :*,
                                s(:send,
                                  s(:back_ref, :$&), :length)), :-,
                              s(:send,
                                s(:send,
                                  s(:back_ref, :$`), :length), :%,
                                s(:lvar, :tab_width)))))),
                      s(:gvar, :$~)),
                    s(:int, 1)),
                  s(:lvar, :line))), :join,
              s(:str, "\n"))),
          s(:lvar, :body))),
      s(:def, :load_variable_map,
        s(:args,
          s(:arg, :map_name)),
        s(:begin,
          s(:if,
            s(:lvasgn, :files,
              s(:send,
                s(:send,
                  s(:ivar, :@store), :cache), :[],
                s(:lvar, :map_name))), nil,
            s(:return,
              s(:hash))),
          s(:if,
            s(:lvasgn, :name_map,
              s(:send,
                s(:lvar, :files), :[],
                s(:ivar, :@file_name))), nil,
            s(:return,
              s(:hash))),
          s(:lvasgn, :class_map,
            s(:hash)),
          s(:block,
            s(:send,
              s(:lvar, :name_map), :each),
            s(:args,
              s(:arg, :variable),
              s(:arg, :name)),
            s(:begin,
              s(:if,
                s(:lvasgn, :mod,
                  s(:send,
                    s(:ivar, :@store), :find_class_or_module,
                    s(:lvar, :name))), nil,
                s(:next)),
              s(:send,
                s(:lvar, :class_map), :[]=,
                s(:lvar, :variable),
                s(:if,
                  s(:send,
                    s(:lvar, :map_name), :==,
                    s(:sym, :c_class_variables)),
                  s(:lvar, :mod),
                  s(:lvar, :name))),
              s(:send,
                s(:ivar, :@known_classes), :[]=,
                s(:lvar, :variable),
                s(:lvar, :name)))),
          s(:lvar, :class_map))),
      s(:def, :look_for_directives_in,
        s(:args,
          s(:arg, :context),
          s(:arg, :comment)),
        s(:begin,
          s(:block,
            s(:send,
              s(:ivar, :@preprocess), :handle,
              s(:lvar, :comment),
              s(:lvar, :context)),
            s(:args,
              s(:arg, :directive),
              s(:arg, :param)),
            s(:case,
              s(:lvar, :directive),
              s(:when,
                s(:str, "main"),
                s(:begin,
                  s(:send,
                    s(:ivar, :@options), :main_page=,
                    s(:lvar, :param)),
                  s(:str, ""))),
              s(:when,
                s(:str, "title"),
                s(:begin,
                  s(:if,
                    s(:send,
                      s(:ivar, :@options), :respond_to?,
                      s(:sym, :default_title=)),
                    s(:send,
                      s(:ivar, :@options), :default_title=,
                      s(:lvar, :param)), nil),
                  s(:str, ""))), nil)),
          s(:lvar, :comment))),
      s(:def, :rb_scan_args,
        s(:args,
          s(:arg, :method_body)),
        s(:begin,
          s(:send,
            s(:lvar, :method_body), :=~,
            s(:regexp,
              s(:str, "rb_scan_args\\((.*?)\\)"),
              s(:regopt, :m))),
          s(:if,
            s(:nth_ref, 1), nil,
            s(:return,
              s(:str, "(*args)"))),
          s(:send,
            s(:send,
              s(:send,
                s(:nth_ref, 1), :split,
                s(:regexp,
                  s(:str, ","),
                  s(:regopt))), :[],
              s(:int, 2)), :=~,
            s(:regexp,
              s(:str, "\"(.*?)\""),
              s(:regopt))),
          s(:lvasgn, :format,
            s(:send,
              s(:nth_ref, 1), :split,
              s(:regexp,
                s(:regopt)))),
          s(:lvasgn, :lead,
            s(:lvasgn, :opt,
              s(:lvasgn, :trail,
                s(:int, 0)))),
          s(:if,
            s(:send,
              s(:send,
                s(:lvar, :format), :first), :=~,
              s(:regexp,
                s(:str, "\\d"),
                s(:regopt))),
            s(:begin,
              s(:lvasgn, :lead,
                s(:send,
                  s(:back_ref, :$&), :to_i)),
              s(:send,
                s(:lvar, :format), :shift),
              s(:if,
                s(:send,
                  s(:send,
                    s(:lvar, :format), :first), :=~,
                  s(:regexp,
                    s(:str, "\\d"),
                    s(:regopt))),
                s(:begin,
                  s(:lvasgn, :opt,
                    s(:send,
                      s(:back_ref, :$&), :to_i)),
                  s(:send,
                    s(:lvar, :format), :shift),
                  s(:if,
                    s(:send,
                      s(:send,
                        s(:lvar, :format), :first), :=~,
                      s(:regexp,
                        s(:str, "\\d"),
                        s(:regopt))),
                    s(:begin,
                      s(:lvasgn, :trail,
                        s(:send,
                          s(:back_ref, :$&), :to_i)),
                      s(:send,
                        s(:lvar, :format), :shift),
                      s(:lvasgn, :block_arg,
                        s(:true))), nil)), nil)), nil),
          s(:if,
            s(:and,
              s(:send,
                s(:send,
                  s(:lvar, :format), :first), :==,
                s(:str, "*")),
              s(:send,
                s(:lvar, :block_arg), :!)),
            s(:begin,
              s(:lvasgn, :var,
                s(:true)),
              s(:send,
                s(:lvar, :format), :shift),
              s(:if,
                s(:send,
                  s(:send,
                    s(:lvar, :format), :first), :=~,
                  s(:regexp,
                    s(:str, "\\d"),
                    s(:regopt))),
                s(:begin,
                  s(:lvasgn, :trail,
                    s(:send,
                      s(:back_ref, :$&), :to_i)),
                  s(:send,
                    s(:lvar, :format), :shift)), nil)), nil),
          s(:if,
            s(:send,
              s(:send,
                s(:lvar, :format), :first), :==,
              s(:str, ":")),
            s(:begin,
              s(:lvasgn, :hash,
                s(:true)),
              s(:send,
                s(:lvar, :format), :shift)), nil),
          s(:if,
            s(:send,
              s(:send,
                s(:lvar, :format), :first), :==,
              s(:str, "&")),
            s(:begin,
              s(:lvasgn, :block,
                s(:true)),
              s(:send,
                s(:lvar, :format), :shift)), nil),
          s(:lvasgn, :args,
            s(:array)),
          s(:lvasgn, :position,
            s(:int, 1)),
          s(:block,
            s(:send,
              s(:begin,
                s(:erange,
                  s(:int, 1),
                  s(:begin,
                    s(:send,
                      s(:lvar, :position), :+,
                      s(:lvar, :lead))))), :each),
            s(:args,
              s(:arg, :index)),
            s(:send,
              s(:lvar, :args), :<<,
              s(:dstr,
                s(:str, "p"),
                s(:begin,
                  s(:lvar, :index))))),
          s(:op_asgn,
            s(:lvasgn, :position), :+,
            s(:lvar, :lead)),
          s(:block,
            s(:send,
              s(:begin,
                s(:erange,
                  s(:lvar, :position),
                  s(:begin,
                    s(:send,
                      s(:lvar, :position), :+,
                      s(:lvar, :opt))))), :each),
            s(:args,
              s(:arg, :index)),
            s(:send,
              s(:lvar, :args), :<<,
              s(:dstr,
                s(:str, "p"),
                s(:begin,
                  s(:lvar, :index)),
                s(:str, " = v"),
                s(:begin,
                  s(:lvar, :index))))),
          s(:op_asgn,
            s(:lvasgn, :position), :+,
            s(:lvar, :opt)),
          s(:if,
            s(:lvar, :var),
            s(:begin,
              s(:send,
                s(:lvar, :args), :<<,
                s(:str, "*args")),
              s(:op_asgn,
                s(:lvasgn, :position), :+,
                s(:int, 1))), nil),
          s(:block,
            s(:send,
              s(:begin,
                s(:erange,
                  s(:lvar, :position),
                  s(:begin,
                    s(:send,
                      s(:lvar, :position), :+,
                      s(:lvar, :trail))))), :each),
            s(:args,
              s(:arg, :index)),
            s(:send,
              s(:lvar, :args), :<<,
              s(:dstr,
                s(:str, "p"),
                s(:begin,
                  s(:lvar, :index))))),
          s(:op_asgn,
            s(:lvasgn, :position), :+,
            s(:lvar, :trail)),
          s(:if,
            s(:lvar, :hash),
            s(:send,
              s(:lvar, :args), :<<,
              s(:dstr,
                s(:str, "p"),
                s(:begin,
                  s(:lvar, :position)),
                s(:str, " = {}"))), nil),
          s(:if,
            s(:lvar, :block),
            s(:send,
              s(:lvar, :args), :<<,
              s(:str, "&block")), nil),
          s(:dstr,
            s(:str, "("),
            s(:begin,
              s(:send,
                s(:lvar, :args), :join,
                s(:str, ", "))),
            s(:str, ")")))),
      s(:def, :remove_commented_out_lines,
        s(:args),
        s(:send,
          s(:ivar, :@content), :gsub!,
          s(:regexp,
            s(:str, "//.*rb_define_"),
            s(:regopt)),
          s(:str, "//"))),
      s(:def, :scan,
        s(:args),
        s(:begin,
          s(:send, nil, :remove_commented_out_lines),
          s(:send, nil, :do_modules),
          s(:send, nil, :do_classes),
          s(:send, nil, :do_missing),
          s(:send, nil, :do_constants),
          s(:send, nil, :do_methods),
          s(:send, nil, :do_includes),
          s(:send, nil, :do_aliases),
          s(:send, nil, :do_attrs),
          s(:send, nil, :deduplicate_call_seq),
          s(:send,
            s(:ivar, :@store), :add_c_variables,
            s(:self)),
          s(:ivar, :@top_level))))))
