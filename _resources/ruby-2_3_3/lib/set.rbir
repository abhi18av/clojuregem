s(:begin,
  s(:class,
    s(:const, nil, :Set), nil,
    s(:begin,
      s(:send, nil, :include,
        s(:const, nil, :Enumerable)),
      s(:defs,
        s(:self), :[],
        s(:args,
          s(:restarg, :ary)),
        s(:send, nil, :new,
          s(:lvar, :ary))),
      s(:def, :initialize,
        s(:args,
          s(:optarg, :enum,
            s(:nil)),
          s(:blockarg, :block)),
        s(:begin,
          s(:or_asgn,
            s(:ivasgn, :@hash),
            s(:send,
              s(:const, nil, :Hash), :new,
              s(:false))),
          s(:and,
            s(:send,
              s(:lvar, :enum), :nil?),
            s(:return)),
          s(:if,
            s(:lvar, :block),
            s(:block,
              s(:send, nil, :do_with_enum,
                s(:lvar, :enum)),
              s(:args,
                s(:arg, :o)),
              s(:send, nil, :add,
                s(:send,
                  s(:lvar, :block), :[],
                  s(:lvar, :o)))),
            s(:send, nil, :merge,
              s(:lvar, :enum))))),
      s(:def, :do_with_enum,
        s(:args,
          s(:arg, :enum),
          s(:blockarg, :block)),
        s(:if,
          s(:send,
            s(:lvar, :enum), :respond_to?,
            s(:sym, :each_entry)),
          s(:if,
            s(:lvar, :block),
            s(:send,
              s(:lvar, :enum), :each_entry,
              s(:block_pass,
                s(:lvar, :block))), nil),
          s(:if,
            s(:send,
              s(:lvar, :enum), :respond_to?,
              s(:sym, :each)),
            s(:if,
              s(:lvar, :block),
              s(:send,
                s(:lvar, :enum), :each,
                s(:block_pass,
                  s(:lvar, :block))), nil),
            s(:send, nil, :raise,
              s(:const, nil, :ArgumentError),
              s(:str, "value must be enumerable"))))),
      s(:send, nil, :private,
        s(:sym, :do_with_enum)),
      s(:def, :initialize_dup,
        s(:args,
          s(:arg, :orig)),
        s(:begin,
          s(:zsuper),
          s(:ivasgn, :@hash,
            s(:send,
              s(:send,
                s(:lvar, :orig), :instance_variable_get,
                s(:sym, :@hash)), :dup)))),
      s(:def, :initialize_clone,
        s(:args,
          s(:arg, :orig)),
        s(:begin,
          s(:zsuper),
          s(:ivasgn, :@hash,
            s(:send,
              s(:send,
                s(:lvar, :orig), :instance_variable_get,
                s(:sym, :@hash)), :clone)))),
      s(:def, :freeze,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@hash), :freeze),
          s(:zsuper))),
      s(:def, :taint,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@hash), :taint),
          s(:zsuper))),
      s(:def, :untaint,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@hash), :untaint),
          s(:zsuper))),
      s(:def, :size,
        s(:args),
        s(:send,
          s(:ivar, :@hash), :size)),
      s(:alias,
        s(:sym, :length),
        s(:sym, :size)),
      s(:def, :empty?,
        s(:args),
        s(:send,
          s(:ivar, :@hash), :empty?)),
      s(:def, :clear,
        s(:args),
        s(:begin,
          s(:send,
            s(:ivar, :@hash), :clear),
          s(:self))),
      s(:def, :replace,
        s(:args,
          s(:arg, :enum)),
        s(:if,
          s(:send,
            s(:lvar, :enum), :instance_of?,
            s(:send,
              s(:self), :class)),
          s(:begin,
            s(:send,
              s(:ivar, :@hash), :replace,
              s(:send,
                s(:lvar, :enum), :instance_variable_get,
                s(:sym, :@hash))),
            s(:self)),
          s(:begin,
            s(:send, nil, :do_with_enum,
              s(:lvar, :enum)),
            s(:send, nil, :clear),
            s(:send, nil, :merge,
              s(:lvar, :enum))))),
      s(:def, :to_a,
        s(:args),
        s(:send,
          s(:ivar, :@hash), :keys)),
      s(:def, :to_set,
        s(:args,
          s(:optarg, :klass,
            s(:const, nil, :Set)),
          s(:restarg, :args),
          s(:blockarg, :block)),
        s(:begin,
          s(:if,
            s(:and,
              s(:and,
                s(:and,
                  s(:send, nil, :instance_of?,
                    s(:const, nil, :Set)),
                  s(:send,
                    s(:lvar, :klass), :==,
                    s(:const, nil, :Set))),
                s(:send,
                  s(:lvar, :block), :nil?)),
              s(:send,
                s(:lvar, :args), :empty?)),
            s(:return,
              s(:self)), nil),
          s(:send,
            s(:lvar, :klass), :new,
            s(:self),
            s(:splat,
              s(:lvar, :args)),
            s(:block_pass,
              s(:lvar, :block))))),
      s(:def, :flatten_merge,
        s(:args,
          s(:arg, :set),
          s(:optarg, :seen,
            s(:send,
              s(:const, nil, :Set), :new))),
        s(:begin,
          s(:block,
            s(:send,
              s(:lvar, :set), :each),
            s(:args,
              s(:arg, :e)),
            s(:if,
              s(:send,
                s(:lvar, :e), :is_a?,
                s(:const, nil, :Set)),
              s(:begin,
                s(:if,
                  s(:send,
                    s(:lvar, :seen), :include?,
                    s(:lvasgn, :e_id,
                      s(:send,
                        s(:lvar, :e), :object_id))),
                  s(:send, nil, :raise,
                    s(:const, nil, :ArgumentError),
                    s(:str, "tried to flatten recursive Set")), nil),
                s(:send,
                  s(:lvar, :seen), :add,
                  s(:lvar, :e_id)),
                s(:send, nil, :flatten_merge,
                  s(:lvar, :e),
                  s(:lvar, :seen)),
                s(:send,
                  s(:lvar, :seen), :delete,
                  s(:lvar, :e_id))),
              s(:send, nil, :add,
                s(:lvar, :e)))),
          s(:self))),
      s(:send, nil, :protected,
        s(:sym, :flatten_merge)),
      s(:def, :flatten,
        s(:args),
        s(:send,
          s(:send,
            s(:send,
              s(:self), :class), :new), :flatten_merge,
          s(:self))),
      s(:def, :flatten!,
        s(:args),
        s(:if,
          s(:block,
            s(:send, nil, :any?),
            s(:args,
              s(:arg, :e)),
            s(:send,
              s(:lvar, :e), :is_a?,
              s(:const, nil, :Set))),
          s(:send, nil, :replace,
            s(:send, nil, :flatten)), nil)),
      s(:def, :include?,
        s(:args,
          s(:arg, :o)),
        s(:send,
          s(:ivar, :@hash), :[],
          s(:lvar, :o))),
      s(:alias,
        s(:sym, :member?),
        s(:sym, :include?)),
      s(:def, :superset?,
        s(:args,
          s(:arg, :set)),
        s(:case, nil,
          s(:when,
            s(:send,
              s(:lvar, :set), :instance_of?,
              s(:send,
                s(:self), :class)),
            s(:send,
              s(:ivar, :@hash), :>=,
              s(:send,
                s(:lvar, :set), :instance_variable_get,
                s(:sym, :@hash)))),
          s(:when,
            s(:send,
              s(:lvar, :set), :is_a?,
              s(:const, nil, :Set)),
            s(:and,
              s(:send,
                s(:send, nil, :size), :>=,
                s(:send,
                  s(:lvar, :set), :size)),
              s(:block,
                s(:send,
                  s(:lvar, :set), :all?),
                s(:args,
                  s(:arg, :o)),
                s(:send, nil, :include?,
                  s(:lvar, :o))))),
          s(:send, nil, :raise,
            s(:const, nil, :ArgumentError),
            s(:str, "value must be a set")))),
      s(:alias,
        s(:sym, :>=),
        s(:sym, :superset?)),
      s(:def, :proper_superset?,
        s(:args,
          s(:arg, :set)),
        s(:case, nil,
          s(:when,
            s(:send,
              s(:lvar, :set), :instance_of?,
              s(:send,
                s(:self), :class)),
            s(:send,
              s(:ivar, :@hash), :>,
              s(:send,
                s(:lvar, :set), :instance_variable_get,
                s(:sym, :@hash)))),
          s(:when,
            s(:send,
              s(:lvar, :set), :is_a?,
              s(:const, nil, :Set)),
            s(:and,
              s(:send,
                s(:send, nil, :size), :>,
                s(:send,
                  s(:lvar, :set), :size)),
              s(:block,
                s(:send,
                  s(:lvar, :set), :all?),
                s(:args,
                  s(:arg, :o)),
                s(:send, nil, :include?,
                  s(:lvar, :o))))),
          s(:send, nil, :raise,
            s(:const, nil, :ArgumentError),
            s(:str, "value must be a set")))),
      s(:alias,
        s(:sym, :>),
        s(:sym, :proper_superset?)),
      s(:def, :subset?,
        s(:args,
          s(:arg, :set)),
        s(:case, nil,
          s(:when,
            s(:send,
              s(:lvar, :set), :instance_of?,
              s(:send,
                s(:self), :class)),
            s(:send,
              s(:ivar, :@hash), :<=,
              s(:send,
                s(:lvar, :set), :instance_variable_get,
                s(:sym, :@hash)))),
          s(:when,
            s(:send,
              s(:lvar, :set), :is_a?,
              s(:const, nil, :Set)),
            s(:and,
              s(:send,
                s(:send, nil, :size), :<=,
                s(:send,
                  s(:lvar, :set), :size)),
              s(:block,
                s(:send, nil, :all?),
                s(:args,
                  s(:arg, :o)),
                s(:send,
                  s(:lvar, :set), :include?,
                  s(:lvar, :o))))),
          s(:send, nil, :raise,
            s(:const, nil, :ArgumentError),
            s(:str, "value must be a set")))),
      s(:alias,
        s(:sym, :<=),
        s(:sym, :subset?)),
      s(:def, :proper_subset?,
        s(:args,
          s(:arg, :set)),
        s(:case, nil,
          s(:when,
            s(:send,
              s(:lvar, :set), :instance_of?,
              s(:send,
                s(:self), :class)),
            s(:send,
              s(:ivar, :@hash), :<,
              s(:send,
                s(:lvar, :set), :instance_variable_get,
                s(:sym, :@hash)))),
          s(:when,
            s(:send,
              s(:lvar, :set), :is_a?,
              s(:const, nil, :Set)),
            s(:and,
              s(:send,
                s(:send, nil, :size), :<,
                s(:send,
                  s(:lvar, :set), :size)),
              s(:block,
                s(:send, nil, :all?),
                s(:args,
                  s(:arg, :o)),
                s(:send,
                  s(:lvar, :set), :include?,
                  s(:lvar, :o))))),
          s(:send, nil, :raise,
            s(:const, nil, :ArgumentError),
            s(:str, "value must be a set")))),
      s(:alias,
        s(:sym, :<),
        s(:sym, :proper_subset?)),
      s(:def, :intersect?,
        s(:args,
          s(:arg, :set)),
        s(:begin,
          s(:or,
            s(:send,
              s(:lvar, :set), :is_a?,
              s(:const, nil, :Set)),
            s(:send, nil, :raise,
              s(:const, nil, :ArgumentError),
              s(:str, "value must be a set"))),
          s(:if,
            s(:send,
              s(:send, nil, :size), :<,
              s(:send,
                s(:lvar, :set), :size)),
            s(:block,
              s(:send, nil, :any?),
              s(:args,
                s(:arg, :o)),
              s(:send,
                s(:lvar, :set), :include?,
                s(:lvar, :o))),
            s(:block,
              s(:send,
                s(:lvar, :set), :any?),
              s(:args,
                s(:arg, :o)),
              s(:send, nil, :include?,
                s(:lvar, :o)))))),
      s(:def, :disjoint?,
        s(:args,
          s(:arg, :set)),
        s(:send,
          s(:send, nil, :intersect?,
            s(:lvar, :set)), :!)),
      s(:def, :each,
        s(:args,
          s(:blockarg, :block)),
        s(:begin,
          s(:or,
            s(:lvar, :block),
            s(:return,
              s(:block,
                s(:send, nil, :enum_for,
                  s(:send, nil, :__method__)),
                s(:args),
                s(:send, nil, :size)))),
          s(:send,
            s(:ivar, :@hash), :each_key,
            s(:block_pass,
              s(:lvar, :block))),
          s(:self))),
      s(:def, :add,
        s(:args,
          s(:arg, :o)),
        s(:begin,
          s(:send,
            s(:ivar, :@hash), :[]=,
            s(:lvar, :o),
            s(:true)),
          s(:self))),
      s(:alias,
        s(:sym, :<<),
        s(:sym, :add)),
      s(:def, :add?,
        s(:args,
          s(:arg, :o)),
        s(:if,
          s(:send, nil, :include?,
            s(:lvar, :o)), nil,
          s(:send, nil, :add,
            s(:lvar, :o)))),
      s(:def, :delete,
        s(:args,
          s(:arg, :o)),
        s(:begin,
          s(:send,
            s(:ivar, :@hash), :delete,
            s(:lvar, :o)),
          s(:self))),
      s(:def, :delete?,
        s(:args,
          s(:arg, :o)),
        s(:if,
          s(:send, nil, :include?,
            s(:lvar, :o)),
          s(:send, nil, :delete,
            s(:lvar, :o)), nil)),
      s(:def, :delete_if,
        s(:args),
        s(:begin,
          s(:or,
            s(:send, nil, :block_given?),
            s(:return,
              s(:send, nil, :enum_for,
                s(:send, nil, :__method__)))),
          s(:block,
            s(:send,
              s(:block,
                s(:send, nil, :select),
                s(:args,
                  s(:arg, :o)),
                s(:yield,
                  s(:lvar, :o))), :each),
            s(:args,
              s(:arg, :o)),
            s(:send,
              s(:ivar, :@hash), :delete,
              s(:lvar, :o))),
          s(:self))),
      s(:def, :keep_if,
        s(:args),
        s(:begin,
          s(:or,
            s(:send, nil, :block_given?),
            s(:return,
              s(:send, nil, :enum_for,
                s(:send, nil, :__method__)))),
          s(:block,
            s(:send,
              s(:block,
                s(:send, nil, :reject),
                s(:args,
                  s(:arg, :o)),
                s(:yield,
                  s(:lvar, :o))), :each),
            s(:args,
              s(:arg, :o)),
            s(:send,
              s(:ivar, :@hash), :delete,
              s(:lvar, :o))),
          s(:self))),
      s(:def, :collect!,
        s(:args),
        s(:begin,
          s(:or,
            s(:send, nil, :block_given?),
            s(:return,
              s(:send, nil, :enum_for,
                s(:send, nil, :__method__)))),
          s(:send, nil, :replace,
            s(:block,
              s(:send,
                s(:send,
                  s(:self), :class), :new,
                s(:self)),
              s(:args,
                s(:arg, :o)),
              s(:yield,
                s(:lvar, :o)))))),
      s(:alias,
        s(:sym, :map!),
        s(:sym, :collect!)),
      s(:def, :reject!,
        s(:args,
          s(:blockarg, :block)),
        s(:begin,
          s(:or,
            s(:lvar, :block),
            s(:return,
              s(:send, nil, :enum_for,
                s(:send, nil, :__method__)))),
          s(:lvasgn, :n,
            s(:send, nil, :size)),
          s(:send, nil, :delete_if,
            s(:block_pass,
              s(:lvar, :block))),
          s(:if,
            s(:send,
              s(:send, nil, :size), :!=,
              s(:lvar, :n)),
            s(:self), nil))),
      s(:def, :select!,
        s(:args,
          s(:blockarg, :block)),
        s(:begin,
          s(:or,
            s(:lvar, :block),
            s(:return,
              s(:send, nil, :enum_for,
                s(:send, nil, :__method__)))),
          s(:lvasgn, :n,
            s(:send, nil, :size)),
          s(:send, nil, :keep_if,
            s(:block_pass,
              s(:lvar, :block))),
          s(:if,
            s(:send,
              s(:send, nil, :size), :!=,
              s(:lvar, :n)),
            s(:self), nil))),
      s(:def, :merge,
        s(:args,
          s(:arg, :enum)),
        s(:begin,
          s(:if,
            s(:send,
              s(:lvar, :enum), :instance_of?,
              s(:send,
                s(:self), :class)),
            s(:send,
              s(:ivar, :@hash), :update,
              s(:send,
                s(:lvar, :enum), :instance_variable_get,
                s(:sym, :@hash))),
            s(:block,
              s(:send, nil, :do_with_enum,
                s(:lvar, :enum)),
              s(:args,
                s(:arg, :o)),
              s(:send, nil, :add,
                s(:lvar, :o)))),
          s(:self))),
      s(:def, :subtract,
        s(:args,
          s(:arg, :enum)),
        s(:begin,
          s(:block,
            s(:send, nil, :do_with_enum,
              s(:lvar, :enum)),
            s(:args,
              s(:arg, :o)),
            s(:send, nil, :delete,
              s(:lvar, :o))),
          s(:self))),
      s(:def, :|,
        s(:args,
          s(:arg, :enum)),
        s(:send,
          s(:send, nil, :dup), :merge,
          s(:lvar, :enum))),
      s(:alias,
        s(:sym, :+),
        s(:sym, :|)),
      s(:alias,
        s(:sym, :union),
        s(:sym, :|)),
      s(:def, :-,
        s(:args,
          s(:arg, :enum)),
        s(:send,
          s(:send, nil, :dup), :subtract,
          s(:lvar, :enum))),
      s(:alias,
        s(:sym, :difference),
        s(:sym, :-)),
      s(:def, :&,
        s(:args,
          s(:arg, :enum)),
        s(:begin,
          s(:lvasgn, :n,
            s(:send,
              s(:send,
                s(:self), :class), :new)),
          s(:block,
            s(:send, nil, :do_with_enum,
              s(:lvar, :enum)),
            s(:args,
              s(:arg, :o)),
            s(:if,
              s(:send, nil, :include?,
                s(:lvar, :o)),
              s(:send,
                s(:lvar, :n), :add,
                s(:lvar, :o)), nil)),
          s(:lvar, :n))),
      s(:alias,
        s(:sym, :intersection),
        s(:sym, :&)),
      s(:def, :^,
        s(:args,
          s(:arg, :enum)),
        s(:begin,
          s(:lvasgn, :n,
            s(:send,
              s(:const, nil, :Set), :new,
              s(:lvar, :enum))),
          s(:block,
            s(:send, nil, :each),
            s(:args,
              s(:arg, :o)),
            s(:if,
              s(:send,
                s(:lvar, :n), :delete?,
                s(:lvar, :o)), nil,
              s(:send,
                s(:lvar, :n), :add,
                s(:lvar, :o)))),
          s(:lvar, :n))),
      s(:def, :==,
        s(:args,
          s(:arg, :other)),
        s(:if,
          s(:send,
            s(:self), :equal?,
            s(:lvar, :other)),
          s(:true),
          s(:if,
            s(:send,
              s(:lvar, :other), :instance_of?,
              s(:send,
                s(:self), :class)),
            s(:send,
              s(:ivar, :@hash), :==,
              s(:send,
                s(:lvar, :other), :instance_variable_get,
                s(:sym, :@hash))),
            s(:if,
              s(:and,
                s(:send,
                  s(:lvar, :other), :is_a?,
                  s(:const, nil, :Set)),
                s(:send,
                  s(:send,
                    s(:self), :size), :==,
                  s(:send,
                    s(:lvar, :other), :size))),
              s(:block,
                s(:send,
                  s(:lvar, :other), :all?),
                s(:args,
                  s(:arg, :o)),
                s(:send,
                  s(:ivar, :@hash), :include?,
                  s(:lvar, :o))),
              s(:false))))),
      s(:def, :hash,
        s(:args),
        s(:send,
          s(:ivar, :@hash), :hash)),
      s(:def, :eql?,
        s(:args,
          s(:arg, :o)),
        s(:begin,
          s(:if,
            s(:send,
              s(:lvar, :o), :is_a?,
              s(:const, nil, :Set)), nil,
            s(:return,
              s(:false))),
          s(:send,
            s(:ivar, :@hash), :eql?,
            s(:send,
              s(:lvar, :o), :instance_variable_get,
              s(:sym, :@hash))))),
      s(:def, :classify,
        s(:args),
        s(:begin,
          s(:or,
            s(:send, nil, :block_given?),
            s(:return,
              s(:send, nil, :enum_for,
                s(:send, nil, :__method__)))),
          s(:lvasgn, :h,
            s(:hash)),
          s(:block,
            s(:send, nil, :each),
            s(:args,
              s(:arg, :i)),
            s(:send,
              s(:begin,
                s(:or_asgn,
                  s(:send,
                    s(:lvar, :h), :[],
                    s(:yield,
                      s(:lvar, :i))),
                  s(:send,
                    s(:send,
                      s(:self), :class), :new))), :add,
              s(:lvar, :i))),
          s(:lvar, :h))),
      s(:def, :divide,
        s(:args,
          s(:blockarg, :func)),
        s(:begin,
          s(:or,
            s(:lvar, :func),
            s(:return,
              s(:send, nil, :enum_for,
                s(:send, nil, :__method__)))),
          s(:if,
            s(:send,
              s(:send,
                s(:lvar, :func), :arity), :==,
              s(:int, 2)),
            s(:begin,
              s(:send, nil, :require,
                s(:str, "tsort")),
              s(:sclass,
                s(:lvasgn, :dig,
                  s(:hash)),
                s(:begin,
                  s(:send, nil, :include,
                    s(:const, nil, :TSort)),
                  s(:alias,
                    s(:sym, :tsort_each_node),
                    s(:sym, :each_key)),
                  s(:def, :tsort_each_child,
                    s(:args,
                      s(:arg, :node),
                      s(:blockarg, :block)),
                    s(:send,
                      s(:send, nil, :fetch,
                        s(:lvar, :node)), :each,
                      s(:block_pass,
                        s(:lvar, :block)))))),
              s(:block,
                s(:send, nil, :each),
                s(:args,
                  s(:arg, :u)),
                s(:begin,
                  s(:send,
                    s(:lvar, :dig), :[]=,
                    s(:lvar, :u),
                    s(:lvasgn, :a,
                      s(:array))),
                  s(:block,
                    s(:send, nil, :each),
                    s(:args,
                      s(:arg, :v)),
                    s(:and,
                      s(:send,
                        s(:lvar, :func), :call,
                        s(:lvar, :u),
                        s(:lvar, :v)),
                      s(:send,
                        s(:lvar, :a), :<<,
                        s(:lvar, :v)))))),
              s(:lvasgn, :set,
                s(:send,
                  s(:const, nil, :Set), :new)),
              s(:block,
                s(:send,
                  s(:lvar, :dig), :each_strongly_connected_component),
                s(:args,
                  s(:arg, :css)),
                s(:send,
                  s(:lvar, :set), :add,
                  s(:send,
                    s(:send,
                      s(:self), :class), :new,
                    s(:lvar, :css)))),
              s(:lvar, :set)),
            s(:send,
              s(:const, nil, :Set), :new,
              s(:send,
                s(:send, nil, :classify,
                  s(:block_pass,
                    s(:lvar, :func))), :values))))),
      s(:casgn, nil, :InspectKey,
        s(:sym, :__inspect_key__)),
      s(:def, :inspect,
        s(:args),
        s(:begin,
          s(:lvasgn, :ids,
            s(:begin,
              s(:or_asgn,
                s(:send,
                  s(:send,
                    s(:const, nil, :Thread), :current), :[],
                  s(:const, nil, :InspectKey)),
                s(:array)))),
          s(:if,
            s(:send,
              s(:lvar, :ids), :include?,
              s(:send, nil, :object_id)),
            s(:return,
              s(:send, nil, :sprintf,
                s(:str, "#<%s: {...}>"),
                s(:send,
                  s(:send,
                    s(:self), :class), :name))), nil),
          s(:send,
            s(:lvar, :ids), :<<,
            s(:send, nil, :object_id)),
          s(:kwbegin,
            s(:ensure,
              s(:return,
                s(:send, nil, :sprintf,
                  s(:str, "#<%s: {%s}>"),
                  s(:send,
                    s(:self), :class),
                  s(:send,
                    s(:send,
                      s(:send, nil, :to_a), :inspect), :[],
                    s(:irange,
                      s(:int, 1),
                      s(:int, -2))))),
              s(:send,
                s(:lvar, :ids), :pop))))),
      s(:def, :pretty_print,
        s(:args,
          s(:arg, :pp)),
        s(:begin,
          s(:send,
            s(:lvar, :pp), :text,
            s(:send, nil, :sprintf,
              s(:str, "#<%s: {"),
              s(:send,
                s(:send,
                  s(:self), :class), :name))),
          s(:block,
            s(:send,
              s(:lvar, :pp), :nest,
              s(:int, 1)),
            s(:args),
            s(:block,
              s(:send,
                s(:lvar, :pp), :seplist,
                s(:self)),
              s(:args,
                s(:arg, :o)),
              s(:send,
                s(:lvar, :pp), :pp,
                s(:lvar, :o)))),
          s(:send,
            s(:lvar, :pp), :text,
            s(:str, "}>")))),
      s(:def, :pretty_print_cycle,
        s(:args,
          s(:arg, :pp)),
        s(:send,
          s(:lvar, :pp), :text,
          s(:send, nil, :sprintf,
            s(:str, "#<%s: {%s}>"),
            s(:send,
              s(:send,
                s(:self), :class), :name),
            s(:if,
              s(:send, nil, :empty?),
              s(:str, ""),
              s(:str, "..."))))))),
  s(:class,
    s(:const, nil, :SortedSet),
    s(:const, nil, :Set),
    s(:begin,
      s(:cvasgn, :@@setup,
        s(:false)),
      s(:sclass,
        s(:self),
        s(:begin,
          s(:def, :[],
            s(:args,
              s(:restarg, :ary)),
            s(:send, nil, :new,
              s(:lvar, :ary))),
          s(:def, :setup,
            s(:args),
            s(:begin,
              s(:and,
                s(:cvar, :@@setup),
                s(:return)),
              s(:block,
                s(:send, nil, :module_eval),
                s(:args),
                s(:alias,
                  s(:sym, :old_init),
                  s(:sym, :initialize))),
              s(:kwbegin,
                s(:rescue,
                  s(:begin,
                    s(:send, nil, :require,
                      s(:str, "rbtree")),
                    s(:send, nil, :module_eval,
                      s(:dstr,
                        s(:str, "          def initialize(*args)\n"),
                        s(:str, "            @hash = RBTree.new\n"),
                        s(:str, "            super\n"),
                        s(:str, "          end\n"),
                        s(:str, "\n"),
                        s(:str, "          def add(o)\n"),
                        s(:str, "            o.respond_to?(:<=>) or raise ArgumentError, \"value must respond to <=>\"\n"),
                        s(:str, "            super\n"),
                        s(:str, "          end\n"),
                        s(:str, "          alias << add\n")),
                      s(:str, "(string)"),
                      s(:send,
                        s(:int, 609), :+,
                        s(:int, 1)))),
                  s(:resbody,
                    s(:array,
                      s(:const, nil, :LoadError)), nil,
                    s(:send, nil, :module_eval,
                      s(:dstr,
                        s(:str, "          def initialize(*args)\n"),
                        s(:str, "            @keys = nil\n"),
                        s(:str, "            super\n"),
                        s(:str, "          end\n"),
                        s(:str, "\n"),
                        s(:str, "          def clear\n"),
                        s(:str, "            @keys = nil\n"),
                        s(:str, "            super\n"),
                        s(:str, "          end\n"),
                        s(:str, "\n"),
                        s(:str, "          def replace(enum)\n"),
                        s(:str, "            @keys = nil\n"),
                        s(:str, "            super\n"),
                        s(:str, "          end\n"),
                        s(:str, "\n"),
                        s(:str, "          def add(o)\n"),
                        s(:str, "            o.respond_to?(:<=>) or raise ArgumentError, \"value must respond to <=>\"\n"),
                        s(:str, "            @keys = nil\n"),
                        s(:str, "            super\n"),
                        s(:str, "          end\n"),
                        s(:str, "          alias << add\n"),
                        s(:str, "\n"),
                        s(:str, "          def delete(o)\n"),
                        s(:str, "            @keys = nil\n"),
                        s(:str, "            @hash.delete(o)\n"),
                        s(:str, "            self\n"),
                        s(:str, "          end\n"),
                        s(:str, "\n"),
                        s(:str, "          def delete_if\n"),
                        s(:str, "            block_given? or return enum_for(__method__)\n"),
                        s(:str, "            n = @hash.size\n"),
                        s(:str, "            super\n"),
                        s(:str, "            @keys = nil if @hash.size != n\n"),
                        s(:str, "            self\n"),
                        s(:str, "          end\n"),
                        s(:str, "\n"),
                        s(:str, "          def keep_if\n"),
                        s(:str, "            block_given? or return enum_for(__method__)\n"),
                        s(:str, "            n = @hash.size\n"),
                        s(:str, "            super\n"),
                        s(:str, "            @keys = nil if @hash.size != n\n"),
                        s(:str, "            self\n"),
                        s(:str, "          end\n"),
                        s(:str, "\n"),
                        s(:str, "          def merge(enum)\n"),
                        s(:str, "            @keys = nil\n"),
                        s(:str, "            super\n"),
                        s(:str, "          end\n"),
                        s(:str, "\n"),
                        s(:str, "          def each(&block)\n"),
                        s(:str, "            block or return enum_for(__method__) { size }\n"),
                        s(:str, "            to_a.each(&block)\n"),
                        s(:str, "            self\n"),
                        s(:str, "          end\n"),
                        s(:str, "\n"),
                        s(:str, "          def to_a\n"),
                        s(:str, "            (@keys = @hash.keys).sort! unless @keys\n"),
                        s(:str, "            @keys\n"),
                        s(:str, "          end\n")),
                      s(:str, "(string)"),
                      s(:send,
                        s(:int, 622), :+,
                        s(:int, 1)))), nil)),
              s(:block,
                s(:send, nil, :module_eval),
                s(:args),
                s(:send, nil, :remove_method,
                  s(:sym, :old_init))),
              s(:cvasgn, :@@setup,
                s(:true)))))),
      s(:def, :initialize,
        s(:args,
          s(:restarg, :args),
          s(:blockarg, :block)),
        s(:begin,
          s(:send,
            s(:const, nil, :SortedSet), :setup),
          s(:send, nil, :initialize,
            s(:splat,
              s(:lvar, :args)),
            s(:block_pass,
              s(:lvar, :block))))))),
  s(:module,
    s(:const, nil, :Enumerable),
    s(:def, :to_set,
      s(:args,
        s(:optarg, :klass,
          s(:const, nil, :Set)),
        s(:restarg, :args),
        s(:blockarg, :block)),
      s(:send,
        s(:lvar, :klass), :new,
        s(:self),
        s(:splat,
          s(:lvar, :args)),
        s(:block_pass,
          s(:lvar, :block))))))
