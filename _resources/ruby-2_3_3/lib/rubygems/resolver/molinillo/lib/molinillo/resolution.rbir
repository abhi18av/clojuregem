s(:module,
  s(:const,
    s(:const,
      s(:const, nil, :Gem), :Resolver), :Molinillo),
  s(:class,
    s(:const, nil, :Resolver), nil,
    s(:class,
      s(:const, nil, :Resolution), nil,
      s(:begin,
        s(:casgn, nil, :Conflict,
          s(:send,
            s(:const, nil, :Struct), :new,
            s(:sym, :requirement),
            s(:sym, :requirements),
            s(:sym, :existing),
            s(:sym, :possibility),
            s(:sym, :locked_requirement),
            s(:sym, :requirement_trees),
            s(:sym, :activated_by_name))),
        s(:send, nil, :attr_reader,
          s(:sym, :specification_provider)),
        s(:send, nil, :attr_reader,
          s(:sym, :resolver_ui)),
        s(:send, nil, :attr_reader,
          s(:sym, :base)),
        s(:send, nil, :attr_reader,
          s(:sym, :original_requested)),
        s(:def, :initialize,
          s(:args,
            s(:arg, :specification_provider),
            s(:arg, :resolver_ui),
            s(:arg, :requested),
            s(:arg, :base)),
          s(:begin,
            s(:ivasgn, :@specification_provider,
              s(:lvar, :specification_provider)),
            s(:ivasgn, :@resolver_ui,
              s(:lvar, :resolver_ui)),
            s(:ivasgn, :@original_requested,
              s(:lvar, :requested)),
            s(:ivasgn, :@base,
              s(:lvar, :base)),
            s(:ivasgn, :@states,
              s(:array)),
            s(:ivasgn, :@iteration_counter,
              s(:int, 0)))),
        s(:def, :resolve,
          s(:args),
          s(:ensure,
            s(:begin,
              s(:send, nil, :start_resolution),
              s(:while,
                s(:send, nil, :state),
                s(:begin,
                  s(:if,
                    s(:or,
                      s(:send,
                        s(:send,
                          s(:send, nil, :state), :requirements), :any?),
                      s(:send,
                        s(:send, nil, :state), :requirement)), nil,
                    s(:break)),
                  s(:send, nil, :indicate_progress),
                  s(:if,
                    s(:send,
                      s(:send, nil, :state), :respond_to?,
                      s(:sym, :pop_possibility_state)),
                    s(:begin,
                      s(:block,
                        s(:send, nil, :debug,
                          s(:send, nil, :depth)),
                        s(:args),
                        s(:dstr,
                          s(:str, "Creating possibility state for "),
                          s(:begin,
                            s(:send, nil, :requirement)),
                          s(:str, " ("),
                          s(:begin,
                            s(:send,
                              s(:send, nil, :possibilities), :count)),
                          s(:str, " remaining)"))),
                      s(:block,
                        s(:send,
                          s(:send,
                            s(:send, nil, :state), :pop_possibility_state), :tap),
                        s(:args,
                          s(:arg, :s)),
                        s(:if,
                          s(:lvar, :s),
                          s(:send,
                            s(:send, nil, :states), :push,
                            s(:lvar, :s)), nil))), nil),
                  s(:send, nil, :process_topmost_state))),
              s(:send,
                s(:send, nil, :activated), :freeze)),
            s(:send, nil, :end_resolution))),
        s(:send, nil, :attr_accessor,
          s(:sym, :iteration_rate)),
        s(:send, nil, :private,
          s(:sym, :iteration_rate)),
        s(:send, nil, :attr_accessor,
          s(:sym, :started_at)),
        s(:send, nil, :private,
          s(:sym, :started_at)),
        s(:send, nil, :attr_accessor,
          s(:sym, :states)),
        s(:send, nil, :private,
          s(:sym, :states)),
        s(:send, nil, :private),
        s(:def, :start_resolution,
          s(:args),
          s(:begin,
            s(:ivasgn, :@started_at,
              s(:send,
                s(:const, nil, :Time), :now)),
            s(:send, nil, :handle_missing_or_push_dependency_state,
              s(:send, nil, :initial_state)),
            s(:block,
              s(:send, nil, :debug),
              s(:args),
              s(:dstr,
                s(:str, "Starting resolution ("),
                s(:begin,
                  s(:ivar, :@started_at)),
                s(:str, ")"))),
            s(:send,
              s(:send, nil, :resolver_ui), :before_resolution))),
        s(:def, :end_resolution,
          s(:args),
          s(:begin,
            s(:send,
              s(:send, nil, :resolver_ui), :after_resolution),
            s(:block,
              s(:send, nil, :debug),
              s(:args),
              s(:dstr,
                s(:dstr,
                  s(:str, "Finished resolution ("),
                  s(:begin,
                    s(:ivar, :@iteration_counter)),
                  s(:str, " steps) ")),
                s(:dstr,
                  s(:str, "(Took "),
                  s(:begin,
                    s(:send,
                      s(:begin,
                        s(:lvasgn, :ended_at,
                          s(:send,
                            s(:const, nil, :Time), :now))), :-,
                      s(:ivar, :@started_at))),
                  s(:str, " seconds) ("),
                  s(:begin,
                    s(:lvar, :ended_at)),
                  s(:str, ")")))),
            s(:if,
              s(:send, nil, :state),
              s(:block,
                s(:send, nil, :debug),
                s(:args),
                s(:send,
                  s(:str, "Unactivated: "), :+,
                  s(:send,
                    s(:send,
                      s(:send,
                        s(:const, nil, :Hash), :[],
                        s(:block,
                          s(:send,
                            s(:send,
                              s(:send, nil, :activated), :vertices), :reject),
                          s(:args,
                            s(:arg, :_n),
                            s(:arg, :v)),
                          s(:send,
                            s(:lvar, :v), :payload))), :keys), :join,
                    s(:str, ", ")))), nil),
            s(:if,
              s(:send, nil, :state),
              s(:block,
                s(:send, nil, :debug),
                s(:args),
                s(:send,
                  s(:str, "Activated: "), :+,
                  s(:send,
                    s(:send,
                      s(:send,
                        s(:const, nil, :Hash), :[],
                        s(:block,
                          s(:send,
                            s(:send,
                              s(:send, nil, :activated), :vertices), :select),
                          s(:args,
                            s(:arg, :_n),
                            s(:arg, :v)),
                          s(:send,
                            s(:lvar, :v), :payload))), :keys), :join,
                    s(:str, ", ")))), nil))),
        s(:send, nil, :require,
          s(:str, "rubygems/resolver/molinillo/lib/molinillo/state")),
        s(:send, nil, :require,
          s(:str, "rubygems/resolver/molinillo/lib/molinillo/modules/specification_provider")),
        s(:block,
          s(:send,
            s(:send,
              s(:send,
                s(:const, nil, :ResolutionState), :new), :members), :each),
          s(:args,
            s(:arg, :member)),
          s(:block,
            s(:send, nil, :define_method,
              s(:lvar, :member)),
            s(:args,
              s(:restarg, :args),
              s(:blockarg, :block)),
            s(:begin,
              s(:lvasgn, :current_state,
                s(:or,
                  s(:send, nil, :state),
                  s(:send,
                    s(:const, nil, :ResolutionState), :empty))),
              s(:send,
                s(:lvar, :current_state), :send,
                s(:lvar, :member),
                s(:splat,
                  s(:lvar, :args)),
                s(:block_pass,
                  s(:lvar, :block)))))),
        s(:block,
          s(:send,
            s(:send,
              s(:const, nil, :SpecificationProvider), :instance_methods,
              s(:false)), :each),
          s(:args,
            s(:arg, :instance_method)),
          s(:block,
            s(:send, nil, :define_method,
              s(:lvar, :instance_method)),
            s(:args,
              s(:restarg, :args),
              s(:blockarg, :block)),
            s(:kwbegin,
              s(:rescue,
                s(:send,
                  s(:send, nil, :specification_provider), :send,
                  s(:lvar, :instance_method),
                  s(:splat,
                    s(:lvar, :args)),
                  s(:block_pass,
                    s(:lvar, :block))),
                s(:resbody,
                  s(:array,
                    s(:const, nil, :NoSuchDependencyError)),
                  s(:lvasgn, :error),
                  s(:begin,
                    s(:if,
                      s(:send, nil, :state),
                      s(:begin,
                        s(:lvasgn, :vertex,
                          s(:send,
                            s(:send, nil, :activated), :vertex_named,
                            s(:send, nil, :name_for,
                              s(:send,
                                s(:lvar, :error), :dependency)))),
                        s(:op_asgn,
                          s(:send,
                            s(:lvar, :error), :required_by), :+,
                          s(:block,
                            s(:send,
                              s(:send,
                                s(:lvar, :vertex), :incoming_edges), :map),
                            s(:args,
                              s(:arg, :e)),
                            s(:send,
                              s(:send,
                                s(:lvar, :e), :origin), :name))),
                        s(:if,
                          s(:send,
                            s(:send,
                              s(:lvar, :vertex), :explicit_requirements), :empty?), nil,
                          s(:send,
                            s(:send,
                              s(:lvar, :error), :required_by), :<<,
                            s(:send, nil, :name_for_explicit_dependency_source)))), nil),
                    s(:send, nil, :raise))), nil)))),
        s(:def, :process_topmost_state,
          s(:args),
          s(:if,
            s(:send, nil, :possibility),
            s(:send, nil, :attempt_to_activate),
            s(:begin,
              s(:if,
                s(:send,
                  s(:send, nil, :state), :is_a?,
                  s(:const, nil, :PossibilityState)),
                s(:send, nil, :create_conflict), nil),
              s(:until,
                s(:and,
                  s(:send, nil, :possibility),
                  s(:send,
                    s(:send, nil, :state), :is_a?,
                    s(:const, nil, :DependencyState))),
                s(:send, nil, :unwind_for_conflict))))),
        s(:def, :possibility,
          s(:args),
          s(:send,
            s(:send, nil, :possibilities), :last)),
        s(:def, :state,
          s(:args),
          s(:send,
            s(:send, nil, :states), :last)),
        s(:def, :initial_state,
          s(:args),
          s(:begin,
            s(:lvasgn, :graph,
              s(:block,
                s(:send,
                  s(:send,
                    s(:const, nil, :DependencyGraph), :new), :tap),
                s(:args,
                  s(:arg, :dg)),
                s(:block,
                  s(:send,
                    s(:send, nil, :original_requested), :each),
                  s(:args,
                    s(:arg, :r)),
                  s(:block,
                    s(:send,
                      s(:send,
                        s(:lvar, :dg), :add_vertex,
                        s(:send, nil, :name_for,
                          s(:lvar, :r)),
                        s(:nil),
                        s(:true)), :tap),
                    s(:args,
                      s(:arg, :v)),
                    s(:send,
                      s(:send,
                        s(:lvar, :v), :explicit_requirements), :<<,
                      s(:lvar, :r)))))),
            s(:lvasgn, :requirements,
              s(:send, nil, :sort_dependencies,
                s(:send, nil, :original_requested),
                s(:lvar, :graph),
                s(:hash))),
            s(:lvasgn, :initial_requirement,
              s(:send,
                s(:lvar, :requirements), :shift)),
            s(:send,
              s(:const, nil, :DependencyState), :new,
              s(:and,
                s(:lvar, :initial_requirement),
                s(:send, nil, :name_for,
                  s(:lvar, :initial_requirement))),
              s(:lvar, :requirements),
              s(:lvar, :graph),
              s(:lvar, :initial_requirement),
              s(:and,
                s(:lvar, :initial_requirement),
                s(:send, nil, :search_for,
                  s(:lvar, :initial_requirement))),
              s(:int, 0),
              s(:hash)))),
        s(:def, :unwind_for_conflict,
          s(:args),
          s(:begin,
            s(:block,
              s(:send, nil, :debug,
                s(:send, nil, :depth)),
              s(:args),
              s(:dstr,
                s(:str, "Unwinding for conflict: "),
                s(:begin,
                  s(:send, nil, :requirement)))),
            s(:block,
              s(:send,
                s(:send, nil, :conflicts), :tap),
              s(:args,
                s(:arg, :c)),
              s(:begin,
                s(:send,
                  s(:send, nil, :states), :slice!,
                  s(:irange,
                    s(:begin,
                      s(:send,
                        s(:send, nil, :state_index_for_unwind), :+,
                        s(:int, 1))),
                    s(:int, -1))),
                s(:if,
                  s(:send, nil, :state), nil,
                  s(:send, nil, :raise,
                    s(:send,
                      s(:const, nil, :VersionConflict), :new,
                      s(:lvar, :c)))),
                s(:send,
                  s(:send, nil, :state), :conflicts=,
                  s(:lvar, :c)))))),
        s(:def, :state_index_for_unwind,
          s(:args),
          s(:begin,
            s(:lvasgn, :current_requirement,
              s(:send, nil, :requirement)),
            s(:lvasgn, :existing_requirement,
              s(:send, nil, :requirement_for_existing_name,
                s(:send, nil, :name))),
            s(:until,
              s(:send,
                s(:lvar, :current_requirement), :nil?),
              s(:begin,
                s(:lvasgn, :current_state,
                  s(:send, nil, :find_state_for,
                    s(:lvar, :current_requirement))),
                s(:if,
                  s(:send, nil, :state_any?,
                    s(:lvar, :current_state)),
                  s(:return,
                    s(:send,
                      s(:send, nil, :states), :index,
                      s(:lvar, :current_state))), nil),
                s(:lvasgn, :current_requirement,
                  s(:send, nil, :parent_of,
                    s(:lvar, :current_requirement))))),
            s(:until,
              s(:send,
                s(:lvar, :existing_requirement), :nil?),
              s(:begin,
                s(:lvasgn, :existing_state,
                  s(:send, nil, :find_state_for,
                    s(:lvar, :existing_requirement))),
                s(:if,
                  s(:send, nil, :state_any?,
                    s(:lvar, :existing_state)),
                  s(:return,
                    s(:send,
                      s(:send, nil, :states), :index,
                      s(:lvar, :existing_state))), nil),
                s(:lvasgn, :existing_requirement,
                  s(:send, nil, :parent_of,
                    s(:lvar, :existing_requirement))))),
            s(:int, -1))),
        s(:def, :parent_of,
          s(:args,
            s(:arg, :requirement)),
          s(:begin,
            s(:if,
              s(:lvar, :requirement), nil,
              s(:return,
                s(:nil))),
            s(:lvasgn, :seen,
              s(:false)),
            s(:lvasgn, :state,
              s(:block,
                s(:send,
                  s(:send,
                    s(:send, nil, :states), :reverse_each), :find),
                s(:args,
                  s(:arg, :s)),
                s(:begin,
                  s(:or_asgn,
                    s(:lvasgn, :seen),
                    s(:or,
                      s(:send,
                        s(:send,
                          s(:lvar, :s), :requirement), :==,
                        s(:lvar, :requirement)),
                      s(:send,
                        s(:send,
                          s(:lvar, :s), :requirements), :include?,
                        s(:lvar, :requirement)))),
                  s(:and,
                    s(:and,
                      s(:lvar, :seen),
                      s(:send,
                        s(:send,
                          s(:lvar, :s), :requirement), :!=,
                        s(:lvar, :requirement))),
                    s(:send,
                      s(:send,
                        s(:send,
                          s(:lvar, :s), :requirements), :include?,
                        s(:lvar, :requirement)), :!))))),
            s(:and,
              s(:lvar, :state),
              s(:send,
                s(:lvar, :state), :requirement)))),
        s(:def, :requirement_for_existing_name,
          s(:args,
            s(:arg, :name)),
          s(:begin,
            s(:if,
              s(:send,
                s(:send,
                  s(:send, nil, :activated), :vertex_named,
                  s(:lvar, :name)), :payload), nil,
              s(:return,
                s(:nil))),
            s(:send,
              s(:block,
                s(:send,
                  s(:send,
                    s(:send, nil, :states), :reverse_each), :find),
                s(:args,
                  s(:arg, :s)),
                s(:send,
                  s(:send,
                    s(:send,
                      s(:send,
                        s(:lvar, :s), :activated), :vertex_named,
                      s(:lvar, :name)), :payload), :!)), :requirement))),
        s(:def, :find_state_for,
          s(:args,
            s(:arg, :requirement)),
          s(:begin,
            s(:if,
              s(:lvar, :requirement), nil,
              s(:return,
                s(:nil))),
            s(:block,
              s(:send,
                s(:send,
                  s(:send, nil, :states), :reverse_each), :find),
              s(:args,
                s(:arg, :i)),
              s(:and,
                s(:send,
                  s(:lvar, :requirement), :==,
                  s(:send,
                    s(:lvar, :i), :requirement)),
                s(:send,
                  s(:lvar, :i), :is_a?,
                  s(:const, nil, :DependencyState)))))),
        s(:def, :state_any?,
          s(:args,
            s(:arg, :state)),
          s(:and,
            s(:lvar, :state),
            s(:send,
              s(:send,
                s(:lvar, :state), :possibilities), :any?))),
        s(:def, :create_conflict,
          s(:args),
          s(:begin,
            s(:lvasgn, :vertex,
              s(:send,
                s(:send, nil, :activated), :vertex_named,
                s(:send, nil, :name))),
            s(:lvasgn, :requirements,
              s(:hash,
                s(:pair,
                  s(:send, nil, :name_for_explicit_dependency_source),
                  s(:send,
                    s(:lvar, :vertex), :explicit_requirements)),
                s(:pair,
                  s(:send, nil, :name_for_locking_dependency_source),
                  s(:send, nil, :Array,
                    s(:send, nil, :locked_requirement_named,
                      s(:send, nil, :name)))))),
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :vertex), :incoming_edges), :each),
              s(:args,
                s(:arg, :edge)),
              s(:send,
                s(:begin,
                  s(:or_asgn,
                    s(:send,
                      s(:lvar, :requirements), :[],
                      s(:send,
                        s(:send,
                          s(:lvar, :edge), :origin), :payload)),
                    s(:array))), :unshift,
                s(:send,
                  s(:lvar, :edge), :requirement))),
            s(:send,
              s(:send, nil, :conflicts), :[]=,
              s(:send, nil, :name),
              s(:send,
                s(:const, nil, :Conflict), :new,
                s(:send, nil, :requirement),
                s(:send,
                  s(:const, nil, :Hash), :[],
                  s(:block,
                    s(:send,
                      s(:lvar, :requirements), :select),
                    s(:args,
                      s(:arg, :_),
                      s(:arg, :r)),
                    s(:send,
                      s(:send,
                        s(:lvar, :r), :empty?), :!))),
                s(:send,
                  s(:lvar, :vertex), :payload),
                s(:send, nil, :possibility),
                s(:send, nil, :locked_requirement_named,
                  s(:send, nil, :name)),
                s(:send, nil, :requirement_trees),
                s(:send,
                  s(:const, nil, :Hash), :[],
                  s(:send,
                    s(:block,
                      s(:send,
                        s(:send, nil, :activated), :map),
                      s(:args,
                        s(:arg, :v)),
                      s(:array,
                        s(:send,
                          s(:lvar, :v), :name),
                        s(:send,
                          s(:lvar, :v), :payload))), :select,
                    s(:block_pass,
                      s(:sym, :last)))))))),
        s(:def, :requirement_trees,
          s(:args),
          s(:begin,
            s(:lvasgn, :vertex,
              s(:send,
                s(:send, nil, :activated), :vertex_named,
                s(:send, nil, :name))),
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :vertex), :requirements), :map),
              s(:args,
                s(:arg, :r)),
              s(:send, nil, :requirement_tree_for,
                s(:lvar, :r))))),
        s(:def, :requirement_tree_for,
          s(:args,
            s(:arg, :requirement)),
          s(:begin,
            s(:lvasgn, :tree,
              s(:array)),
            s(:while,
              s(:lvar, :requirement),
              s(:begin,
                s(:send,
                  s(:lvar, :tree), :unshift,
                  s(:lvar, :requirement)),
                s(:lvasgn, :requirement,
                  s(:send, nil, :parent_of,
                    s(:lvar, :requirement))))),
            s(:lvar, :tree))),
        s(:def, :indicate_progress,
          s(:args),
          s(:begin,
            s(:op_asgn,
              s(:ivasgn, :@iteration_counter), :+,
              s(:int, 1)),
            s(:or_asgn,
              s(:ivasgn, :@progress_rate),
              s(:send,
                s(:send, nil, :resolver_ui), :progress_rate)),
            s(:if,
              s(:send,
                s(:send, nil, :iteration_rate), :nil?),
              s(:if,
                s(:send,
                  s(:send,
                    s(:send,
                      s(:const, nil, :Time), :now), :-,
                    s(:send, nil, :started_at)), :>=,
                  s(:ivar, :@progress_rate)),
                s(:send,
                  s(:self), :iteration_rate=,
                  s(:ivar, :@iteration_counter)), nil), nil),
            s(:if,
              s(:and,
                s(:send, nil, :iteration_rate),
                s(:send,
                  s(:begin,
                    s(:send,
                      s(:ivar, :@iteration_counter), :%,
                      s(:send, nil, :iteration_rate))), :==,
                  s(:int, 0))),
              s(:send,
                s(:send, nil, :resolver_ui), :indicate_progress), nil))),
        s(:def, :debug,
          s(:args,
            s(:optarg, :depth,
              s(:int, 0)),
            s(:blockarg, :block)),
          s(:send,
            s(:send, nil, :resolver_ui), :debug,
            s(:lvar, :depth),
            s(:block_pass,
              s(:lvar, :block)))),
        s(:def, :attempt_to_activate,
          s(:args),
          s(:begin,
            s(:block,
              s(:send, nil, :debug,
                s(:send, nil, :depth)),
              s(:args),
              s(:send,
                s(:str, "Attempting to activate "), :+,
                s(:send,
                  s(:send, nil, :possibility), :to_s))),
            s(:lvasgn, :existing_node,
              s(:send,
                s(:send, nil, :activated), :vertex_named,
                s(:send, nil, :name))),
            s(:if,
              s(:send,
                s(:lvar, :existing_node), :payload),
              s(:begin,
                s(:block,
                  s(:send, nil, :debug,
                    s(:send, nil, :depth)),
                  s(:args),
                  s(:dstr,
                    s(:str, "Found existing spec ("),
                    s(:begin,
                      s(:send,
                        s(:lvar, :existing_node), :payload)),
                    s(:str, ")"))),
                s(:send, nil, :attempt_to_activate_existing_spec,
                  s(:lvar, :existing_node))),
              s(:send, nil, :attempt_to_activate_new_spec)))),
        s(:def, :attempt_to_activate_existing_spec,
          s(:args,
            s(:arg, :existing_node)),
          s(:begin,
            s(:lvasgn, :existing_spec,
              s(:send,
                s(:lvar, :existing_node), :payload)),
            s(:if,
              s(:send, nil, :requirement_satisfied_by?,
                s(:send, nil, :requirement),
                s(:send, nil, :activated),
                s(:lvar, :existing_spec)),
              s(:begin,
                s(:lvasgn, :new_requirements,
                  s(:send,
                    s(:send, nil, :requirements), :dup)),
                s(:send, nil, :push_state_for_requirements,
                  s(:lvar, :new_requirements),
                  s(:false))),
              s(:begin,
                s(:if,
                  s(:send, nil, :attempt_to_swap_possibility),
                  s(:return), nil),
                s(:send, nil, :create_conflict),
                s(:block,
                  s(:send, nil, :debug,
                    s(:send, nil, :depth)),
                  s(:args),
                  s(:dstr,
                    s(:str, "Unsatisfied by existing spec ("),
                    s(:begin,
                      s(:send,
                        s(:lvar, :existing_node), :payload)),
                    s(:str, ")"))),
                s(:send, nil, :unwind_for_conflict))))),
        s(:def, :attempt_to_swap_possibility,
          s(:args),
          s(:begin,
            s(:lvasgn, :swapped,
              s(:send,
                s(:send, nil, :activated), :dup)),
            s(:send,
              s(:send,
                s(:lvar, :swapped), :vertex_named,
                s(:send, nil, :name)), :payload=,
              s(:send, nil, :possibility)),
            s(:if,
              s(:block,
                s(:send,
                  s(:send,
                    s(:send,
                      s(:lvar, :swapped), :vertex_named,
                      s(:send, nil, :name)), :requirements), :all?),
                s(:args,
                  s(:arg, :r)),
                s(:send, nil, :requirement_satisfied_by?,
                  s(:lvar, :r),
                  s(:lvar, :swapped),
                  s(:send, nil, :possibility))), nil,
              s(:return)),
            s(:send, nil, :attempt_to_activate_new_spec))),
        s(:def, :attempt_to_activate_new_spec,
          s(:args),
          s(:begin,
            s(:lvasgn, :satisfied,
              s(:kwbegin,
                s(:lvasgn, :locked_requirement,
                  s(:send, nil, :locked_requirement_named,
                    s(:send, nil, :name))),
                s(:lvasgn, :requested_spec_satisfied,
                  s(:send, nil, :requirement_satisfied_by?,
                    s(:send, nil, :requirement),
                    s(:send, nil, :activated),
                    s(:send, nil, :possibility))),
                s(:lvasgn, :locked_spec_satisfied,
                  s(:or,
                    s(:send,
                      s(:lvar, :locked_requirement), :!),
                    s(:send, nil, :requirement_satisfied_by?,
                      s(:lvar, :locked_requirement),
                      s(:send, nil, :activated),
                      s(:send, nil, :possibility)))),
                s(:if,
                  s(:lvar, :requested_spec_satisfied), nil,
                  s(:block,
                    s(:send, nil, :debug,
                      s(:send, nil, :depth)),
                    s(:args),
                    s(:str, "Unsatisfied by requested spec"))),
                s(:if,
                  s(:lvar, :locked_spec_satisfied), nil,
                  s(:block,
                    s(:send, nil, :debug,
                      s(:send, nil, :depth)),
                    s(:args),
                    s(:str, "Unsatisfied by locked spec"))),
                s(:and,
                  s(:lvar, :requested_spec_satisfied),
                  s(:lvar, :locked_spec_satisfied)))),
            s(:if,
              s(:lvar, :satisfied),
              s(:send, nil, :activate_spec),
              s(:begin,
                s(:send, nil, :create_conflict),
                s(:send, nil, :unwind_for_conflict))))),
        s(:def, :locked_requirement_named,
          s(:args,
            s(:arg, :requirement_name)),
          s(:begin,
            s(:lvasgn, :vertex,
              s(:send,
                s(:send, nil, :base), :vertex_named,
                s(:lvar, :requirement_name))),
            s(:and,
              s(:lvar, :vertex),
              s(:send,
                s(:lvar, :vertex), :payload)))),
        s(:def, :activate_spec,
          s(:args),
          s(:begin,
            s(:send,
              s(:send, nil, :conflicts), :delete,
              s(:send, nil, :name)),
            s(:block,
              s(:send, nil, :debug,
                s(:send, nil, :depth)),
              s(:args),
              s(:send,
                s(:send,
                  s(:send,
                    s(:str, "Activated "), :+,
                    s(:send, nil, :name)), :+,
                  s(:str, " at ")), :+,
                s(:send,
                  s(:send, nil, :possibility), :to_s))),
            s(:lvasgn, :vertex,
              s(:send,
                s(:send, nil, :activated), :vertex_named,
                s(:send, nil, :name))),
            s(:send,
              s(:lvar, :vertex), :payload=,
              s(:send, nil, :possibility)),
            s(:send, nil, :require_nested_dependencies_for,
              s(:send, nil, :possibility)))),
        s(:def, :require_nested_dependencies_for,
          s(:args,
            s(:arg, :activated_spec)),
          s(:begin,
            s(:lvasgn, :nested_dependencies,
              s(:send, nil, :dependencies_for,
                s(:lvar, :activated_spec))),
            s(:block,
              s(:send, nil, :debug,
                s(:send, nil, :depth)),
              s(:args),
              s(:dstr,
                s(:str, "Requiring nested dependencies ("),
                s(:begin,
                  s(:send,
                    s(:send,
                      s(:lvar, :nested_dependencies), :map,
                      s(:block_pass,
                        s(:sym, :to_s))), :join,
                    s(:str, ", "))),
                s(:str, ")"))),
            s(:block,
              s(:send,
                s(:lvar, :nested_dependencies), :each),
              s(:args,
                s(:arg, :d)),
              s(:send,
                s(:send, nil, :activated), :add_child_vertex,
                s(:send, nil, :name_for,
                  s(:lvar, :d)),
                s(:nil),
                s(:array,
                  s(:send, nil, :name_for,
                    s(:lvar, :activated_spec))),
                s(:lvar, :d))),
            s(:send, nil, :push_state_for_requirements,
              s(:send,
                s(:send, nil, :requirements), :+,
                s(:lvar, :nested_dependencies)),
              s(:send,
                s(:send,
                  s(:lvar, :nested_dependencies), :size), :>,
                s(:int, 0))))),
        s(:def, :push_state_for_requirements,
          s(:args,
            s(:arg, :new_requirements),
            s(:optarg, :requires_sort,
              s(:true)),
            s(:optarg, :new_activated,
              s(:send,
                s(:send, nil, :activated), :dup))),
          s(:begin,
            s(:if,
              s(:lvar, :requires_sort),
              s(:lvasgn, :new_requirements,
                s(:send, nil, :sort_dependencies,
                  s(:send,
                    s(:lvar, :new_requirements), :uniq),
                  s(:lvar, :new_activated),
                  s(:send, nil, :conflicts))), nil),
            s(:lvasgn, :new_requirement,
              s(:send,
                s(:lvar, :new_requirements), :shift)),
            s(:lvasgn, :new_name,
              s(:if,
                s(:lvar, :new_requirement),
                s(:send, nil, :name_for,
                  s(:lvar, :new_requirement)),
                s(:str, ""))),
            s(:lvasgn, :possibilities,
              s(:if,
                s(:lvar, :new_requirement),
                s(:send, nil, :search_for,
                  s(:lvar, :new_requirement)),
                s(:array))),
            s(:send, nil, :handle_missing_or_push_dependency_state,
              s(:send,
                s(:const, nil, :DependencyState), :new,
                s(:lvar, :new_name),
                s(:lvar, :new_requirements),
                s(:lvar, :new_activated),
                s(:lvar, :new_requirement),
                s(:lvar, :possibilities),
                s(:send, nil, :depth),
                s(:send,
                  s(:send, nil, :conflicts), :dup))))),
        s(:def, :handle_missing_or_push_dependency_state,
          s(:args,
            s(:arg, :state)),
          s(:if,
            s(:and,
              s(:and,
                s(:send,
                  s(:lvar, :state), :requirement),
                s(:send,
                  s(:send,
                    s(:lvar, :state), :possibilities), :empty?)),
              s(:send, nil, :allow_missing?,
                s(:send,
                  s(:lvar, :state), :requirement))),
            s(:begin,
              s(:send,
                s(:send,
                  s(:lvar, :state), :activated), :detach_vertex_named,
                s(:send,
                  s(:lvar, :state), :name)),
              s(:send, nil, :push_state_for_requirements,
                s(:send,
                  s(:send,
                    s(:lvar, :state), :requirements), :dup),
                s(:false),
                s(:send,
                  s(:lvar, :state), :activated))),
            s(:send,
              s(:send, nil, :states), :push,
              s(:lvar, :state))))))))
