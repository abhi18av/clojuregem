s(:begin,
  s(:send, nil, :require,
    s(:str, "e2mmap")),
  s(:send, nil, :require,
    s(:str, "irb/notifier")),
  s(:module,
    s(:const, nil, :IRB),
    s(:class,
      s(:const, nil, :SLex), nil,
      s(:begin,
        s(:send, nil, :extend,
          s(:const, nil, :Exception2MessageMapper)),
        s(:send, nil, :def_exception,
          s(:sym, :ErrNodeNothing),
          s(:str, "node nothing")),
        s(:send, nil, :def_exception,
          s(:sym, :ErrNodeAlreadyExists),
          s(:str, "node already exists")),
        s(:casgn, nil, :DOUT,
          s(:send,
            s(:const, nil, :Notifier), :def_notifier,
            s(:str, "SLex::"))),
        s(:casgn, nil, :D_WARN,
          s(:send,
            s(:const, nil, :DOUT), :def_notifier,
            s(:int, 1),
            s(:str, "Warn: "))),
        s(:casgn, nil, :D_DEBUG,
          s(:send,
            s(:const, nil, :DOUT), :def_notifier,
            s(:int, 2),
            s(:str, "Debug: "))),
        s(:casgn, nil, :D_DETAIL,
          s(:send,
            s(:const, nil, :DOUT), :def_notifier,
            s(:int, 4),
            s(:str, "Detail: "))),
        s(:send,
          s(:const, nil, :DOUT), :level=,
          s(:const,
            s(:const, nil, :Notifier), :D_NOMSG)),
        s(:def, :initialize,
          s(:args),
          s(:ivasgn, :@head,
            s(:send,
              s(:const, nil, :Node), :new,
              s(:str, "")))),
        s(:def, :def_rule,
          s(:args,
            s(:arg, :token),
            s(:optarg, :preproc,
              s(:nil)),
            s(:optarg, :postproc,
              s(:nil)),
            s(:blockarg, :block)),
          s(:begin,
            s(:send,
              s(:const, nil, :D_DETAIL), :pp,
              s(:lvar, :token)),
            s(:if,
              s(:send, nil, :block_given?),
              s(:lvasgn, :postproc,
                s(:lvar, :block)), nil),
            s(:send, nil, :create,
              s(:lvar, :token),
              s(:lvar, :preproc),
              s(:lvar, :postproc)))),
        s(:def, :def_rules,
          s(:args,
            s(:restarg, :tokens),
            s(:blockarg, :block)),
          s(:begin,
            s(:if,
              s(:send, nil, :block_given?),
              s(:lvasgn, :p,
                s(:lvar, :block)), nil),
            s(:for,
              s(:lvasgn, :token),
              s(:lvar, :tokens),
              s(:send, nil, :def_rule,
                s(:lvar, :token),
                s(:nil),
                s(:lvar, :p))))),
        s(:def, :preproc,
          s(:args,
            s(:arg, :token),
            s(:arg, :proc)),
          s(:begin,
            s(:lvasgn, :node,
              s(:send, nil, :search,
                s(:lvar, :token))),
            s(:send,
              s(:lvar, :node), :preproc=,
              s(:lvar, :proc)))),
        s(:def, :postproc,
          s(:args,
            s(:arg, :token)),
          s(:begin,
            s(:lvasgn, :node,
              s(:send, nil, :search,
                s(:lvar, :token),
                s(:send, nil, :proc))),
            s(:send,
              s(:lvar, :node), :postproc=,
              s(:send, nil, :proc)))),
        s(:def, :search,
          s(:args,
            s(:arg, :token)),
          s(:send,
            s(:ivar, :@head), :search,
            s(:send,
              s(:lvar, :token), :split,
              s(:regexp,
                s(:regopt))))),
        s(:def, :create,
          s(:args,
            s(:arg, :token),
            s(:optarg, :preproc,
              s(:nil)),
            s(:optarg, :postproc,
              s(:nil))),
          s(:send,
            s(:ivar, :@head), :create_subnode,
            s(:send,
              s(:lvar, :token), :split,
              s(:regexp,
                s(:regopt))),
            s(:lvar, :preproc),
            s(:lvar, :postproc))),
        s(:def, :match,
          s(:args,
            s(:arg, :token)),
          s(:begin,
            s(:case,
              s(:lvar, :token),
              s(:when,
                s(:const, nil, :Array), nil),
              s(:when,
                s(:const, nil, :String),
                s(:return,
                  s(:send, nil, :match,
                    s(:send,
                      s(:lvar, :token), :split,
                      s(:regexp,
                        s(:regopt)))))),
              s(:return,
                s(:send,
                  s(:ivar, :@head), :match_io,
                  s(:lvar, :token)))),
            s(:lvasgn, :ret,
              s(:send,
                s(:ivar, :@head), :match,
                s(:lvar, :token))),
            s(:block,
              s(:send,
                s(:const, nil, :D_DETAIL), :exec_if),
              s(:args),
              s(:send,
                s(:const, nil, :D_DETAIL), :printf,
                s(:str, "match end: %s:%s\n"),
                s(:lvar, :ret),
                s(:send,
                  s(:lvar, :token), :inspect))),
            s(:lvar, :ret))),
        s(:def, :inspect,
          s(:args),
          s(:send, nil, :format,
            s(:str, "<SLex: @head = %s>"),
            s(:send,
              s(:ivar, :@head), :inspect))),
        s(:class,
          s(:const, nil, :Node), nil,
          s(:begin,
            s(:def, :initialize,
              s(:args,
                s(:optarg, :preproc,
                  s(:nil)),
                s(:optarg, :postproc,
                  s(:nil))),
              s(:begin,
                s(:ivasgn, :@Tree,
                  s(:hash)),
                s(:ivasgn, :@preproc,
                  s(:lvar, :preproc)),
                s(:ivasgn, :@postproc,
                  s(:lvar, :postproc)))),
            s(:send, nil, :attr_accessor,
              s(:sym, :preproc)),
            s(:send, nil, :attr_accessor,
              s(:sym, :postproc)),
            s(:def, :search,
              s(:args,
                s(:arg, :chrs),
                s(:optarg, :opt,
                  s(:nil))),
              s(:begin,
                s(:if,
                  s(:send,
                    s(:lvar, :chrs), :empty?),
                  s(:return,
                    s(:self)), nil),
                s(:lvasgn, :ch,
                  s(:send,
                    s(:lvar, :chrs), :shift)),
                s(:if,
                  s(:lvasgn, :node,
                    s(:send,
                      s(:ivar, :@Tree), :[],
                      s(:lvar, :ch))),
                  s(:send,
                    s(:lvar, :node), :search,
                    s(:lvar, :chrs),
                    s(:lvar, :opt)),
                  s(:if,
                    s(:lvar, :opt),
                    s(:begin,
                      s(:send,
                        s(:lvar, :chrs), :unshift,
                        s(:lvar, :ch)),
                      s(:send,
                        s(:self), :create_subnode,
                        s(:lvar, :chrs))),
                    s(:send,
                      s(:const, nil, :SLex), :fail,
                      s(:const, nil, :ErrNodeNothing)))))),
            s(:def, :create_subnode,
              s(:args,
                s(:arg, :chrs),
                s(:optarg, :preproc,
                  s(:nil)),
                s(:optarg, :postproc,
                  s(:nil))),
              s(:begin,
                s(:if,
                  s(:send,
                    s(:lvar, :chrs), :empty?),
                  s(:begin,
                    s(:if,
                      s(:ivar, :@postproc),
                      s(:begin,
                        s(:send,
                          s(:const, nil, :D_DETAIL), :pp,
                          s(:send, nil, :node)),
                        s(:send,
                          s(:const, nil, :SLex), :fail,
                          s(:const, nil, :ErrNodeAlreadyExists))),
                      s(:begin,
                        s(:send,
                          s(:const, nil, :D_DEBUG), :puts,
                          s(:str, "change abstract node to real node.")),
                        s(:ivasgn, :@preproc,
                          s(:lvar, :preproc)),
                        s(:ivasgn, :@postproc,
                          s(:lvar, :postproc)))),
                    s(:return,
                      s(:self))), nil),
                s(:lvasgn, :ch,
                  s(:send,
                    s(:lvar, :chrs), :shift)),
                s(:if,
                  s(:lvasgn, :node,
                    s(:send,
                      s(:ivar, :@Tree), :[],
                      s(:lvar, :ch))),
                  s(:if,
                    s(:send,
                      s(:lvar, :chrs), :empty?),
                    s(:if,
                      s(:send,
                        s(:lvar, :node), :postproc),
                      s(:begin,
                        s(:send,
                          s(:const, nil, :DebugLogger), :pp,
                          s(:lvar, :node)),
                        s(:send,
                          s(:const, nil, :DebugLogger), :pp,
                          s(:self)),
                        s(:send,
                          s(:const, nil, :DebugLogger), :pp,
                          s(:lvar, :ch)),
                        s(:send,
                          s(:const, nil, :DebugLogger), :pp,
                          s(:lvar, :chrs)),
                        s(:send,
                          s(:const, nil, :SLex), :fail,
                          s(:const, nil, :ErrNodeAlreadyExists))),
                      s(:begin,
                        s(:send,
                          s(:const, nil, :D_WARN), :puts,
                          s(:str, "change abstract node to real node")),
                        s(:send,
                          s(:lvar, :node), :preproc=,
                          s(:lvar, :preproc)),
                        s(:send,
                          s(:lvar, :node), :postproc=,
                          s(:lvar, :postproc)))),
                    s(:send,
                      s(:lvar, :node), :create_subnode,
                      s(:lvar, :chrs),
                      s(:lvar, :preproc),
                      s(:lvar, :postproc))),
                  s(:begin,
                    s(:if,
                      s(:send,
                        s(:lvar, :chrs), :empty?),
                      s(:lvasgn, :node,
                        s(:send,
                          s(:const, nil, :Node), :new,
                          s(:lvar, :preproc),
                          s(:lvar, :postproc))),
                      s(:begin,
                        s(:lvasgn, :node,
                          s(:send,
                            s(:const, nil, :Node), :new)),
                        s(:send,
                          s(:lvar, :node), :create_subnode,
                          s(:lvar, :chrs),
                          s(:lvar, :preproc),
                          s(:lvar, :postproc)))),
                    s(:send,
                      s(:ivar, :@Tree), :[]=,
                      s(:lvar, :ch),
                      s(:lvar, :node)))),
                s(:lvar, :node))),
            s(:def, :match,
              s(:args,
                s(:arg, :chrs),
                s(:optarg, :op,
                  s(:str, ""))),
              s(:begin,
                s(:send,
                  s(:const, nil, :D_DETAIL), :print,
                  s(:str, "match>: "),
                  s(:lvar, :chrs),
                  s(:str, "op:"),
                  s(:lvar, :op),
                  s(:str, "\n")),
                s(:if,
                  s(:send,
                    s(:lvar, :chrs), :empty?),
                  s(:if,
                    s(:or,
                      s(:send,
                        s(:ivar, :@preproc), :nil?),
                      s(:send,
                        s(:ivar, :@preproc), :call,
                        s(:lvar, :op),
                        s(:lvar, :chrs))),
                    s(:begin,
                      s(:send,
                        s(:const, nil, :DOUT), :printf,
                        s(:const, nil, :D_DETAIL),
                        s(:str, "op1: %s\n"),
                        s(:lvar, :op)),
                      s(:send,
                        s(:ivar, :@postproc), :call,
                        s(:lvar, :op),
                        s(:lvar, :chrs))),
                    s(:nil)),
                  s(:begin,
                    s(:lvasgn, :ch,
                      s(:send,
                        s(:lvar, :chrs), :shift)),
                    s(:if,
                      s(:lvasgn, :node,
                        s(:send,
                          s(:ivar, :@Tree), :[],
                          s(:lvar, :ch))),
                      s(:if,
                        s(:lvasgn, :ret,
                          s(:send,
                            s(:lvar, :node), :match,
                            s(:lvar, :chrs),
                            s(:send,
                              s(:lvar, :op), :+,
                              s(:lvar, :ch)))),
                        s(:return,
                          s(:lvar, :ret)),
                        s(:begin,
                          s(:send,
                            s(:lvar, :chrs), :unshift,
                            s(:lvar, :ch)),
                          s(:if,
                            s(:and,
                              s(:ivar, :@postproc),
                              s(:or,
                                s(:send,
                                  s(:ivar, :@preproc), :nil?),
                                s(:send,
                                  s(:ivar, :@preproc), :call,
                                  s(:lvar, :op),
                                  s(:lvar, :chrs)))),
                            s(:begin,
                              s(:send,
                                s(:const, nil, :DOUT), :printf,
                                s(:const, nil, :D_DETAIL),
                                s(:str, "op2: %s\n"),
                                s(:send,
                                  s(:lvar, :op), :inspect)),
                              s(:lvasgn, :ret,
                                s(:send,
                                  s(:ivar, :@postproc), :call,
                                  s(:lvar, :op),
                                  s(:lvar, :chrs))),
                              s(:return,
                                s(:lvar, :ret))),
                            s(:return,
                              s(:nil))))),
                      s(:begin,
                        s(:send,
                          s(:lvar, :chrs), :unshift,
                          s(:lvar, :ch)),
                        s(:if,
                          s(:and,
                            s(:ivar, :@postproc),
                            s(:or,
                              s(:send,
                                s(:ivar, :@preproc), :nil?),
                              s(:send,
                                s(:ivar, :@preproc), :call,
                                s(:lvar, :op),
                                s(:lvar, :chrs)))),
                          s(:begin,
                            s(:send,
                              s(:const, nil, :DOUT), :printf,
                              s(:const, nil, :D_DETAIL),
                              s(:str, "op3: %s\n"),
                              s(:lvar, :op)),
                            s(:send,
                              s(:ivar, :@postproc), :call,
                              s(:lvar, :op),
                              s(:lvar, :chrs)),
                            s(:return,
                              s(:str, ""))),
                          s(:return,
                            s(:nil))))))))),
            s(:def, :match_io,
              s(:args,
                s(:arg, :io),
                s(:optarg, :op,
                  s(:str, ""))),
              s(:begin,
                s(:if,
                  s(:send,
                    s(:lvar, :op), :==,
                    s(:str, "")),
                  s(:begin,
                    s(:lvasgn, :ch,
                      s(:send,
                        s(:lvar, :io), :getc)),
                    s(:if,
                      s(:send,
                        s(:lvar, :ch), :==,
                        s(:nil)),
                      s(:return,
                        s(:nil)), nil)),
                  s(:lvasgn, :ch,
                    s(:send,
                      s(:lvar, :io), :getc_of_rests))),
                s(:if,
                  s(:send,
                    s(:lvar, :ch), :nil?),
                  s(:if,
                    s(:or,
                      s(:send,
                        s(:ivar, :@preproc), :nil?),
                      s(:send,
                        s(:ivar, :@preproc), :call,
                        s(:lvar, :op),
                        s(:lvar, :io))),
                    s(:begin,
                      s(:send,
                        s(:const, nil, :D_DETAIL), :printf,
                        s(:str, "op1: %s\n"),
                        s(:lvar, :op)),
                      s(:send,
                        s(:ivar, :@postproc), :call,
                        s(:lvar, :op),
                        s(:lvar, :io))),
                    s(:nil)),
                  s(:if,
                    s(:lvasgn, :node,
                      s(:send,
                        s(:ivar, :@Tree), :[],
                        s(:lvar, :ch))),
                    s(:if,
                      s(:lvasgn, :ret,
                        s(:send,
                          s(:lvar, :node), :match_io,
                          s(:lvar, :io),
                          s(:send,
                            s(:lvar, :op), :+,
                            s(:lvar, :ch)))),
                      s(:lvar, :ret),
                      s(:begin,
                        s(:send,
                          s(:lvar, :io), :ungetc,
                          s(:lvar, :ch)),
                        s(:if,
                          s(:and,
                            s(:ivar, :@postproc),
                            s(:or,
                              s(:send,
                                s(:ivar, :@preproc), :nil?),
                              s(:send,
                                s(:ivar, :@preproc), :call,
                                s(:lvar, :op),
                                s(:lvar, :io)))),
                          s(:begin,
                            s(:block,
                              s(:send,
                                s(:const, nil, :DOUT), :exec_if),
                              s(:args),
                              s(:send,
                                s(:const, nil, :D_DETAIL), :printf,
                                s(:str, "op2: %s\n"),
                                s(:send,
                                  s(:lvar, :op), :inspect))),
                            s(:send,
                              s(:ivar, :@postproc), :call,
                              s(:lvar, :op),
                              s(:lvar, :io))),
                          s(:nil)))),
                    s(:begin,
                      s(:send,
                        s(:lvar, :io), :ungetc,
                        s(:lvar, :ch)),
                      s(:if,
                        s(:and,
                          s(:ivar, :@postproc),
                          s(:or,
                            s(:send,
                              s(:ivar, :@preproc), :nil?),
                            s(:send,
                              s(:ivar, :@preproc), :call,
                              s(:lvar, :op),
                              s(:lvar, :io)))),
                        s(:begin,
                          s(:send,
                            s(:const, nil, :D_DETAIL), :printf,
                            s(:str, "op3: %s\n"),
                            s(:lvar, :op)),
                          s(:send,
                            s(:ivar, :@postproc), :call,
                            s(:lvar, :op),
                            s(:lvar, :io))),
                        s(:nil)))))))))))),
  s(:if,
    s(:send,
      s(:gvar, :$0), :==,
      s(:str, "(string)")),
    s(:begin,
      s(:case,
        s(:nth_ref, 1),
        s(:when,
          s(:str, "1"),
          s(:begin,
            s(:lvasgn, :tr,
              s(:send,
                s(:const, nil, :SLex), :new)),
            s(:send, nil, :print,
              s(:str, "0: "),
              s(:send,
                s(:lvar, :tr), :inspect),
              s(:str, "\n")),
            s(:block,
              s(:send,
                s(:lvar, :tr), :def_rule,
                s(:str, "=")),
              s(:args),
              s(:send, nil, :print,
                s(:str, "=\n"))),
            s(:send, nil, :print,
              s(:str, "1: "),
              s(:send,
                s(:lvar, :tr), :inspect),
              s(:str, "\n")),
            s(:block,
              s(:send,
                s(:lvar, :tr), :def_rule,
                s(:str, "==")),
              s(:args),
              s(:send, nil, :print,
                s(:str, "==\n"))),
            s(:send, nil, :print,
              s(:str, "2: "),
              s(:send,
                s(:lvar, :tr), :inspect),
              s(:str, "\n")),
            s(:send, nil, :print,
              s(:str, "case 1:\n")),
            s(:send, nil, :print,
              s(:send,
                s(:lvar, :tr), :match,
                s(:str, "=")),
              s(:str, "\n")),
            s(:send, nil, :print,
              s(:str, "case 2:\n")),
            s(:send, nil, :print,
              s(:send,
                s(:lvar, :tr), :match,
                s(:str, "==")),
              s(:str, "\n")),
            s(:send, nil, :print,
              s(:str, "case 3:\n")),
            s(:send, nil, :print,
              s(:send,
                s(:lvar, :tr), :match,
                s(:str, "=>")),
              s(:str, "\n")))),
        s(:when,
          s(:str, "2"),
          s(:begin,
            s(:lvasgn, :tr,
              s(:send,
                s(:const, nil, :SLex), :new)),
            s(:send, nil, :print,
              s(:str, "0: "),
              s(:send,
                s(:lvar, :tr), :inspect),
              s(:str, "\n")),
            s(:block,
              s(:send,
                s(:lvar, :tr), :def_rule,
                s(:str, "=")),
              s(:args),
              s(:send, nil, :print,
                s(:str, "=\n"))),
            s(:send, nil, :print,
              s(:str, "1: "),
              s(:send,
                s(:lvar, :tr), :inspect),
              s(:str, "\n")),
            s(:block,
              s(:send,
                s(:lvar, :tr), :def_rule,
                s(:str, "=="),
                s(:block,
                  s(:send, nil, :proc),
                  s(:args),
                  s(:false))),
              s(:args),
              s(:send, nil, :print,
                s(:str, "==\n"))),
            s(:send, nil, :print,
              s(:str, "2: "),
              s(:send,
                s(:lvar, :tr), :inspect),
              s(:str, "\n")),
            s(:send, nil, :print,
              s(:str, "case 1:\n")),
            s(:send, nil, :print,
              s(:send,
                s(:lvar, :tr), :match,
                s(:str, "=")),
              s(:str, "\n")),
            s(:send, nil, :print,
              s(:str, "case 2:\n")),
            s(:send, nil, :print,
              s(:send,
                s(:lvar, :tr), :match,
                s(:str, "==")),
              s(:str, "\n")),
            s(:send, nil, :print,
              s(:str, "case 3:\n")),
            s(:send, nil, :print,
              s(:send,
                s(:lvar, :tr), :match,
                s(:str, "=>")),
              s(:str, "\n")))), nil),
      s(:send, nil, :exit)), nil))
