s(:begin,
  s(:send, nil, :require,
    s(:str, "optparse")),
  s(:def, :set_argument,
    s(:args,
      s(:arg, :argname),
      s(:arg, :nth)),
    s(:begin,
      s(:send,
        s(:lvar, :argname), :gsub!,
        s(:regexp,
          s(:str, ".+ (.+)"),
          s(:regopt)),
        s(:str, "\\1")),
      s(:send,
        s(:lvar, :argname), :gsub!,
        s(:regexp,
          s(:str, "^\\*"),
          s(:regopt)),
        s(:str, "")),
      s(:dstr,
        s(:begin,
          s(:lvar, :argname)),
        s(:str, " = $arg"),
        s(:begin,
          s(:lvar, :nth))))),
  s(:lvasgn, :ruby_path,
    s(:str, "/usr/local/ruby")),
  s(:lvasgn, :opts,
    s(:send,
      s(:const, nil, :OptionParser), :new)),
  s(:block,
    s(:send,
      s(:lvar, :opts), :on,
      s(:str, "--ruby-path=PATH")),
    s(:args,
      s(:arg, :v)),
    s(:lvasgn, :ruby_path,
      s(:lvar, :v))),
  s(:send,
    s(:lvar, :opts), :parse!,
    s(:const, nil, :ARGV)),
  s(:lvasgn, :text,
    s(:send,
      s(:const, nil, :ARGF), :read)),
  s(:send,
    s(:lvar, :text), :gsub!,
    s(:regexp,
      s(:str, "^#.*$"),
      s(:regopt)),
    s(:str, "")),
  s(:send,
    s(:lvar, :text), :gsub!,
    s(:regexp,
      s(:str, "^provider ruby \\{"),
      s(:regopt)),
    s(:str, "")),
  s(:send,
    s(:lvar, :text), :gsub!,
    s(:regexp,
      s(:str, "^\\};"),
      s(:regopt)),
    s(:str, "")),
  s(:block,
    s(:send,
      s(:lvar, :text), :gsub!,
      s(:regexp,
        s(:str, "probe (.+)\\( *\\);"),
        s(:regopt))),
    s(:args),
    s(:begin,
      s(:lvasgn, :probe_name,
        s(:nth_ref, 1)),
      s(:lvasgn, :probe,
        s(:dstr,
          s(:str, "    probe "),
          s(:begin,
            s(:lvar, :probe_name)),
          s(:str, " = process(\"ruby\").provider(\"ruby\").mark(\""),
          s(:begin,
            s(:lvar, :probe_name)),
          s(:str, "\")\n"),
          s(:str, "    {\n"),
          s(:str, "    }\n"))))),
  s(:block,
    s(:send,
      s(:lvar, :text), :gsub!,
      s(:regexp,
        s(:str, " *probe (.+)\\(([^,)]+)\\);"),
        s(:regopt))),
    s(:args),
    s(:begin,
      s(:lvasgn, :probe_name,
        s(:nth_ref, 1)),
      s(:lvasgn, :arg1,
        s(:nth_ref, 2)),
      s(:lvasgn, :probe,
        s(:dstr,
          s(:str, "    probe "),
          s(:begin,
            s(:lvar, :probe_name)),
          s(:str, " = process(\"ruby\").provider(\"ruby\").mark(\""),
          s(:begin,
            s(:lvar, :probe_name)),
          s(:str, "\")\n"),
          s(:str, "    {\n"),
          s(:str, "      "),
          s(:begin,
            s(:send, nil, :set_argument,
              s(:lvar, :arg1),
              s(:int, 1))),
          s(:str, "\n"),
          s(:str, "    }\n"))))),
  s(:block,
    s(:send,
      s(:lvar, :text), :gsub!,
      s(:regexp,
        s(:str, " *probe (.+)\\(([^,)]+),([^,)]+)\\);"),
        s(:regopt))),
    s(:args),
    s(:begin,
      s(:lvasgn, :probe_name,
        s(:nth_ref, 1)),
      s(:lvasgn, :arg1,
        s(:nth_ref, 2)),
      s(:lvasgn, :arg2,
        s(:nth_ref, 3)),
      s(:lvasgn, :probe,
        s(:dstr,
          s(:str, "    probe "),
          s(:begin,
            s(:lvar, :probe_name)),
          s(:str, " = process(\""),
          s(:begin,
            s(:lvar, :ruby_path)),
          s(:str, "\").provider(\"ruby\").mark(\""),
          s(:begin,
            s(:lvar, :probe_name)),
          s(:str, "\")\n"),
          s(:str, "    {\n"),
          s(:str, "      "),
          s(:begin,
            s(:send, nil, :set_argument,
              s(:lvar, :arg1),
              s(:int, 1))),
          s(:str, "\n"),
          s(:str, "      "),
          s(:begin,
            s(:send, nil, :set_argument,
              s(:lvar, :arg2),
              s(:int, 2))),
          s(:str, "\n"),
          s(:str, "    }\n"))))),
  s(:block,
    s(:send,
      s(:lvar, :text), :gsub!,
      s(:regexp,
        s(:str, " *probe (.+)\\(([^,)]+),([^,)]+),([^,)]+)\\);"),
        s(:regopt))),
    s(:args),
    s(:begin,
      s(:lvasgn, :probe_name,
        s(:nth_ref, 1)),
      s(:lvasgn, :arg1,
        s(:nth_ref, 2)),
      s(:lvasgn, :arg2,
        s(:nth_ref, 3)),
      s(:lvasgn, :arg3,
        s(:nth_ref, 4)),
      s(:lvasgn, :probe,
        s(:dstr,
          s(:str, "    probe "),
          s(:begin,
            s(:lvar, :probe_name)),
          s(:str, " = process(\""),
          s(:begin,
            s(:lvar, :ruby_path)),
          s(:str, "\").provider(\"ruby\").mark(\""),
          s(:begin,
            s(:lvar, :probe_name)),
          s(:str, "\")\n"),
          s(:str, "    {\n"),
          s(:str, "      "),
          s(:begin,
            s(:send, nil, :set_argument,
              s(:lvar, :arg1),
              s(:int, 1))),
          s(:str, "\n"),
          s(:str, "      "),
          s(:begin,
            s(:send, nil, :set_argument,
              s(:lvar, :arg2),
              s(:int, 2))),
          s(:str, "\n"),
          s(:str, "      "),
          s(:begin,
            s(:send, nil, :set_argument,
              s(:lvar, :arg3),
              s(:int, 3))),
          s(:str, "\n"),
          s(:str, "    }\n"))))),
  s(:block,
    s(:send,
      s(:lvar, :text), :gsub!,
      s(:regexp,
        s(:str, " *probe (.+)\\(([^,)]+),([^,)]+),([^,)]+),([^,)]+)\\);"),
        s(:regopt))),
    s(:args),
    s(:begin,
      s(:lvasgn, :probe_name,
        s(:nth_ref, 1)),
      s(:lvasgn, :arg1,
        s(:nth_ref, 2)),
      s(:lvasgn, :arg2,
        s(:nth_ref, 3)),
      s(:lvasgn, :arg3,
        s(:nth_ref, 4)),
      s(:lvasgn, :arg4,
        s(:nth_ref, 5)),
      s(:lvasgn, :probe,
        s(:dstr,
          s(:str, "    probe "),
          s(:begin,
            s(:lvar, :probe_name)),
          s(:str, " = process(\""),
          s(:begin,
            s(:lvar, :ruby_path)),
          s(:str, "\").provider(\"ruby\").mark(\""),
          s(:begin,
            s(:lvar, :probe_name)),
          s(:str, "\")\n"),
          s(:str, "    {\n"),
          s(:str, "      "),
          s(:begin,
            s(:send, nil, :set_argument,
              s(:lvar, :arg1),
              s(:int, 1))),
          s(:str, "\n"),
          s(:str, "      "),
          s(:begin,
            s(:send, nil, :set_argument,
              s(:lvar, :arg2),
              s(:int, 2))),
          s(:str, "\n"),
          s(:str, "      "),
          s(:begin,
            s(:send, nil, :set_argument,
              s(:lvar, :arg3),
              s(:int, 3))),
          s(:str, "\n"),
          s(:str, "      "),
          s(:begin,
            s(:send, nil, :set_argument,
              s(:lvar, :arg4),
              s(:int, 4))),
          s(:str, "\n"),
          s(:str, "    }\n"))))),
  s(:send, nil, :print,
    s(:lvar, :text)))
