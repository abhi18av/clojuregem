s(:begin,
  s(:lvasgn, :text,
    s(:send,
      s(:const, nil, :ARGF), :read)),
  s(:block,
    s(:send,
      s(:lvar, :text), :gsub!,
      s(:regexp,
        s(:str, "^(?!#)(.*)"),
        s(:regopt))),
    s(:args),
    s(:send,
      s(:nth_ref, 1), :upcase)),
  s(:send,
    s(:lvar, :text), :gsub!,
    s(:regexp,
      s(:str, "(?:^ *)?/\\*.*?\\*/\\n?"),
      s(:regopt, :m)),
    s(:str, "")),
  s(:send,
    s(:lvar, :text), :gsub!,
    s(:regexp,
      s(:str, "^#pragma.*\\n"),
      s(:regopt)),
    s(:str, "")),
  s(:send,
    s(:lvar, :text), :gsub!,
    s(:regexp,
      s(:str, "PROVIDER RUBY \\{"),
      s(:regopt)),
    s(:str, "#ifndef\t_PROBES_H\n#define\t_PROBES_H\n#define DTRACE_PROBES_DISABLED 1\n")),
  s(:send,
    s(:lvar, :text), :gsub!,
    s(:regexp,
      s(:str, "\\};"),
      s(:regopt)),
    s(:str, "\n#endif\t/* _PROBES_H */")),
  s(:send,
    s(:lvar, :text), :gsub!,
    s(:regexp,
      s(:str, "__"),
      s(:regopt)),
    s(:str, "_")),
  s(:block,
    s(:send,
      s(:lvar, :text), :gsub!,
      s(:regexp,
        s(:str, "\\((.+?)(?=\\);)"),
        s(:regopt))),
    s(:args),
    s(:send,
      s(:str, "(arg"), :<<,
      s(:send,
        s(:send,
          s(:begin,
            s(:irange,
              s(:int, 0),
              s(:send,
                s(:nth_ref, 1), :count,
                s(:str, ",")))), :to_a), :join,
        s(:str, ", arg")))),
  s(:send,
    s(:lvar, :text), :gsub!,
    s(:regexp,
      s(:str, " *PROBE ([^\\(]*)(\\([^\\)]*\\));"),
      s(:regopt)),
    s(:str, "#define RUBY_DTRACE_\\1_ENABLED() 0\n#define RUBY_DTRACE_\\1\\2 do { } while(0)")),
  s(:send, nil, :puts,
    s(:str, "/* -*- c -*- */")),
  s(:send, nil, :print,
    s(:lvar, :text)))
