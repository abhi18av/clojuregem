s(:begin,
  s(:send, nil, :require,
    s(:str, "optparse")),
  s(:send, nil, :require,
    s(:str, "erb")),
  s(:send, nil, :require,
    s(:str, "fileutils")),
  s(:send, nil, :require,
    s(:str, "pp")),
  s(:class,
    s(:const, nil, :Array), nil,
    s(:if,
      s(:send,
        s(:array), :respond_to?,
        s(:sym, :product)), nil,
      s(:def, :product,
        s(:args,
          s(:restarg, :args)),
        s(:if,
          s(:send,
            s(:lvar, :args), :empty?),
          s(:block,
            s(:send,
              s(:self), :map),
            s(:args,
              s(:arg, :e)),
            s(:array,
              s(:lvar, :e))),
          s(:begin,
            s(:lvasgn, :result,
              s(:array)),
            s(:block,
              s(:send,
                s(:self), :each),
              s(:args,
                s(:arg, :e0)),
              s(:send,
                s(:lvar, :result), :concat,
                s(:block,
                  s(:send,
                    s(:send,
                      s(:send,
                        s(:lvar, :args), :first), :product,
                      s(:splat,
                        s(:send,
                          s(:lvar, :args), :[],
                          s(:irange,
                            s(:int, 1),
                            s(:int, -1))))), :map),
                  s(:args,
                    s(:arg, :es)),
                  s(:array,
                    s(:lvar, :e0),
                    s(:splat,
                      s(:lvar, :es)))))),
            s(:lvar, :result)))))),
  s(:class,
    s(:const, nil, :String), nil,
    s(:if,
      s(:send,
        s(:str, ""), :respond_to?,
        s(:sym, :start_with?)), nil,
      s(:def, :start_with?,
        s(:args,
          s(:restarg, :prefixes)),
        s(:begin,
          s(:block,
            s(:send,
              s(:lvar, :prefixes), :each),
            s(:args,
              s(:arg, :prefix)),
            s(:if,
              s(:and,
                s(:send,
                  s(:send,
                    s(:lvar, :prefix), :length), :<=,
                  s(:send,
                    s(:self), :length)),
                s(:send,
                  s(:lvar, :prefix), :==,
                  s(:send,
                    s(:self), :[],
                    s(:int, 0),
                    s(:send,
                      s(:lvar, :prefix), :length)))),
              s(:return,
                s(:true)), nil)),
          s(:false))))),
  s(:casgn, nil, :NUM_ELEM_BYTELOOKUP,
    s(:int, 2)),
  s(:casgn, nil, :C_ESC,
    s(:hash,
      s(:pair,
        s(:str, "\\"),
        s(:str, "\\\\")),
      s(:pair,
        s(:str, "\""),
        s(:str, "\\\"")),
      s(:pair,
        s(:str, "\n"),
        s(:str, "\\n")))),
  s(:block,
    s(:send,
      s(:int, 0), :upto,
      s(:int, 31)),
    s(:args,
      s(:arg, :ch)),
    s(:or_asgn,
      s(:send,
        s(:const, nil, :C_ESC), :[],
        s(:send,
          s(:array,
            s(:lvar, :ch)), :pack,
          s(:str, "C"))),
      s(:send,
        s(:str, "\\%03o"), :%,
        s(:lvar, :ch)))),
  s(:block,
    s(:send,
      s(:int, 127), :upto,
      s(:int, 255)),
    s(:args,
      s(:arg, :ch)),
    s(:send,
      s(:const, nil, :C_ESC), :[]=,
      s(:send,
        s(:array,
          s(:lvar, :ch)), :pack,
        s(:str, "C")),
      s(:send,
        s(:str, "\\%03o"), :%,
        s(:lvar, :ch)))),
  s(:casgn, nil, :C_ESC_PAT,
    s(:send,
      s(:const, nil, :Regexp), :union,
      s(:splat,
        s(:send,
          s(:const, nil, :C_ESC), :keys)))),
  s(:def, :c_esc,
    s(:args,
      s(:arg, :str)),
    s(:send,
      s(:send,
        s(:str, "\""), :+,
        s(:block,
          s(:send,
            s(:lvar, :str), :gsub,
            s(:const, nil, :C_ESC_PAT)),
          s(:args),
          s(:send,
            s(:const, nil, :C_ESC), :[],
            s(:back_ref, :$&)))), :+,
      s(:str, "\""))),
  s(:casgn, nil, :HEX2,
    s(:regexp,
      s(:str, "(?:[0-9A-Fa-f]{2})"),
      s(:regopt))),
  s(:class,
    s(:const, nil, :ArrayCode), nil,
    s(:begin,
      s(:def, :initialize,
        s(:args,
          s(:arg, :type),
          s(:arg, :name)),
        s(:begin,
          s(:ivasgn, :@type,
            s(:lvar, :type)),
          s(:ivasgn, :@name,
            s(:lvar, :name)),
          s(:ivasgn, :@len,
            s(:int, 0)),
          s(:ivasgn, :@content,
            s(:send,
              s(:str, ""), :dup)))),
      s(:def, :length,
        s(:args),
        s(:ivar, :@len)),
      s(:def, :insert_at_last,
        s(:args,
          s(:arg, :num),
          s(:arg, :str)),
        s(:begin,
          s(:lvasgn, :newnum,
            s(:send,
              s(:send,
                s(:self), :length), :+,
              s(:lvar, :num))),
          s(:send,
            s(:ivar, :@content), :<<,
            s(:lvar, :str)),
          s(:op_asgn,
            s(:ivasgn, :@len), :+,
            s(:lvar, :num)))),
      s(:def, :to_s,
        s(:args),
        s(:dstr,
          s(:str, "static const "),
          s(:begin,
            s(:ivar, :@type)),
          s(:str, "\n"),
          s(:begin,
            s(:ivar, :@name)),
          s(:str, "["),
          s(:begin,
            s(:ivar, :@len)),
          s(:str, "] = {\n"),
          s(:begin,
            s(:ivar, :@content)),
          s(:str, "};\n"))))),
  s(:class,
    s(:const, nil, :Action), nil,
    s(:begin,
      s(:def, :initialize,
        s(:args,
          s(:arg, :value)),
        s(:ivasgn, :@value,
          s(:lvar, :value))),
      s(:send, nil, :attr_reader,
        s(:sym, :value)),
      s(:def, :hash,
        s(:args),
        s(:send,
          s(:ivar, :@value), :hash)),
      s(:def, :eql?,
        s(:args,
          s(:arg, :other)),
        s(:and,
          s(:send,
            s(:send,
              s(:self), :class), :==,
            s(:send,
              s(:lvar, :other), :class)),
          s(:send,
            s(:ivar, :@value), :==,
            s(:send,
              s(:lvar, :other), :value)))),
      s(:alias,
        s(:sym, :==),
        s(:sym, :eql?)))),
  s(:class,
    s(:const, nil, :Branch), nil,
    s(:begin,
      s(:def, :initialize,
        s(:args,
          s(:arg, :byte_min),
          s(:arg, :byte_max),
          s(:arg, :child_tree)),
        s(:begin,
          s(:ivasgn, :@byte_min,
            s(:lvar, :byte_min)),
          s(:ivasgn, :@byte_max,
            s(:lvar, :byte_max)),
          s(:ivasgn, :@child_tree,
            s(:lvar, :child_tree)),
          s(:ivasgn, :@hash,
            s(:send,
              s(:send,
                s(:send,
                  s(:lvar, :byte_min), :hash), :^,
                s(:send,
                  s(:lvar, :byte_max), :hash)), :^,
              s(:send,
                s(:lvar, :child_tree), :hash))))),
      s(:send, nil, :attr_reader,
        s(:sym, :byte_min),
        s(:sym, :byte_max),
        s(:sym, :child_tree),
        s(:sym, :hash)),
      s(:def, :eql?,
        s(:args,
          s(:arg, :other)),
        s(:and,
          s(:and,
            s(:and,
              s(:and,
                s(:send,
                  s(:send,
                    s(:self), :class), :==,
                  s(:send,
                    s(:lvar, :other), :class)),
                s(:send,
                  s(:ivar, :@hash), :==,
                  s(:send,
                    s(:lvar, :other), :hash))),
              s(:send,
                s(:ivar, :@byte_min), :==,
                s(:send,
                  s(:lvar, :other), :byte_min))),
            s(:send,
              s(:ivar, :@byte_max), :==,
              s(:send,
                s(:lvar, :other), :byte_max))),
          s(:send,
            s(:ivar, :@child_tree), :==,
            s(:send,
              s(:lvar, :other), :child_tree)))),
      s(:alias,
        s(:sym, :==),
        s(:sym, :eql?)))),
  s(:class,
    s(:const, nil, :ActionMap), nil,
    s(:begin,
      s(:defs,
        s(:self), :parse_to_rects,
        s(:args,
          s(:arg, :mapping)),
        s(:begin,
          s(:lvasgn, :rects,
            s(:array)),
          s(:lvasgn, :n,
            s(:int, 0)),
          s(:block,
            s(:send,
              s(:lvar, :mapping), :each),
            s(:args,
              s(:arg, :pat),
              s(:arg, :action)),
            s(:begin,
              s(:lvasgn, :pat,
                s(:send,
                  s(:lvar, :pat), :to_s)),
              s(:if,
                s(:match_with_lvasgn,
                  s(:regexp,
                    s(:str, "\\A\\s*\\(empset\\)\\s*\\z"),
                    s(:regopt)),
                  s(:lvar, :pat)),
                s(:next),
                s(:if,
                  s(:match_with_lvasgn,
                    s(:regexp,
                      s(:str, "\\A\\s*\\(empstr\\)\\s*\\z"),
                      s(:regopt)),
                    s(:lvar, :pat)),
                  s(:begin,
                    s(:send,
                      s(:lvar, :rects), :<<,
                      s(:array,
                        s(:str, ""),
                        s(:str, ""),
                        s(:lvar, :action))),
                    s(:op_asgn,
                      s(:lvasgn, :n), :+,
                      s(:int, 1))),
                  s(:if,
                    s(:send,
                      s(:regexp,
                        s(:str, "\\A\\s*("),
                        s(:begin,
                          s(:const, nil, :HEX2)),
                        s(:str, "+)\\s*\\z"),
                        s(:regopt, :o)), :=~,
                      s(:lvar, :pat)),
                    s(:begin,
                      s(:lvasgn, :hex,
                        s(:send,
                          s(:nth_ref, 1), :upcase)),
                      s(:send,
                        s(:lvar, :rects), :<<,
                        s(:array,
                          s(:lvar, :hex),
                          s(:lvar, :hex),
                          s(:lvar, :action)))),
                    s(:if,
                      s(:send,
                        s(:regexp,
                          s(:str, "\\A\\s*(("),
                          s(:begin,
                            s(:const, nil, :HEX2)),
                          s(:str, "|\\{"),
                          s(:begin,
                            s(:const, nil, :HEX2)),
                          s(:str, "(?:-"),
                          s(:begin,
                            s(:const, nil, :HEX2)),
                          s(:str, ")?(,"),
                          s(:begin,
                            s(:const, nil, :HEX2)),
                          s(:str, "(?:-"),
                          s(:begin,
                            s(:const, nil, :HEX2)),
                          s(:str, ")?)*\\})+(\\s+|\\z))*\\z"),
                          s(:regopt, :o)), :=~,
                        s(:lvar, :pat)),
                      s(:begin,
                        s(:lvasgn, :pat,
                          s(:send,
                            s(:lvar, :pat), :upcase)),
                        s(:block,
                          s(:send,
                            s(:lvar, :pat), :scan,
                            s(:regexp,
                              s(:str, "\\S+"),
                              s(:regopt))),
                          s(:args),
                          s(:begin,
                            s(:lvasgn, :pat1,
                              s(:back_ref, :$&)),
                            s(:lvasgn, :ranges_list,
                              s(:array)),
                            s(:block,
                              s(:send,
                                s(:lvar, :pat1), :scan,
                                s(:regexp,
                                  s(:begin,
                                    s(:const, nil, :HEX2)),
                                  s(:str, "|\\{([^\\}]*)\\}"),
                                  s(:regopt, :o))),
                              s(:args),
                              s(:begin,
                                s(:send,
                                  s(:lvar, :ranges_list), :<<,
                                  s(:array)),
                                s(:if,
                                  s(:send,
                                    s(:nth_ref, 1), :!),
                                  s(:send,
                                    s(:send,
                                      s(:lvar, :ranges_list), :last), :<<,
                                    s(:array,
                                      s(:back_ref, :$&),
                                      s(:back_ref, :$&))),
                                  s(:begin,
                                    s(:lvasgn, :set,
                                      s(:hash)),
                                    s(:block,
                                      s(:send,
                                        s(:nth_ref, 1), :scan,
                                        s(:regexp,
                                          s(:str, "("),
                                          s(:begin,
                                            s(:const, nil, :HEX2)),
                                          s(:str, ")(?:-("),
                                          s(:begin,
                                            s(:const, nil, :HEX2)),
                                          s(:str, "))?"),
                                          s(:regopt, :o))),
                                      s(:args),
                                      s(:if,
                                        s(:send,
                                          s(:nth_ref, 2), :!),
                                        s(:begin,
                                          s(:lvasgn, :c,
                                            s(:send,
                                              s(:nth_ref, 1), :to_i,
                                              s(:int, 16))),
                                          s(:send,
                                            s(:lvar, :set), :[]=,
                                            s(:lvar, :c),
                                            s(:true))),
                                        s(:begin,
                                          s(:lvasgn, :b,
                                            s(:send,
                                              s(:nth_ref, 1), :to_i,
                                              s(:int, 16))),
                                          s(:lvasgn, :e,
                                            s(:send,
                                              s(:nth_ref, 2), :to_i,
                                              s(:int, 16))),
                                          s(:block,
                                            s(:send,
                                              s(:lvar, :b), :upto,
                                              s(:lvar, :e)),
                                            s(:args,
                                              s(:arg, :c)),
                                            s(:send,
                                              s(:lvar, :set), :[]=,
                                              s(:lvar, :c),
                                              s(:true)))))),
                                    s(:lvasgn, :i,
                                      s(:nil)),
                                    s(:block,
                                      s(:send,
                                        s(:int, 0), :upto,
                                        s(:int, 256)),
                                      s(:args,
                                        s(:arg, :j)),
                                      s(:if,
                                        s(:send,
                                          s(:lvar, :set), :[],
                                          s(:lvar, :j)),
                                        s(:begin,
                                          s(:if,
                                            s(:send,
                                              s(:lvar, :i), :!),
                                            s(:lvasgn, :i,
                                              s(:lvar, :j)), nil),
                                          s(:if,
                                            s(:send,
                                              s(:send,
                                                s(:lvar, :set), :[],
                                                s(:send,
                                                  s(:lvar, :j), :+,
                                                  s(:int, 1))), :!),
                                            s(:begin,
                                              s(:send,
                                                s(:send,
                                                  s(:lvar, :ranges_list), :last), :<<,
                                                s(:array,
                                                  s(:send,
                                                    s(:str, "%02X"), :%,
                                                    s(:lvar, :i)),
                                                  s(:send,
                                                    s(:str, "%02X"), :%,
                                                    s(:lvar, :j)))),
                                              s(:lvasgn, :i,
                                                s(:nil))), nil)), nil)))))),
                            s(:lvasgn, :first_ranges,
                              s(:send,
                                s(:lvar, :ranges_list), :shift)),
                            s(:block,
                              s(:send,
                                s(:send,
                                  s(:lvar, :first_ranges), :product,
                                  s(:splat,
                                    s(:lvar, :ranges_list))), :each),
                              s(:args,
                                s(:arg, :range_list)),
                              s(:begin,
                                s(:lvasgn, :min,
                                  s(:send,
                                    s(:block,
                                      s(:send,
                                        s(:lvar, :range_list), :map),
                                      s(:args,
                                        s(:arg, :x),
                                        s(:arg, :y)),
                                      s(:lvar, :x)), :join)),
                                s(:lvasgn, :max,
                                  s(:send,
                                    s(:block,
                                      s(:send,
                                        s(:lvar, :range_list), :map),
                                      s(:args,
                                        s(:arg, :x),
                                        s(:arg, :y)),
                                      s(:lvar, :y)), :join)),
                                s(:send,
                                  s(:lvar, :rects), :<<,
                                  s(:array,
                                    s(:lvar, :min),
                                    s(:lvar, :max),
                                    s(:lvar, :action)))))))),
                      s(:send, nil, :raise,
                        s(:const, nil, :ArgumentError),
                        s(:dstr,
                          s(:str, "invalid pattern: "),
                          s(:begin,
                            s(:send,
                              s(:lvar, :pat), :inspect)))))))))),
          s(:lvar, :rects))),
      s(:defs,
        s(:self), :unambiguous_action,
        s(:args,
          s(:arg, :actions0)),
        s(:begin,
          s(:lvasgn, :actions,
            s(:send,
              s(:lvar, :actions0), :uniq)),
          s(:if,
            s(:send,
              s(:send,
                s(:lvar, :actions), :length), :==,
              s(:int, 1)),
            s(:send,
              s(:lvar, :actions), :[],
              s(:int, 0)),
            s(:begin,
              s(:send,
                s(:lvar, :actions), :delete,
                s(:sym, :nomap0)),
              s(:if,
                s(:send,
                  s(:send,
                    s(:lvar, :actions), :length), :==,
                  s(:int, 1)),
                s(:send,
                  s(:lvar, :actions), :[],
                  s(:int, 0)),
                s(:send, nil, :raise,
                  s(:const, nil, :ArgumentError),
                  s(:dstr,
                    s(:str, "ambiguous actions: "),
                    s(:begin,
                      s(:send,
                        s(:lvar, :actions0), :inspect))))))))),
      s(:defs,
        s(:self), :build_tree,
        s(:args,
          s(:arg, :rects)),
        s(:block,
          s(:send, nil, :expand,
            s(:lvar, :rects)),
          s(:args,
            s(:arg, :prefix),
            s(:arg, :actions)),
          s(:send, nil, :unambiguous_action,
            s(:lvar, :actions)))),
      s(:defs,
        s(:self), :parse,
        s(:args,
          s(:arg, :mapping)),
        s(:begin,
          s(:lvasgn, :rects,
            s(:send, nil, :parse_to_rects,
              s(:lvar, :mapping))),
          s(:lvasgn, :tree,
            s(:send, nil, :build_tree,
              s(:lvar, :rects))),
          s(:send,
            s(:self), :new,
            s(:lvar, :tree)))),
      s(:defs,
        s(:self), :merge_rects,
        s(:args,
          s(:restarg, :rects_list)),
        s(:begin,
          s(:if,
            s(:send,
              s(:send,
                s(:lvar, :rects_list), :length), :<,
              s(:int, 2)),
            s(:send, nil, :raise,
              s(:const, nil, :ArgumentError),
              s(:str, "not enough arguments")), nil),
          s(:lvasgn, :all_rects,
            s(:array)),
          s(:block,
            s(:send,
              s(:lvar, :rects_list), :each_with_index),
            s(:args,
              s(:arg, :rects),
              s(:arg, :i)),
            s(:send,
              s(:lvar, :all_rects), :concat,
              s(:block,
                s(:send,
                  s(:lvar, :rects), :map),
                s(:args,
                  s(:arg, :min),
                  s(:arg, :max),
                  s(:arg, :action)),
                s(:array,
                  s(:lvar, :min),
                  s(:lvar, :max),
                  s(:array,
                    s(:lvar, :i),
                    s(:lvar, :action)))))),
          s(:lvasgn, :tree,
            s(:block,
              s(:send, nil, :expand,
                s(:lvar, :all_rects)),
              s(:args,
                s(:arg, :prefix),
                s(:arg, :actions)),
              s(:begin,
                s(:lvasgn, :args,
                  s(:block,
                    s(:send,
                      s(:const, nil, :Array), :new,
                      s(:send,
                        s(:lvar, :rects_list), :length)),
                    s(:args),
                    s(:array))),
                s(:block,
                  s(:send,
                    s(:lvar, :actions), :each),
                  s(:args,
                    s(:arg, :i),
                    s(:arg, :action)),
                  s(:send,
                    s(:send,
                      s(:lvar, :args), :[],
                      s(:lvar, :i)), :<<,
                    s(:lvar, :action))),
                s(:yield,
                  s(:lvar, :prefix),
                  s(:splat,
                    s(:lvar, :args)))))),
          s(:send,
            s(:self), :new,
            s(:lvar, :tree)))),
      s(:defs,
        s(:self), :merge,
        s(:args,
          s(:restarg, :mappings),
          s(:blockarg, :block)),
        s(:send, nil, :merge_rects,
          s(:splat,
            s(:block,
              s(:send,
                s(:lvar, :mappings), :map),
              s(:args,
                s(:arg, :m)),
              s(:send, nil, :parse_to_rects,
                s(:lvar, :m)))),
          s(:block_pass,
            s(:lvar, :block)))),
      s(:defs,
        s(:self), :merge2,
        s(:args,
          s(:arg, :map1),
          s(:arg, :map2),
          s(:blockarg, :block)),
        s(:begin,
          s(:lvasgn, :rects1,
            s(:send, nil, :parse_to_rects,
              s(:lvar, :map1))),
          s(:lvasgn, :rects2,
            s(:send, nil, :parse_to_rects,
              s(:lvar, :map2))),
          s(:lvasgn, :actions,
            s(:array)),
          s(:lvasgn, :all_rects,
            s(:array)),
          s(:block,
            s(:send,
              s(:lvar, :rects1), :each),
            s(:args,
              s(:arg, :rect)),
            s(:begin,
              s(:masgn,
                s(:mlhs,
                  s(:lvasgn, :min),
                  s(:lvasgn, :max),
                  s(:lvasgn, :action)),
                s(:lvar, :rect)),
              s(:send,
                s(:lvar, :rect), :[]=,
                s(:int, 2),
                s(:send,
                  s(:lvar, :actions), :length)),
              s(:send,
                s(:lvar, :actions), :<<,
                s(:lvar, :action)),
              s(:send,
                s(:lvar, :all_rects), :<<,
                s(:lvar, :rect)))),
          s(:lvasgn, :boundary,
            s(:send,
              s(:lvar, :actions), :length)),
          s(:block,
            s(:send,
              s(:lvar, :rects2), :each),
            s(:args,
              s(:arg, :rect)),
            s(:begin,
              s(:masgn,
                s(:mlhs,
                  s(:lvasgn, :min),
                  s(:lvasgn, :max),
                  s(:lvasgn, :action)),
                s(:lvar, :rect)),
              s(:send,
                s(:lvar, :rect), :[]=,
                s(:int, 2),
                s(:send,
                  s(:lvar, :actions), :length)),
              s(:send,
                s(:lvar, :actions), :<<,
                s(:lvar, :action)),
              s(:send,
                s(:lvar, :all_rects), :<<,
                s(:lvar, :rect)))),
          s(:lvasgn, :tree,
            s(:block,
              s(:send, nil, :expand,
                s(:lvar, :all_rects)),
              s(:args,
                s(:arg, :prefix),
                s(:arg, :as0)),
              s(:begin,
                s(:lvasgn, :as1,
                  s(:array)),
                s(:lvasgn, :as2,
                  s(:array)),
                s(:block,
                  s(:send,
                    s(:lvar, :as0), :each),
                  s(:args,
                    s(:arg, :i)),
                  s(:if,
                    s(:send,
                      s(:lvar, :i), :<,
                      s(:lvar, :boundary)),
                    s(:send,
                      s(:lvar, :as1), :<<,
                      s(:send,
                        s(:lvar, :actions), :[],
                        s(:lvar, :i))),
                    s(:send,
                      s(:lvar, :as2), :<<,
                      s(:send,
                        s(:lvar, :actions), :[],
                        s(:lvar, :i))))),
                s(:yield,
                  s(:lvar, :prefix),
                  s(:lvar, :as1),
                  s(:lvar, :as2))))),
          s(:send,
            s(:self), :new,
            s(:lvar, :tree)))),
      s(:defs,
        s(:self), :expand,
        s(:args,
          s(:arg, :rects),
          s(:blockarg, :block)),
        s(:begin,
          s(:lvasgn, :singleton_rects,
            s(:array)),
          s(:lvasgn, :region_rects,
            s(:array)),
          s(:block,
            s(:send,
              s(:lvar, :rects), :each),
            s(:args,
              s(:arg, :rect)),
            s(:begin,
              s(:masgn,
                s(:mlhs,
                  s(:lvasgn, :min),
                  s(:lvasgn, :max),
                  s(:lvasgn, :action)),
                s(:lvar, :rect)),
              s(:if,
                s(:send,
                  s(:lvar, :min), :==,
                  s(:lvar, :max)),
                s(:send,
                  s(:lvar, :singleton_rects), :<<,
                  s(:lvar, :rect)),
                s(:send,
                  s(:lvar, :region_rects), :<<,
                  s(:lvar, :rect))))),
          s(:ivasgn, :@singleton_rects,
            s(:block,
              s(:send,
                s(:lvar, :singleton_rects), :sort_by),
              s(:args,
                s(:arg, :min),
                s(:arg, :max),
                s(:arg, :action)),
              s(:lvar, :min))),
          s(:send,
            s(:ivar, :@singleton_rects), :reverse!),
          s(:lvasgn, :ret,
            s(:send, nil, :expand_rec,
              s(:str, ""),
              s(:lvar, :region_rects),
              s(:block_pass,
                s(:lvar, :block)))),
          s(:ivasgn, :@singleton_rects,
            s(:nil)),
          s(:lvar, :ret))),
      s(:casgn, nil, :TMPHASH,
        s(:hash)),
      s(:defs,
        s(:self), :expand_rec,
        s(:args,
          s(:arg, :prefix),
          s(:arg, :region_rects),
          s(:blockarg, :block)),
        s(:begin,
          s(:if,
            s(:and,
              s(:send,
                s(:lvar, :region_rects), :empty?),
              s(:send,
                s(:begin,
                  s(:and,
                    s(:begin,
                      s(:lvasgn, :s_rect,
                        s(:send,
                          s(:ivar, :@singleton_rects), :last))),
                    s(:send,
                      s(:send,
                        s(:lvar, :s_rect), :[],
                        s(:int, 0)), :start_with?,
                      s(:lvar, :prefix)))), :!)),
            s(:return,
              s(:lvar, :region_rects)), nil),
          s(:if,
            s(:if,
              s(:send,
                s(:lvar, :region_rects), :empty?),
              s(:send,
                s(:send,
                  s(:send,
                    s(:lvar, :s_rect), :[],
                    s(:int, 0)), :length), :==,
                s(:send,
                  s(:lvar, :prefix), :length)),
              s(:send,
                s(:send,
                  s(:send,
                    s(:lvar, :region_rects), :[],
                    s(:int, 0)), :[],
                  s(:int, 0)), :empty?)),
            s(:begin,
              s(:lvasgn, :h,
                s(:const, nil, :TMPHASH)),
              s(:while,
                s(:and,
                  s(:begin,
                    s(:lvasgn, :s_rect,
                      s(:send,
                        s(:ivar, :@singleton_rects), :last))),
                  s(:send,
                    s(:send,
                      s(:lvar, :s_rect), :[],
                      s(:int, 0)), :start_with?,
                    s(:lvar, :prefix))),
                s(:begin,
                  s(:masgn,
                    s(:mlhs,
                      s(:lvasgn, :min),
                      s(:lvasgn, :max),
                      s(:lvasgn, :action)),
                    s(:send,
                      s(:ivar, :@singleton_rects), :pop)),
                  s(:if,
                    s(:send,
                      s(:send,
                        s(:lvar, :min), :length), :!=,
                      s(:send,
                        s(:lvar, :prefix), :length)),
                    s(:send, nil, :raise,
                      s(:const, nil, :ArgumentError),
                      s(:dstr,
                        s(:str, "ambiguous pattern: "),
                        s(:begin,
                          s(:lvar, :prefix)))), nil),
                  s(:send,
                    s(:lvar, :h), :[]=,
                    s(:lvar, :action),
                    s(:true)))),
              s(:block,
                s(:send,
                  s(:lvar, :region_rects), :each),
                s(:args,
                  s(:arg, :min),
                  s(:arg, :max),
                  s(:arg, :action)),
                s(:begin,
                  s(:if,
                    s(:send,
                      s(:send,
                        s(:lvar, :min), :empty?), :!),
                    s(:send, nil, :raise,
                      s(:const, nil, :ArgumentError),
                      s(:dstr,
                        s(:str, "ambiguous pattern: "),
                        s(:begin,
                          s(:lvar, :prefix)))), nil),
                  s(:send,
                    s(:lvar, :h), :[]=,
                    s(:lvar, :action),
                    s(:true)))),
              s(:lvasgn, :tree,
                s(:send,
                  s(:const, nil, :Action), :new,
                  s(:send,
                    s(:lvar, :block), :call,
                    s(:lvar, :prefix),
                    s(:send,
                      s(:lvar, :h), :keys)))),
              s(:send,
                s(:lvar, :h), :clear)),
            s(:begin,
              s(:lvasgn, :tree,
                s(:array)),
              s(:block,
                s(:send, nil, :each_firstbyte_range,
                  s(:lvar, :prefix),
                  s(:lvar, :region_rects)),
                s(:args,
                  s(:arg, :byte_min),
                  s(:arg, :byte_max),
                  s(:arg, :r_rects2)),
                s(:begin,
                  s(:if,
                    s(:send,
                      s(:lvar, :byte_min), :==,
                      s(:lvar, :byte_max)),
                    s(:lvasgn, :prefix2,
                      s(:send,
                        s(:lvar, :prefix), :+,
                        s(:send,
                          s(:str, "%02X"), :%,
                          s(:lvar, :byte_min)))),
                    s(:lvasgn, :prefix2,
                      s(:send,
                        s(:lvar, :prefix), :+,
                        s(:send,
                          s(:str, "{%02X-%02X}"), :%,
                          s(:array,
                            s(:lvar, :byte_min),
                            s(:lvar, :byte_max)))))),
                  s(:lvasgn, :child_tree,
                    s(:send, nil, :expand_rec,
                      s(:lvar, :prefix2),
                      s(:lvar, :r_rects2),
                      s(:block_pass,
                        s(:lvar, :block)))),
                  s(:send,
                    s(:lvar, :tree), :<<,
                    s(:send,
                      s(:const, nil, :Branch), :new,
                      s(:lvar, :byte_min),
                      s(:lvar, :byte_max),
                      s(:lvar, :child_tree))))))),
          s(:return,
            s(:lvar, :tree)))),
      s(:defs,
        s(:self), :each_firstbyte_range,
        s(:args,
          s(:arg, :prefix),
          s(:arg, :region_rects)),
        s(:begin,
          s(:lvasgn, :index_from,
            s(:const, nil, :TMPHASH)),
          s(:lvasgn, :region_ary,
            s(:array)),
          s(:block,
            s(:send,
              s(:lvar, :region_rects), :each),
            s(:args,
              s(:arg, :min),
              s(:arg, :max),
              s(:arg, :action)),
            s(:begin,
              s(:if,
                s(:send,
                  s(:lvar, :min), :empty?),
                s(:send, nil, :raise,
                  s(:const, nil, :ArgumentError),
                  s(:dstr,
                    s(:str, "ambiguous pattern: "),
                    s(:begin,
                      s(:lvar, :prefix)))), nil),
              s(:lvasgn, :min_firstbyte,
                s(:send,
                  s(:send,
                    s(:lvar, :min), :[],
                    s(:int, 0),
                    s(:int, 2)), :to_i,
                  s(:int, 16))),
              s(:lvasgn, :min_rest,
                s(:send,
                  s(:lvar, :min), :[],
                  s(:irange,
                    s(:int, 2),
                    s(:int, -1)))),
              s(:lvasgn, :max_firstbyte,
                s(:send,
                  s(:send,
                    s(:lvar, :max), :[],
                    s(:int, 0),
                    s(:int, 2)), :to_i,
                  s(:int, 16))),
              s(:lvasgn, :max_rest,
                s(:send,
                  s(:lvar, :max), :[],
                  s(:irange,
                    s(:int, 2),
                    s(:int, -1)))),
              s(:send,
                s(:lvar, :region_ary), :<<,
                s(:array,
                  s(:lvar, :min_firstbyte),
                  s(:lvar, :max_firstbyte),
                  s(:array,
                    s(:lvar, :min_rest),
                    s(:lvar, :max_rest),
                    s(:lvar, :action)))),
              s(:send,
                s(:lvar, :index_from), :[]=,
                s(:lvar, :min_firstbyte),
                s(:true)),
              s(:send,
                s(:lvar, :index_from), :[]=,
                s(:send,
                  s(:lvar, :max_firstbyte), :+,
                  s(:int, 1)),
                s(:true)))),
          s(:lvasgn, :byte_from,
            s(:send,
              s(:const, nil, :Array), :new,
              s(:send,
                s(:lvar, :index_from), :size))),
          s(:lvasgn, :bytes,
            s(:send,
              s(:lvar, :index_from), :keys)),
          s(:send,
            s(:lvar, :bytes), :sort!),
          s(:send,
            s(:lvar, :bytes), :reverse!),
          s(:block,
            s(:send,
              s(:lvar, :bytes), :each_with_index),
            s(:args,
              s(:arg, :byte),
              s(:arg, :i)),
            s(:begin,
              s(:send,
                s(:lvar, :index_from), :[]=,
                s(:lvar, :byte),
                s(:lvar, :i)),
              s(:send,
                s(:lvar, :byte_from), :[]=,
                s(:lvar, :i),
                s(:lvar, :byte)))),
          s(:lvasgn, :region_rects_ary,
            s(:block,
              s(:send,
                s(:const, nil, :Array), :new,
                s(:send,
                  s(:lvar, :index_from), :size)),
              s(:args),
              s(:array))),
          s(:block,
            s(:send,
              s(:lvar, :region_ary), :each),
            s(:args,
              s(:arg, :min_firstbyte),
              s(:arg, :max_firstbyte),
              s(:arg, :rest_elt)),
            s(:block,
              s(:send,
                s(:send,
                  s(:lvar, :index_from), :[],
                  s(:lvar, :min_firstbyte)), :downto,
                s(:send,
                  s(:send,
                    s(:lvar, :index_from), :[],
                    s(:send,
                      s(:lvar, :max_firstbyte), :+,
                      s(:int, 1))), :+,
                  s(:int, 1))),
              s(:args,
                s(:arg, :i)),
              s(:send,
                s(:send,
                  s(:lvar, :region_rects_ary), :[],
                  s(:lvar, :i)), :<<,
                s(:lvar, :rest_elt)))),
          s(:send,
            s(:lvar, :index_from), :clear),
          s(:lvasgn, :r_rects,
            s(:send,
              s(:lvar, :region_rects_ary), :pop)),
          s(:lvasgn, :region_byte,
            s(:send,
              s(:lvar, :byte_from), :pop)),
          s(:lvasgn, :prev_r_start,
            s(:lvar, :region_byte)),
          s(:lvasgn, :prev_r_rects,
            s(:array)),
          s(:while,
            s(:and,
              s(:and,
                s(:lvar, :r_rects),
                s(:begin,
                  s(:lvasgn, :s_rect,
                    s(:send,
                      s(:ivar, :@singleton_rects), :last)))),
              s(:send,
                s(:begin,
                  s(:lvasgn, :seq,
                    s(:send,
                      s(:lvar, :s_rect), :[],
                      s(:int, 0)))), :start_with?,
                s(:lvar, :prefix))),
            s(:begin,
              s(:lvasgn, :singleton_byte,
                s(:send,
                  s(:send,
                    s(:lvar, :seq), :[],
                    s(:send,
                      s(:lvar, :prefix), :length),
                    s(:int, 2)), :to_i,
                  s(:int, 16))),
              s(:lvasgn, :min_byte,
                s(:if,
                  s(:send,
                    s(:lvar, :singleton_byte), :<,
                    s(:lvar, :region_byte)),
                  s(:lvar, :singleton_byte),
                  s(:lvar, :region_byte))),
              s(:if,
                s(:and,
                  s(:send,
                    s(:lvar, :prev_r_start), :<,
                    s(:lvar, :min_byte)),
                  s(:send,
                    s(:send,
                      s(:lvar, :prev_r_rects), :empty?), :!)),
                s(:yield,
                  s(:lvar, :prev_r_start),
                  s(:send,
                    s(:lvar, :min_byte), :-,
                    s(:int, 1)),
                  s(:lvar, :prev_r_rects)), nil),
              s(:if,
                s(:send,
                  s(:lvar, :region_byte), :<,
                  s(:lvar, :singleton_byte)),
                s(:begin,
                  s(:lvasgn, :prev_r_start,
                    s(:lvar, :region_byte)),
                  s(:lvasgn, :prev_r_rects,
                    s(:lvar, :r_rects)),
                  s(:lvasgn, :r_rects,
                    s(:send,
                      s(:lvar, :region_rects_ary), :pop)),
                  s(:lvasgn, :region_byte,
                    s(:send,
                      s(:lvar, :byte_from), :pop))),
                s(:if,
                  s(:send,
                    s(:lvar, :region_byte), :>,
                    s(:lvar, :singleton_byte)),
                  s(:begin,
                    s(:yield,
                      s(:lvar, :singleton_byte),
                      s(:lvar, :singleton_byte),
                      s(:lvar, :prev_r_rects)),
                    s(:lvasgn, :prev_r_start,
                      s(:send,
                        s(:lvar, :singleton_byte), :+,
                        s(:int, 1)))),
                  s(:begin,
                    s(:lvasgn, :prev_r_start,
                      s(:send,
                        s(:lvar, :region_byte), :+,
                        s(:int, 1))),
                    s(:lvasgn, :prev_r_rects,
                      s(:lvar, :r_rects)),
                    s(:lvasgn, :r_rects,
                      s(:send,
                        s(:lvar, :region_rects_ary), :pop)),
                    s(:lvasgn, :region_byte,
                      s(:send,
                        s(:lvar, :byte_from), :pop)),
                    s(:yield,
                      s(:lvar, :singleton_byte),
                      s(:lvar, :singleton_byte),
                      s(:lvar, :prev_r_rects))))))),
          s(:while,
            s(:lvar, :r_rects),
            s(:begin,
              s(:if,
                s(:and,
                  s(:send,
                    s(:lvar, :prev_r_start), :<,
                    s(:lvar, :region_byte)),
                  s(:send,
                    s(:send,
                      s(:lvar, :prev_r_rects), :empty?), :!)),
                s(:yield,
                  s(:lvar, :prev_r_start),
                  s(:send,
                    s(:lvar, :region_byte), :-,
                    s(:int, 1)),
                  s(:lvar, :prev_r_rects)), nil),
              s(:lvasgn, :prev_r_start,
                s(:lvar, :region_byte)),
              s(:lvasgn, :prev_r_rects,
                s(:lvar, :r_rects)),
              s(:lvasgn, :r_rects,
                s(:send,
                  s(:lvar, :region_rects_ary), :pop)),
              s(:lvasgn, :region_byte,
                s(:send,
                  s(:lvar, :byte_from), :pop)))),
          s(:while,
            s(:and,
              s(:begin,
                s(:lvasgn, :s_rect,
                  s(:send,
                    s(:ivar, :@singleton_rects), :last))),
              s(:send,
                s(:begin,
                  s(:lvasgn, :seq,
                    s(:send,
                      s(:lvar, :s_rect), :[],
                      s(:int, 0)))), :start_with?,
                s(:lvar, :prefix))),
            s(:begin,
              s(:lvasgn, :singleton_byte,
                s(:send,
                  s(:send,
                    s(:lvar, :seq), :[],
                    s(:send,
                      s(:lvar, :prefix), :length),
                    s(:int, 2)), :to_i,
                  s(:int, 16))),
              s(:yield,
                s(:lvar, :singleton_byte),
                s(:lvar, :singleton_byte),
                s(:array)))))),
      s(:def, :initialize,
        s(:args,
          s(:arg, :tree)),
        s(:ivasgn, :@tree,
          s(:lvar, :tree))),
      s(:def, :inspect,
        s(:args),
        s(:send,
          s(:send,
            s(:dstr,
              s(:str, "#<"),
              s(:begin,
                s(:send,
                  s(:self), :class)),
              s(:str, ":")), :+,
            s(:send,
              s(:ivar, :@tree), :inspect)), :+,
          s(:str, ">"))),
      s(:def, :max_input_length_rec,
        s(:args,
          s(:arg, :tree)),
        s(:case,
          s(:lvar, :tree),
          s(:when,
            s(:const, nil, :Action),
            s(:int, 0)),
          s(:send,
            s(:send,
              s(:block,
                s(:send,
                  s(:lvar, :tree), :map),
                s(:args,
                  s(:arg, :branch)),
                s(:send, nil, :max_input_length_rec,
                  s(:send,
                    s(:lvar, :branch), :child_tree))), :max), :+,
            s(:int, 1)))),
      s(:def, :max_input_length,
        s(:args),
        s(:send, nil, :max_input_length_rec,
          s(:ivar, :@tree))),
      s(:def, :empty_action,
        s(:args),
        s(:if,
          s(:send,
            s(:ivar, :@tree), :kind_of?,
            s(:const, nil, :Action)),
          s(:send,
            s(:ivar, :@tree), :value),
          s(:nil))),
      s(:casgn, nil, :OffsetsMemo,
        s(:hash)),
      s(:casgn, nil, :InfosMemo,
        s(:hash)),
      s(:def, :format_offsets,
        s(:args,
          s(:arg, :min),
          s(:arg, :max),
          s(:arg, :offsets)),
        s(:begin,
          s(:lvasgn, :offsets,
            s(:send,
              s(:lvar, :offsets), :[],
              s(:irange,
                s(:lvar, :min),
                s(:lvar, :max)))),
          s(:lvasgn, :code,
            s(:send,
              s(:str, "%d, %d,\n"), :%,
              s(:array,
                s(:lvar, :min),
                s(:lvar, :max)))),
          s(:block,
            s(:send,
              s(:int, 0), :step,
              s(:send,
                s(:send,
                  s(:lvar, :offsets), :length), :-,
                s(:int, 1)),
              s(:int, 16)),
            s(:args,
              s(:arg, :i)),
            s(:begin,
              s(:send,
                s(:lvar, :code), :<<,
                s(:str, "    ")),
              s(:send,
                s(:lvar, :code), :<<,
                s(:send,
                  s(:block,
                    s(:send,
                      s(:send,
                        s(:lvar, :offsets), :[],
                        s(:lvar, :i),
                        s(:int, 8)), :map),
                    s(:args,
                      s(:arg, :off)),
                    s(:send,
                      s(:str, "%3d,"), :%,
                      s(:send,
                        s(:lvar, :off), :to_s))), :join,
                  s(:str, ""))),
              s(:if,
                s(:send,
                  s(:send,
                    s(:lvar, :i), :+,
                    s(:int, 8)), :<,
                  s(:send,
                    s(:lvar, :offsets), :length)),
                s(:begin,
                  s(:send,
                    s(:lvar, :code), :<<,
                    s(:str, "  ")),
                  s(:send,
                    s(:lvar, :code), :<<,
                    s(:send,
                      s(:block,
                        s(:send,
                          s(:send,
                            s(:lvar, :offsets), :[],
                            s(:send,
                              s(:lvar, :i), :+,
                              s(:int, 8)),
                            s(:int, 8)), :map),
                        s(:args,
                          s(:arg, :off)),
                        s(:send,
                          s(:str, "%3d,"), :%,
                          s(:send,
                            s(:lvar, :off), :to_s))), :join,
                      s(:str, "")))), nil),
              s(:send,
                s(:lvar, :code), :<<,
                s(:str, "\n")))),
          s(:lvar, :code))),
      s(:casgn, nil, :UsedName,
        s(:hash)),
      s(:casgn, nil, :StrMemo,
        s(:hash)),
      s(:def, :str_name,
        s(:args,
          s(:arg, :bytes)),
        s(:begin,
          s(:lvasgn, :size,
            s(:send,
              s(:ivar, :@bytes_code), :length)),
          s(:lvasgn, :rawbytes,
            s(:send,
              s(:array,
                s(:lvar, :bytes)), :pack,
              s(:str, "H*"))),
          s(:lvasgn, :n,
            s(:nil)),
          s(:if,
            s(:and,
              s(:and,
                s(:send,
                  s(:lvar, :n), :!),
                s(:send,
                  s(:send,
                    s(:begin,
                      s(:lvasgn, :suf,
                        s(:send,
                          s(:lvar, :rawbytes), :gsub,
                          s(:regexp,
                            s(:str, "[^A-Za-z0-9_]"),
                            s(:regopt)),
                          s(:str, "")))), :empty?), :!)),
              s(:send,
                s(:send,
                  s(:const, nil, :UsedName), :[],
                  s(:lvasgn, :nn,
                    s(:send,
                      s(:str, "str1_"), :+,
                      s(:lvar, :suf)))), :!)),
            s(:lvasgn, :n,
              s(:lvar, :nn)), nil),
          s(:if,
            s(:and,
              s(:send,
                s(:lvar, :n), :!),
              s(:send,
                s(:send,
                  s(:const, nil, :UsedName), :[],
                  s(:lvasgn, :nn,
                    s(:send,
                      s(:str, "str1_"), :+,
                      s(:lvar, :bytes)))), :!)),
            s(:lvasgn, :n,
              s(:lvar, :nn)), nil),
          s(:or_asgn,
            s(:lvasgn, :n),
            s(:dstr,
              s(:str, "str1s_"),
              s(:begin,
                s(:lvar, :size)))),
          s(:send,
            s(:const, nil, :StrMemo), :[]=,
            s(:lvar, :bytes),
            s(:lvar, :n)),
          s(:send,
            s(:const, nil, :UsedName), :[]=,
            s(:lvar, :n),
            s(:true)),
          s(:lvar, :n))),
      s(:def, :gen_str,
        s(:args,
          s(:arg, :bytes)),
        s(:if,
          s(:lvasgn, :n,
            s(:send,
              s(:const, nil, :StrMemo), :[],
              s(:lvar, :bytes))),
          s(:lvar, :n),
          s(:begin,
            s(:lvasgn, :len,
              s(:send,
                s(:send,
                  s(:lvar, :bytes), :length), :/,
                s(:int, 2))),
            s(:lvasgn, :size,
              s(:send,
                s(:ivar, :@bytes_code), :length)),
            s(:lvasgn, :n,
              s(:send, nil, :str_name,
                s(:lvar, :bytes))),
            s(:send,
              s(:ivar, :@bytes_code), :insert_at_last,
              s(:send,
                s(:int, 1), :+,
                s(:lvar, :len)),
              s(:send,
                s(:send,
                  s(:send,
                    s(:dstr,
                      s(:str, "#define "),
                      s(:begin,
                        s(:lvar, :n)),
                      s(:str, " makeSTR1("),
                      s(:begin,
                        s(:lvar, :size)),
                      s(:str, ")\n")), :+,
                    s(:dstr,
                      s(:str, "    makeSTR1LEN("),
                      s(:begin,
                        s(:lvar, :len)),
                      s(:str, "),"))), :+,
                  s(:send,
                    s(:lvar, :bytes), :gsub,
                    s(:regexp,
                      s(:str, ".."),
                      s(:regopt)),
                    s(:str, " 0x\\&,"))), :+,
                s(:str, "\n\n"))),
            s(:lvar, :n)))),
      s(:def, :generate_info,
        s(:args,
          s(:arg, :info)),
        s(:case,
          s(:lvar, :info),
          s(:when,
            s(:sym, :nomap),
            s(:sym, :nomap0),
            s(:str, "NOMAP")),
          s(:when,
            s(:sym, :undef),
            s(:str, "UNDEF")),
          s(:when,
            s(:sym, :invalid),
            s(:str, "INVALID")),
          s(:when,
            s(:sym, :func_ii),
            s(:str, "FUNii")),
          s(:when,
            s(:sym, :func_si),
            s(:str, "FUNsi")),
          s(:when,
            s(:sym, :func_io),
            s(:str, "FUNio")),
          s(:when,
            s(:sym, :func_so),
            s(:str, "FUNso")),
          s(:when,
            s(:regexp,
              s(:str, "\\A("),
              s(:begin,
                s(:const, nil, :HEX2)),
              s(:str, ")\\z"),
              s(:regopt, :o)),
            s(:dstr,
              s(:str, "o1(0x"),
              s(:nth_ref, 1),
              s(:str, ")"))),
          s(:when,
            s(:regexp,
              s(:str, "\\A("),
              s(:begin,
                s(:const, nil, :HEX2)),
              s(:str, ")("),
              s(:begin,
                s(:const, nil, :HEX2)),
              s(:str, ")\\z"),
              s(:regopt, :o)),
            s(:dstr,
              s(:str, "o2(0x"),
              s(:nth_ref, 1),
              s(:str, ",0x"),
              s(:nth_ref, 2),
              s(:str, ")"))),
          s(:when,
            s(:regexp,
              s(:str, "\\A("),
              s(:begin,
                s(:const, nil, :HEX2)),
              s(:str, ")("),
              s(:begin,
                s(:const, nil, :HEX2)),
              s(:str, ")("),
              s(:begin,
                s(:const, nil, :HEX2)),
              s(:str, ")\\z"),
              s(:regopt, :o)),
            s(:dstr,
              s(:str, "o3(0x"),
              s(:nth_ref, 1),
              s(:str, ",0x"),
              s(:nth_ref, 2),
              s(:str, ",0x"),
              s(:nth_ref, 3),
              s(:str, ")"))),
          s(:when,
            s(:regexp,
              s(:str, "funsio\\((\\d+)\\)"),
              s(:regopt)),
            s(:dstr,
              s(:str, "funsio("),
              s(:begin,
                s(:nth_ref, 1)),
              s(:str, ")"))),
          s(:when,
            s(:regexp,
              s(:str, "\\A("),
              s(:begin,
                s(:const, nil, :HEX2)),
              s(:str, ")(3[0-9])("),
              s(:begin,
                s(:const, nil, :HEX2)),
              s(:str, ")(3[0-9])\\z"),
              s(:regopt, :o)),
            s(:dstr,
              s(:str, "g4(0x"),
              s(:nth_ref, 1),
              s(:str, ",0x"),
              s(:nth_ref, 2),
              s(:str, ",0x"),
              s(:nth_ref, 3),
              s(:str, ",0x"),
              s(:nth_ref, 4),
              s(:str, ")"))),
          s(:when,
            s(:regexp,
              s(:str, "\\A(f[0-7])("),
              s(:begin,
                s(:const, nil, :HEX2)),
              s(:str, ")("),
              s(:begin,
                s(:const, nil, :HEX2)),
              s(:str, ")("),
              s(:begin,
                s(:const, nil, :HEX2)),
              s(:str, ")\\z"),
              s(:regopt, :o)),
            s(:dstr,
              s(:str, "o4(0x"),
              s(:nth_ref, 1),
              s(:str, ",0x"),
              s(:nth_ref, 2),
              s(:str, ",0x"),
              s(:nth_ref, 3),
              s(:str, ",0x"),
              s(:nth_ref, 4),
              s(:str, ")"))),
          s(:when,
            s(:regexp,
              s(:str, "\\A("),
              s(:begin,
                s(:const, nil, :HEX2)),
              s(:str, "){4,259}\\z"),
              s(:regopt, :o)),
            s(:send, nil, :gen_str,
              s(:send,
                s(:lvar, :info), :upcase))),
          s(:when,
            s(:regexp,
              s(:str, "\\A/\\*BYTE_LOOKUP\\*/"),
              s(:regopt)),
            s(:send,
              s(:back_ref, :$'), :to_s)),
          s(:send, nil, :raise,
            s(:dstr,
              s(:str, "unexpected action: "),
              s(:begin,
                s(:send,
                  s(:lvar, :info), :inspect)))))),
      s(:def, :format_infos,
        s(:args,
          s(:arg, :infos)),
        s(:begin,
          s(:lvasgn, :infos,
            s(:block,
              s(:send,
                s(:lvar, :infos), :map),
              s(:args,
                s(:arg, :info)),
              s(:send, nil, :generate_info,
                s(:lvar, :info)))),
          s(:lvasgn, :maxlen,
            s(:send,
              s(:block,
                s(:send,
                  s(:lvar, :infos), :map),
                s(:args,
                  s(:arg, :info)),
                s(:send,
                  s(:lvar, :info), :length)), :max)),
          s(:lvasgn, :columns,
            s(:if,
              s(:send,
                s(:lvar, :maxlen), :<=,
                s(:int, 16)),
              s(:int, 4),
              s(:int, 2))),
          s(:lvasgn, :code,
            s(:send,
              s(:str, ""), :dup)),
          s(:block,
            s(:send,
              s(:int, 0), :step,
              s(:send,
                s(:send,
                  s(:lvar, :infos), :length), :-,
                s(:int, 1)),
              s(:lvar, :columns)),
            s(:args,
              s(:arg, :i)),
            s(:begin,
              s(:send,
                s(:lvar, :code), :<<,
                s(:str, "    ")),
              s(:lvasgn, :is,
                s(:send,
                  s(:lvar, :infos), :[],
                  s(:lvar, :i),
                  s(:lvar, :columns))),
              s(:block,
                s(:send,
                  s(:lvar, :is), :each),
                s(:args,
                  s(:arg, :info)),
                s(:send,
                  s(:lvar, :code), :<<,
                  s(:send, nil, :sprintf,
                    s(:dstr,
                      s(:str, " %"),
                      s(:begin,
                        s(:lvar, :maxlen)),
                      s(:str, "s,")),
                    s(:lvar, :info)))),
              s(:send,
                s(:lvar, :code), :<<,
                s(:str, "\n")))),
          s(:lvar, :code))),
      s(:def, :generate_lookup_node,
        s(:args,
          s(:arg, :name),
          s(:arg, :table)),
        s(:begin,
          s(:lvasgn, :bytes_code,
            s(:ivar, :@bytes_code)),
          s(:lvasgn, :words_code,
            s(:ivar, :@words_code)),
          s(:lvasgn, :offsets,
            s(:array)),
          s(:lvasgn, :infos,
            s(:array)),
          s(:lvasgn, :infomap,
            s(:hash)),
          s(:lvasgn, :min,
            s(:lvasgn, :max,
              s(:nil))),
          s(:block,
            s(:send,
              s(:lvar, :table), :each_with_index),
            s(:args,
              s(:arg, :action),
              s(:arg, :byte)),
            s(:begin,
              s(:or_asgn,
                s(:lvasgn, :action),
                s(:sym, :invalid)),
              s(:if,
                s(:send,
                  s(:lvar, :action), :!=,
                  s(:sym, :invalid)),
                s(:begin,
                  s(:if,
                    s(:send,
                      s(:lvar, :min), :!),
                    s(:lvasgn, :min,
                      s(:lvar, :byte)), nil),
                  s(:lvasgn, :max,
                    s(:lvar, :byte))), nil),
              s(:if,
                s(:lvasgn, :o,
                  s(:send,
                    s(:lvar, :infomap), :[],
                    s(:lvar, :action))), nil,
                s(:begin,
                  s(:send,
                    s(:lvar, :infomap), :[]=,
                    s(:lvar, :action),
                    s(:lvasgn, :o,
                      s(:send,
                        s(:lvar, :infos), :length))),
                  s(:send,
                    s(:lvar, :infos), :[]=,
                    s(:lvar, :o),
                    s(:lvar, :action)))),
              s(:send,
                s(:lvar, :offsets), :[]=,
                s(:lvar, :byte),
                s(:lvar, :o)))),
          s(:send,
            s(:lvar, :infomap), :clear),
          s(:if,
            s(:send,
              s(:lvar, :min), :!),
            s(:lvasgn, :min,
              s(:lvasgn, :max,
                s(:int, 0))), nil),
          s(:lvasgn, :offsets_key,
            s(:array,
              s(:lvar, :min),
              s(:lvar, :max),
              s(:send,
                s(:lvar, :offsets), :[],
                s(:irange,
                  s(:lvar, :min),
                  s(:lvar, :max))))),
          s(:if,
            s(:lvasgn, :n,
              s(:send,
                s(:const, nil, :OffsetsMemo), :[],
                s(:lvar, :offsets_key))),
            s(:lvasgn, :offsets_name,
              s(:lvar, :n)),
            s(:begin,
              s(:lvasgn, :offsets_name,
                s(:dstr,
                  s(:begin,
                    s(:lvar, :name)),
                  s(:str, "_offsets"))),
              s(:send,
                s(:const, nil, :OffsetsMemo), :[]=,
                s(:lvar, :offsets_key),
                s(:lvar, :offsets_name)),
              s(:lvasgn, :size,
                s(:send,
                  s(:lvar, :bytes_code), :length)),
              s(:send,
                s(:lvar, :bytes_code), :insert_at_last,
                s(:send,
                  s(:send,
                    s(:send,
                      s(:int, 2), :+,
                      s(:lvar, :max)), :-,
                    s(:lvar, :min)), :+,
                  s(:int, 1)),
                s(:send,
                  s(:send,
                    s(:dstr,
                      s(:str, "#define "),
                      s(:begin,
                        s(:lvar, :offsets_name)),
                      s(:str, " "),
                      s(:begin,
                        s(:lvar, :size)),
                      s(:str, "\n")), :+,
                    s(:send, nil, :format_offsets,
                      s(:lvar, :min),
                      s(:lvar, :max),
                      s(:lvar, :offsets))), :+,
                  s(:str, "\n"))))),
          s(:if,
            s(:lvasgn, :n,
              s(:send,
                s(:const, nil, :InfosMemo), :[],
                s(:lvar, :infos))),
            s(:lvasgn, :infos_name,
              s(:lvar, :n)),
            s(:begin,
              s(:lvasgn, :infos_name,
                s(:dstr,
                  s(:begin,
                    s(:lvar, :name)),
                  s(:str, "_infos"))),
              s(:send,
                s(:const, nil, :InfosMemo), :[]=,
                s(:lvar, :infos),
                s(:lvar, :infos_name)),
              s(:lvasgn, :size,
                s(:send,
                  s(:lvar, :words_code), :length)),
              s(:send,
                s(:lvar, :words_code), :insert_at_last,
                s(:send,
                  s(:lvar, :infos), :length),
                s(:send,
                  s(:send,
                    s(:dstr,
                      s(:str, "#define "),
                      s(:begin,
                        s(:lvar, :infos_name)),
                      s(:str, " WORDINDEX2INFO("),
                      s(:begin,
                        s(:lvar, :size)),
                      s(:str, ")\n")), :+,
                    s(:send, nil, :format_infos,
                      s(:lvar, :infos))), :+,
                  s(:str, "\n"))))),
          s(:lvasgn, :size,
            s(:send,
              s(:lvar, :words_code), :length)),
          s(:send,
            s(:lvar, :words_code), :insert_at_last,
            s(:const, nil, :NUM_ELEM_BYTELOOKUP),
            s(:send,
              s(:send,
                s(:dstr,
                  s(:str, "#define "),
                  s(:begin,
                    s(:lvar, :name)),
                  s(:str, " WORDINDEX2INFO("),
                  s(:begin,
                    s(:lvar, :size)),
                  s(:str, ")\n")), :+,
                s(:dstr,
                  s(:str, "    "),
                  s(:begin,
                    s(:lvar, :offsets_name)),
                  s(:str, ",\n"),
                  s(:str, "    "),
                  s(:begin,
                    s(:lvar, :infos_name)),
                  s(:str, ",\n"))), :+,
              s(:str, "\n"))))),
      s(:casgn, nil, :PreMemo,
        s(:hash)),
      s(:casgn, nil, :NextName,
        s(:str, "a")),
      s(:def, :generate_node,
        s(:args,
          s(:optarg, :name_hint,
            s(:nil))),
        s(:begin,
          s(:if,
            s(:lvasgn, :n,
              s(:send,
                s(:const, nil, :PreMemo), :[],
                s(:ivar, :@tree))),
            s(:return,
              s(:lvar, :n)), nil),
          s(:lvasgn, :table,
            s(:send,
              s(:const, nil, :Array), :new,
              s(:int, 256),
              s(:sym, :invalid))),
          s(:block,
            s(:send,
              s(:ivar, :@tree), :each),
            s(:args,
              s(:arg, :branch)),
            s(:begin,
              s(:masgn,
                s(:mlhs,
                  s(:lvasgn, :byte_min),
                  s(:lvasgn, :byte_max),
                  s(:lvasgn, :child_tree)),
                s(:array,
                  s(:send,
                    s(:lvar, :branch), :byte_min),
                  s(:send,
                    s(:lvar, :branch), :byte_max),
                  s(:send,
                    s(:lvar, :branch), :child_tree))),
              s(:lvasgn, :rest,
                s(:send,
                  s(:const, nil, :ActionMap), :new,
                  s(:lvar, :child_tree))),
              s(:if,
                s(:lvasgn, :a,
                  s(:send,
                    s(:lvar, :rest), :empty_action)),
                s(:send,
                  s(:lvar, :table), :fill,
                  s(:lvar, :a),
                  s(:irange,
                    s(:lvar, :byte_min),
                    s(:lvar, :byte_max))),
                s(:begin,
                  s(:lvasgn, :name_hint2,
                    s(:nil)),
                  s(:if,
                    s(:lvar, :name_hint),
                    s(:lvasgn, :name_hint2,
                      s(:dstr,
                        s(:begin,
                          s(:lvar, :name_hint)),
                        s(:str, "_"),
                        s(:begin,
                          s(:if,
                            s(:send,
                              s(:lvar, :byte_min), :==,
                              s(:lvar, :byte_max)),
                            s(:send,
                              s(:str, "%02X"), :%,
                              s(:lvar, :byte_min)),
                            s(:send,
                              s(:str, "%02Xto%02X"), :%,
                              s(:array,
                                s(:lvar, :byte_min),
                                s(:lvar, :byte_max))))))), nil),
                  s(:lvasgn, :v,
                    s(:send,
                      s(:str, "/*BYTE_LOOKUP*/"), :+,
                      s(:send,
                        s(:lvar, :rest), :gennode,
                        s(:ivar, :@bytes_code),
                        s(:ivar, :@words_code),
                        s(:lvar, :name_hint2)))),
                  s(:send,
                    s(:lvar, :table), :fill,
                    s(:lvar, :v),
                    s(:irange,
                      s(:lvar, :byte_min),
                      s(:lvar, :byte_max))))))),
          s(:if,
            s(:send,
              s(:lvar, :name_hint), :!),
            s(:begin,
              s(:lvasgn, :name_hint,
                s(:send,
                  s(:str, "fun_"), :+,
                  s(:const, nil, :NextName))),
              s(:send,
                s(:const, nil, :NextName), :succ!)), nil),
          s(:send,
            s(:const, nil, :PreMemo), :[]=,
            s(:ivar, :@tree),
            s(:lvar, :name_hint)),
          s(:send, nil, :generate_lookup_node,
            s(:lvar, :name_hint),
            s(:lvar, :table)),
          s(:lvar, :name_hint))),
      s(:def, :gennode,
        s(:args,
          s(:arg, :bytes_code),
          s(:arg, :words_code),
          s(:optarg, :name_hint,
            s(:nil))),
        s(:begin,
          s(:ivasgn, :@bytes_code,
            s(:lvar, :bytes_code)),
          s(:ivasgn, :@words_code,
            s(:lvar, :words_code)),
          s(:lvasgn, :name,
            s(:send, nil, :generate_node,
              s(:lvar, :name_hint))),
          s(:ivasgn, :@bytes_code,
            s(:nil)),
          s(:ivasgn, :@words_code,
            s(:nil)),
          s(:return,
            s(:lvar, :name)))))),
  s(:def, :citrus_mskanji_cstomb,
    s(:args,
      s(:arg, :csid),
      s(:arg, :index)),
    s(:send,
      s(:case,
        s(:lvar, :csid),
        s(:when,
          s(:int, 0),
          s(:lvar, :index)),
        s(:when,
          s(:int, 1),
          s(:send,
            s(:lvar, :index), :+,
            s(:int, 128))),
        s(:when,
          s(:int, 2),
          s(:int, 3),
          s(:begin,
            s(:lvasgn, :row,
              s(:send,
                s(:lvar, :index), :>>,
                s(:int, 8))),
            s(:if,
              s(:send,
                s(:lvar, :row), :<,
                s(:int, 33)),
              s(:send, nil, :raise,
                s(:str, "invalid byte sequence")), nil),
            s(:if,
              s(:send,
                s(:lvar, :csid), :==,
                s(:int, 3)),
              s(:if,
                s(:send,
                  s(:lvar, :row), :<=,
                  s(:int, 47)),
                s(:lvasgn, :offset,
                  s(:if,
                    s(:begin,
                      s(:or,
                        s(:send,
                          s(:lvar, :row), :==,
                          s(:int, 34)),
                        s(:send,
                          s(:lvar, :row), :>=,
                          s(:int, 38)))),
                    s(:int, 237),
                    s(:int, 240))),
                s(:if,
                  s(:and,
                    s(:send,
                      s(:lvar, :row), :>=,
                      s(:int, 77)),
                    s(:send,
                      s(:lvar, :row), :<=,
                      s(:int, 126))),
                  s(:lvasgn, :offset,
                    s(:int, 206)),
                  s(:send, nil, :raise,
                    s(:str, "invalid byte sequence")))),
              s(:begin,
                s(:if,
                  s(:send,
                    s(:lvar, :row), :>,
                    s(:int, 151)),
                  s(:send, nil, :raise,
                    s(:str, "invalid byte sequence")), nil),
                s(:lvasgn, :offset,
                  s(:if,
                    s(:begin,
                      s(:send,
                        s(:lvar, :row), :<,
                        s(:int, 95))),
                    s(:int, 129),
                    s(:int, 193))))),
            s(:lvasgn, :col,
              s(:send,
                s(:lvar, :index), :&,
                s(:int, 255))),
            s(:if,
              s(:begin,
                s(:or,
                  s(:send,
                    s(:lvar, :col), :<,
                    s(:int, 33)),
                  s(:send,
                    s(:lvar, :col), :>,
                    s(:int, 126)))),
              s(:send, nil, :raise,
                s(:str, "invalid byte sequence")), nil),
            s(:op_asgn,
              s(:lvasgn, :row), :-,
              s(:int, 33)),
            s(:op_asgn,
              s(:lvasgn, :col), :-,
              s(:int, 33)),
            s(:if,
              s(:send,
                s(:begin,
                  s(:send,
                    s(:lvar, :row), :&,
                    s(:int, 1))), :==,
                s(:int, 0)),
              s(:begin,
                s(:op_asgn,
                  s(:lvasgn, :col), :+,
                  s(:int, 64)),
                s(:if,
                  s(:begin,
                    s(:send,
                      s(:lvar, :col), :>=,
                      s(:int, 127))),
                  s(:op_asgn,
                    s(:lvasgn, :col), :+,
                    s(:int, 1)), nil)),
              s(:op_asgn,
                s(:lvasgn, :col), :+,
                s(:int, 159))),
            s(:lvasgn, :row,
              s(:send,
                s(:send,
                  s(:lvar, :row), :/,
                  s(:int, 2)), :+,
                s(:lvar, :offset))),
            s(:send,
              s(:begin,
                s(:send,
                  s(:lvar, :row), :<<,
                  s(:int, 8))), :|,
              s(:lvar, :col)))), nil), :to_s,
      s(:int, 16))),
  s(:def, :citrus_euc_cstomb,
    s(:args,
      s(:arg, :csid),
      s(:arg, :index)),
    s(:send,
      s(:case,
        s(:lvar, :csid),
        s(:when,
          s(:int, 0),
          s(:lvar, :index)),
        s(:when,
          s(:int, 32896),
          s(:send,
            s(:lvar, :index), :|,
            s(:int, 32896))),
        s(:when,
          s(:int, 128),
          s(:send,
            s(:lvar, :index), :|,
            s(:int, 36480))),
        s(:when,
          s(:int, 32768),
          s(:send,
            s(:lvar, :index), :|,
            s(:int, 9404544))), nil), :to_s,
      s(:int, 16))),
  s(:def, :citrus_stateless_iso_cstomb,
    s(:args,
      s(:arg, :csid),
      s(:arg, :index)),
    s(:send,
      s(:begin,
        s(:send,
          s(:send,
            s(:lvar, :index), :|,
            s(:int, 32896)), :|,
          s(:begin,
            s(:send,
              s(:lvar, :csid), :<<,
              s(:int, 16))))), :to_s,
      s(:int, 16))),
  s(:def, :citrus_cstomb,
    s(:args,
      s(:arg, :ces),
      s(:arg, :csid),
      s(:arg, :index)),
    s(:case,
      s(:lvar, :ces),
      s(:when,
        s(:str, "mskanji"),
        s(:send, nil, :citrus_mskanji_cstomb,
          s(:lvar, :csid),
          s(:lvar, :index))),
      s(:when,
        s(:str, "euc"),
        s(:send, nil, :citrus_euc_cstomb,
          s(:lvar, :csid),
          s(:lvar, :index))),
      s(:when,
        s(:str, "stateless_iso"),
        s(:send, nil, :citrus_stateless_iso_cstomb,
          s(:lvar, :csid),
          s(:lvar, :index))), nil)),
  s(:casgn, nil, :SUBDIR,
    s(:array,
      s(:str, "APPLE"),
      s(:str, "AST"),
      s(:str, "BIG5"),
      s(:str, "CNS"),
      s(:str, "CP"),
      s(:str, "EBCDIC"),
      s(:str, "EMOJI"),
      s(:str, "GB"),
      s(:str, "GEORGIAN"),
      s(:str, "ISO646"),
      s(:str, "ISO-8859"),
      s(:str, "JIS"),
      s(:str, "KAZAKH"),
      s(:str, "KOI"),
      s(:str, "KS"),
      s(:str, "MISC"),
      s(:str, "TCVN"))),
  s(:def, :citrus_decode_mapsrc,
    s(:args,
      s(:arg, :ces),
      s(:arg, :csid),
      s(:arg, :mapsrcs)),
    s(:begin,
      s(:lvasgn, :table,
        s(:array)),
      s(:block,
        s(:send,
          s(:send,
            s(:lvar, :mapsrcs), :split,
            s(:str, ",")), :each),
        s(:args,
          s(:arg, :mapsrc)),
        s(:begin,
          s(:lvasgn, :path,
            s(:array,
              s(:gvar, :$srcdir))),
          s(:lvasgn, :mode,
            s(:nil)),
          s(:if,
            s(:send,
              s(:lvar, :mapsrc), :rindex,
              s(:regexp,
                s(:str, "UCS(?:@[A-Z]+)?"),
                s(:regopt)),
              s(:int, 0)),
            s(:begin,
              s(:lvasgn, :mode,
                s(:sym, :from_ucs)),
              s(:lvasgn, :from,
                s(:send,
                  s(:lvar, :mapsrc), :[],
                  s(:irange,
                    s(:send,
                      s(:send,
                        s(:back_ref, :$&), :size), :+,
                      s(:int, 1)),
                    s(:int, -1)))),
              s(:send,
                s(:lvar, :path), :<<,
                s(:block,
                  s(:send,
                    s(:const, nil, :SUBDIR), :find),
                  s(:args,
                    s(:arg, :x)),
                  s(:send,
                    s(:lvar, :from), :rindex,
                    s(:lvar, :x),
                    s(:int, 0))))),
            s(:begin,
              s(:lvasgn, :mode,
                s(:sym, :to_ucs)),
              s(:send,
                s(:lvar, :path), :<<,
                s(:block,
                  s(:send,
                    s(:const, nil, :SUBDIR), :find),
                  s(:args,
                    s(:arg, :x)),
                  s(:send,
                    s(:lvar, :mapsrc), :rindex,
                    s(:lvar, :x),
                    s(:int, 0)))))),
          s(:if,
            s(:match_with_lvasgn,
              s(:regexp,
                s(:str, "\\bUCS@(BMP|SMP|SIP|TIP|SSP)\\b"),
                s(:regopt)),
              s(:lvar, :mapsrc)),
            s(:lvasgn, :plane,
              s(:send,
                s(:hash,
                  s(:pair,
                    s(:str, "BMP"),
                    s(:int, 0)),
                  s(:pair,
                    s(:str, "SMP"),
                    s(:int, 1)),
                  s(:pair,
                    s(:str, "SIP"),
                    s(:int, 2)),
                  s(:pair,
                    s(:str, "TIP"),
                    s(:int, 3)),
                  s(:pair,
                    s(:str, "SSP"),
                    s(:int, 14))), :[],
                s(:nth_ref, 1))),
            s(:lvasgn, :plane,
              s(:int, 0))),
          s(:op_asgn,
            s(:lvasgn, :plane), :<<,
            s(:int, 16)),
          s(:send,
            s(:lvar, :path), :<<,
            s(:send,
              s(:lvar, :mapsrc), :gsub,
              s(:str, ":"),
              s(:str, "@"))),
          s(:lvasgn, :path,
            s(:send,
              s(:const, nil, :File), :join,
              s(:splat,
                s(:lvar, :path)))),
          s(:send,
            s(:lvar, :path), :<<,
            s(:str, ".src")),
          s(:send,
            s(:lvar, :path), :[]=,
            s(:send,
              s(:lvar, :path), :rindex,
              s(:str, "/")),
            s(:str, "%")),
          s(:if,
            s(:const, nil, :VERBOSE_MODE),
            s(:send,
              s(:const, nil, :STDERR), :puts,
              s(:send,
                s(:str, "load mapsrc %s"), :%,
                s(:lvar, :path))), nil),
          s(:block,
            s(:send, nil, :open,
              s(:lvar, :path),
              s(:str, "rb")),
            s(:args,
              s(:arg, :f)),
            s(:begin,
              s(:block,
                s(:send,
                  s(:lvar, :f), :each_line),
                s(:args,
                  s(:arg, :l)),
                s(:if,
                  s(:match_with_lvasgn,
                    s(:regexp,
                      s(:str, "^BEGIN_MAP"),
                      s(:regopt)),
                    s(:lvar, :l)),
                  s(:break), nil)),
              s(:block,
                s(:send,
                  s(:lvar, :f), :each_line),
                s(:args,
                  s(:arg, :l)),
                s(:begin,
                  s(:if,
                    s(:match_with_lvasgn,
                      s(:regexp,
                        s(:str, "^\\s*(?:#|$)"),
                        s(:regopt)),
                      s(:lvar, :l)),
                    s(:next), nil),
                  s(:if,
                    s(:match_with_lvasgn,
                      s(:regexp,
                        s(:str, "^END_MAP"),
                        s(:regopt)),
                      s(:lvar, :l)),
                    s(:break), nil),
                  s(:case,
                    s(:lvar, :mode),
                    s(:when,
                      s(:sym, :from_ucs),
                      s(:case,
                        s(:lvar, :l),
                        s(:when,
                          s(:regexp,
                            s(:str, "0x(\\w+)\\s*-\\s*0x(\\w+)\\s*=\\s*INVALID"),
                            s(:regopt)), nil),
                        s(:when,
                          s(:regexp,
                            s(:str, "(0x\\w+)\\s*=\\s*(0x\\w+)"),
                            s(:regopt)),
                          s(:send,
                            s(:send,
                              s(:lvar, :table), :push), :<<,
                            s(:array,
                              s(:send,
                                s(:lvar, :plane), :|,
                                s(:send,
                                  s(:nth_ref, 1), :hex)),
                              s(:send, nil, :citrus_cstomb,
                                s(:lvar, :ces),
                                s(:lvar, :csid),
                                s(:send,
                                  s(:nth_ref, 2), :hex))))),
                        s(:send, nil, :raise,
                          s(:send,
                            s(:str, "unknown notation '%s'"), :%,
                            s(:lvar, :l))))),
                    s(:when,
                      s(:sym, :to_ucs),
                      s(:case,
                        s(:lvar, :l),
                        s(:when,
                          s(:regexp,
                            s(:str, "(0x\\w+)\\s*=\\s*(0x\\w+)"),
                            s(:regopt)),
                          s(:send,
                            s(:send,
                              s(:lvar, :table), :push), :<<,
                            s(:array,
                              s(:send, nil, :citrus_cstomb,
                                s(:lvar, :ces),
                                s(:lvar, :csid),
                                s(:send,
                                  s(:nth_ref, 1), :hex)),
                              s(:send,
                                s(:lvar, :plane), :|,
                                s(:send,
                                  s(:nth_ref, 2), :hex))))),
                        s(:send, nil, :raise,
                          s(:send,
                            s(:str, "unknown notation '%s'"), :%,
                            s(:lvar, :l))))), nil))))))),
      s(:return,
        s(:lvar, :table)))),
  s(:def, :import_ucm,
    s(:args,
      s(:arg, :path)),
    s(:begin,
      s(:lvasgn, :to_ucs,
        s(:array)),
      s(:lvasgn, :from_ucs,
        s(:array)),
      s(:block,
        s(:send,
          s(:const, nil, :File), :foreach,
          s(:send,
            s(:const, nil, :File), :join,
            s(:gvar, :$srcdir),
            s(:str, "ucm"),
            s(:lvar, :path))),
        s(:args,
          s(:arg, :line)),
        s(:begin,
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :uc),
              s(:lvasgn, :bs),
              s(:lvasgn, :fb)),
            s(:nil)),
          s(:if,
            s(:match_with_lvasgn,
              s(:regexp,
                s(:str, "^<U([0-9a-fA-F]+)>\\s*([\\+0-9a-fA-Fx\\\\]+)\\s*\\|(\\d)"),
                s(:regopt)),
              s(:lvar, :line)),
            s(:begin,
              s(:lvasgn, :uc,
                s(:send,
                  s(:nth_ref, 1), :hex)),
              s(:lvasgn, :bs,
                s(:send,
                  s(:nth_ref, 2), :delete,
                  s(:str, "x\\"))),
              s(:lvasgn, :fb,
                s(:send,
                  s(:nth_ref, 3), :to_i)),
              s(:if,
                s(:and,
                  s(:send,
                    s(:lvar, :uc), :<,
                    s(:int, 128)),
                  s(:send,
                    s(:lvar, :uc), :==,
                    s(:send,
                      s(:lvar, :bs), :hex))),
                s(:next), nil)),
            s(:if,
              s(:match_with_lvasgn,
                s(:regexp,
                  s(:str, "^([<U0-9a-fA-F>+]+)\\s*([\\+0-9a-fA-Fx\\\\]+)\\s*\\|(\\d)"),
                  s(:regopt)),
                s(:lvar, :line)),
              s(:begin,
                s(:lvasgn, :uc,
                  s(:send,
                    s(:send,
                      s(:send,
                        s(:send,
                          s(:send,
                            s(:nth_ref, 1), :scan,
                            s(:regexp,
                              s(:str, "[0-9a-fA-F]+>"),
                              s(:regopt))), :map,
                          s(:block_pass,
                            s(:sym, :hex))), :pack,
                        s(:str, "U*")), :unpack,
                      s(:str, "H*")), :[],
                    s(:int, 0))),
                s(:lvasgn, :bs,
                  s(:send,
                    s(:nth_ref, 2), :delete,
                    s(:str, "x\\"))),
                s(:lvasgn, :fb,
                  s(:send,
                    s(:nth_ref, 3), :to_i))), nil)),
          s(:if,
            s(:or,
              s(:send,
                s(:lvar, :fb), :==,
                s(:int, 0)),
              s(:send,
                s(:lvar, :fb), :==,
                s(:int, 3))),
            s(:send,
              s(:lvar, :to_ucs), :<<,
              s(:array,
                s(:lvar, :bs),
                s(:lvar, :uc))), nil),
          s(:if,
            s(:or,
              s(:send,
                s(:lvar, :fb), :==,
                s(:int, 0)),
              s(:send,
                s(:lvar, :fb), :==,
                s(:int, 1))),
            s(:send,
              s(:lvar, :from_ucs), :<<,
              s(:array,
                s(:lvar, :uc),
                s(:lvar, :bs))), nil))),
      s(:array,
        s(:lvar, :to_ucs),
        s(:lvar, :from_ucs)))),
  s(:def, :encode_utf8,
    s(:args,
      s(:arg, :map)),
    s(:begin,
      s(:lvasgn, :r,
        s(:array)),
      s(:block,
        s(:send,
          s(:lvar, :map), :each),
        s(:args,
          s(:arg, :k),
          s(:arg, :v)),
        s(:begin,
          s(:if,
            s(:send,
              s(:const, nil, :Integer), :===,
              s(:lvar, :k)),
            s(:lvasgn, :k,
              s(:send,
                s(:send,
                  s(:send,
                    s(:send,
                      s(:array,
                        s(:lvar, :k)), :pack,
                      s(:str, "U")), :unpack,
                    s(:str, "H*")), :[],
                  s(:int, 0)), :upcase)), nil),
          s(:if,
            s(:send,
              s(:const, nil, :Integer), :===,
              s(:lvar, :v)),
            s(:lvasgn, :v,
              s(:send,
                s(:send,
                  s(:send,
                    s(:send,
                      s(:array,
                        s(:lvar, :v)), :pack,
                      s(:str, "U")), :unpack,
                    s(:str, "H*")), :[],
                  s(:int, 0)), :upcase)), nil),
          s(:send,
            s(:lvar, :r), :<<,
            s(:array,
              s(:lvar, :k),
              s(:lvar, :v))))),
      s(:lvar, :r))),
  s(:casgn, nil, :UnspecifiedValidEncoding,
    s(:send,
      s(:const, nil, :Object), :new)),
  s(:def, :transcode_compile_tree,
    s(:args,
      s(:arg, :name),
      s(:arg, :from),
      s(:arg, :map),
      s(:arg, :valid_encoding)),
    s(:begin,
      s(:lvasgn, :map,
        s(:send, nil, :encode_utf8,
          s(:lvar, :map))),
      s(:lvasgn, :h,
        s(:hash)),
      s(:block,
        s(:send,
          s(:lvar, :map), :each),
        s(:args,
          s(:arg, :k),
          s(:arg, :v)),
        s(:if,
          s(:send,
            s(:lvar, :h), :[],
            s(:lvar, :k)), nil,
          s(:send,
            s(:lvar, :h), :[]=,
            s(:lvar, :k),
            s(:lvar, :v)))),
      s(:if,
        s(:send,
          s(:lvar, :valid_encoding), :equal?,
          s(:const, nil, :UnspecifiedValidEncoding)),
        s(:lvasgn, :valid_encoding,
          s(:send,
            s(:const, nil, :ValidEncoding), :fetch,
            s(:lvar, :from))), nil),
      s(:if,
        s(:lvar, :valid_encoding),
        s(:lvasgn, :am,
          s(:block,
            s(:send,
              s(:const, nil, :ActionMap), :merge2,
              s(:lvar, :h),
              s(:hash,
                s(:pair,
                  s(:lvar, :valid_encoding),
                  s(:sym, :undef)))),
            s(:args,
              s(:arg, :prefix),
              s(:arg, :as1),
              s(:arg, :as2)),
            s(:begin,
              s(:lvasgn, :a1,
                s(:if,
                  s(:send,
                    s(:lvar, :as1), :empty?),
                  s(:nil),
                  s(:send,
                    s(:const, nil, :ActionMap), :unambiguous_action,
                    s(:lvar, :as1)))),
              s(:lvasgn, :a2,
                s(:if,
                  s(:send,
                    s(:lvar, :as2), :empty?),
                  s(:nil),
                  s(:send,
                    s(:const, nil, :ActionMap), :unambiguous_action,
                    s(:lvar, :as2)))),
              s(:if,
                s(:send,
                  s(:lvar, :a2), :!),
                s(:send, nil, :raise,
                  s(:dstr,
                    s(:str, "invalid mapping: "),
                    s(:begin,
                      s(:lvar, :prefix)))), nil),
              s(:or,
                s(:lvar, :a1),
                s(:lvar, :a2))))),
        s(:lvasgn, :am,
          s(:send,
            s(:const, nil, :ActionMap), :parse,
            s(:lvar, :h)))),
      s(:send,
        s(:lvar, :h), :clear),
      s(:lvasgn, :max_input,
        s(:send,
          s(:lvar, :am), :max_input_length)),
      s(:lvasgn, :defined_name,
        s(:send,
          s(:lvar, :am), :gennode,
          s(:const, nil, :TRANSCODE_GENERATED_BYTES_CODE),
          s(:const, nil, :TRANSCODE_GENERATED_WORDS_CODE),
          s(:lvar, :name))),
      s(:return,
        s(:lvar, :defined_name),
        s(:lvar, :max_input)))),
  s(:casgn, nil, :TRANSCODERS,
    s(:array)),
  s(:casgn, nil, :TRANSCODE_GENERATED_TRANSCODER_CODE,
    s(:send,
      s(:str, ""), :dup)),
  s(:def, :transcode_tbl_only,
    s(:args,
      s(:arg, :from),
      s(:arg, :to),
      s(:arg, :map),
      s(:optarg, :valid_encoding,
        s(:const, nil, :UnspecifiedValidEncoding))),
    s(:begin,
      s(:if,
        s(:const, nil, :VERBOSE_MODE),
        s(:if,
          s(:or,
            s(:send,
              s(:lvar, :from), :empty?),
            s(:send,
              s(:lvar, :to), :empty?)),
          s(:send,
            s(:const, nil, :STDERR), :puts,
            s(:dstr,
              s(:str, "converter for "),
              s(:begin,
                s(:if,
                  s(:send,
                    s(:lvar, :from), :empty?),
                  s(:lvar, :to),
                  s(:lvar, :from))))),
          s(:send,
            s(:const, nil, :STDERR), :puts,
            s(:dstr,
              s(:str, "converter from "),
              s(:begin,
                s(:lvar, :from)),
              s(:str, " to "),
              s(:begin,
                s(:lvar, :to))))), nil),
      s(:lvasgn, :id_from,
        s(:send,
          s(:lvar, :from), :tr,
          s(:str, "^0-9A-Za-z"),
          s(:str, "_"))),
      s(:lvasgn, :id_to,
        s(:send,
          s(:lvar, :to), :tr,
          s(:str, "^0-9A-Za-z"),
          s(:str, "_"))),
      s(:if,
        s(:send,
          s(:lvar, :from), :==,
          s(:str, "UTF-8")),
        s(:lvasgn, :tree_name,
          s(:dstr,
            s(:str, "to_"),
            s(:begin,
              s(:lvar, :id_to)))),
        s(:if,
          s(:send,
            s(:lvar, :to), :==,
            s(:str, "UTF-8")),
          s(:lvasgn, :tree_name,
            s(:dstr,
              s(:str, "from_"),
              s(:begin,
                s(:lvar, :id_from)))),
          s(:lvasgn, :tree_name,
            s(:dstr,
              s(:str, "from_"),
              s(:begin,
                s(:lvar, :id_from)),
              s(:str, "_to_"),
              s(:begin,
                s(:lvar, :id_to)))))),
      s(:masgn,
        s(:mlhs,
          s(:lvasgn, :real_tree_name),
          s(:lvasgn, :max_input)),
        s(:send, nil, :transcode_compile_tree,
          s(:lvar, :tree_name),
          s(:lvar, :from),
          s(:lvar, :map),
          s(:lvar, :valid_encoding))),
      s(:return,
        s(:lvar, :map),
        s(:lvar, :tree_name),
        s(:lvar, :real_tree_name),
        s(:lvar, :max_input)))),
  s(:def, :transcode_tblgen,
    s(:args,
      s(:arg, :from),
      s(:arg, :to),
      s(:arg, :map),
      s(:optarg, :valid_encoding,
        s(:const, nil, :UnspecifiedValidEncoding)),
      s(:optarg, :ascii_compatibility,
        s(:str, "asciicompat_converter"))),
    s(:begin,
      s(:masgn,
        s(:mlhs,
          s(:lvasgn, :map),
          s(:lvasgn, :tree_name),
          s(:lvasgn, :real_tree_name),
          s(:lvasgn, :max_input)),
        s(:send, nil, :transcode_tbl_only,
          s(:lvar, :from),
          s(:lvar, :to),
          s(:lvar, :map),
          s(:lvar, :valid_encoding))),
      s(:lvasgn, :transcoder_name,
        s(:dstr,
          s(:str, "rb_"),
          s(:begin,
            s(:lvar, :tree_name)))),
      s(:send,
        s(:const, nil, :TRANSCODERS), :<<,
        s(:lvar, :transcoder_name)),
      s(:lvasgn, :input_unit_length,
        s(:send,
          s(:const, nil, :UnitLength), :[],
          s(:lvar, :from))),
      s(:lvasgn, :max_output,
        s(:send,
          s(:block,
            s(:send,
              s(:lvar, :map), :map),
            s(:args,
              s(:arg, :k),
              s(:arg, :v)),
            s(:if,
              s(:send,
                s(:const, nil, :String), :===,
                s(:lvar, :v)),
              s(:send,
                s(:send,
                  s(:lvar, :v), :length), :/,
                s(:int, 2)),
              s(:int, 1))), :max)),
      s(:lvasgn, :transcoder_code,
        s(:dstr,
          s(:str, "static const rb_transcoder\n"),
          s(:begin,
            s(:lvar, :transcoder_name)),
          s(:str, " = {\n"),
          s(:str, "    "),
          s(:begin,
            s(:send, nil, :c_esc,
              s(:lvar, :from))),
          s(:str, ", "),
          s(:begin,
            s(:send, nil, :c_esc,
              s(:lvar, :to))),
          s(:str, ", "),
          s(:begin,
            s(:lvar, :real_tree_name)),
          s(:str, ",\n"),
          s(:str, "    TRANSCODE_TABLE_INFO,\n"),
          s(:str, "    "),
          s(:begin,
            s(:lvar, :input_unit_length)),
          s(:str, ", /* input_unit_length */\n"),
          s(:str, "    "),
          s(:begin,
            s(:lvar, :max_input)),
          s(:str, ", /* max_input */\n"),
          s(:str, "    "),
          s(:begin,
            s(:lvar, :max_output)),
          s(:str, ", /* max_output */\n"),
          s(:str, "    "),
          s(:begin,
            s(:lvar, :ascii_compatibility)),
          s(:str, ", /* asciicompat_type */\n"),
          s(:str, "    0, NULL, NULL, /* state_size, state_init, state_fini */\n"),
          s(:str, "    NULL, NULL, NULL, NULL,\n"),
          s(:str, "    NULL, NULL, NULL\n"),
          s(:str, "};\n"))),
      s(:send,
        s(:const, nil, :TRANSCODE_GENERATED_TRANSCODER_CODE), :<<,
        s(:lvar, :transcoder_code)),
      s(:str, ""))),
  s(:def, :transcode_generate_node,
    s(:args,
      s(:arg, :am),
      s(:optarg, :name_hint,
        s(:nil))),
    s(:begin,
      s(:if,
        s(:const, nil, :VERBOSE_MODE),
        s(:send,
          s(:const, nil, :STDERR), :puts,
          s(:dstr,
            s(:str, "converter for "),
            s(:begin,
              s(:lvar, :name_hint)))), nil),
      s(:lvasgn, :name,
        s(:send,
          s(:lvar, :am), :gennode,
          s(:const, nil, :TRANSCODE_GENERATED_BYTES_CODE),
          s(:const, nil, :TRANSCODE_GENERATED_WORDS_CODE),
          s(:lvar, :name_hint))),
      s(:str, ""))),
  s(:def, :transcode_generated_code,
    s(:args),
    s(:send,
      s(:send,
        s(:send,
          s(:send,
            s(:send,
              s(:send,
                s(:send,
                  s(:const, nil, :TRANSCODE_GENERATED_BYTES_CODE), :to_s), :+,
                s(:send,
                  s(:const, nil, :TRANSCODE_GENERATED_WORDS_CODE), :to_s)), :+,
              s(:str, "#define TRANSCODE_TABLE_INFO ")), :+,
            s(:dstr,
              s(:begin,
                s(:const, nil, :OUTPUT_PREFIX)),
              s(:str, "byte_array, "),
              s(:begin,
                s(:send,
                  s(:const, nil, :TRANSCODE_GENERATED_BYTES_CODE), :length)),
              s(:str, ", "))), :+,
          s(:dstr,
            s(:begin,
              s(:const, nil, :OUTPUT_PREFIX)),
            s(:str, "word_array, "),
            s(:begin,
              s(:send,
                s(:const, nil, :TRANSCODE_GENERATED_WORDS_CODE), :length)),
            s(:str, ", "))), :+,
        s(:str, "((int)sizeof(unsigned int))\n")), :+,
      s(:const, nil, :TRANSCODE_GENERATED_TRANSCODER_CODE))),
  s(:def, :transcode_register_code,
    s(:args),
    s(:begin,
      s(:lvasgn, :code,
        s(:send,
          s(:str, ""), :dup)),
      s(:block,
        s(:send,
          s(:const, nil, :TRANSCODERS), :each),
        s(:args,
          s(:arg, :transcoder_name)),
        s(:send,
          s(:lvar, :code), :<<,
          s(:dstr,
            s(:str, "    rb_register_transcoder(&"),
            s(:begin,
              s(:lvar, :transcoder_name)),
            s(:str, ");\n")))),
      s(:lvar, :code))),
  s(:casgn, nil, :UnitLength,
    s(:hash,
      s(:pair,
        s(:str, "UTF-16BE"),
        s(:int, 2)),
      s(:pair,
        s(:str, "UTF-16LE"),
        s(:int, 2)),
      s(:pair,
        s(:str, "UTF-32BE"),
        s(:int, 4)),
      s(:pair,
        s(:str, "UTF-32LE"),
        s(:int, 4)))),
  s(:send,
    s(:const, nil, :UnitLength), :default=,
    s(:int, 1)),
  s(:casgn, nil, :ValidEncoding,
    s(:hash,
      s(:pair,
        s(:str, "1byte"),
        s(:str, "{00-ff}")),
      s(:pair,
        s(:str, "2byte"),
        s(:str, "{00-ff}{00-ff}")),
      s(:pair,
        s(:str, "4byte"),
        s(:str, "{00-ff}{00-ff}{00-ff}{00-ff}")),
      s(:pair,
        s(:str, "US-ASCII"),
        s(:str, "{00-7f}")),
      s(:pair,
        s(:str, "UTF-8"),
        s(:dstr,
          s(:str, "{00-7f}\n"),
          s(:str, "                     {c2-df}{80-bf}\n"),
          s(:str, "                          e0{a0-bf}{80-bf}\n"),
          s(:str, "                     {e1-ec}{80-bf}{80-bf}\n"),
          s(:str, "                          ed{80-9f}{80-bf}\n"),
          s(:str, "                     {ee-ef}{80-bf}{80-bf}\n"),
          s(:str, "                          f0{90-bf}{80-bf}{80-bf}\n"),
          s(:str, "                     {f1-f3}{80-bf}{80-bf}{80-bf}\n"),
          s(:str, "                          f4{80-8f}{80-bf}{80-bf}"))),
      s(:pair,
        s(:str, "UTF-16BE"),
        s(:dstr,
          s(:str, "{00-d7,e0-ff}{00-ff}\n"),
          s(:str, "                     {d8-db}{00-ff}{dc-df}{00-ff}"))),
      s(:pair,
        s(:str, "UTF-16LE"),
        s(:dstr,
          s(:str, "{00-ff}{00-d7,e0-ff}\n"),
          s(:str, "                     {00-ff}{d8-db}{00-ff}{dc-df}"))),
      s(:pair,
        s(:str, "UTF-32BE"),
        s(:dstr,
          s(:str, "0000{00-d7,e0-ff}{00-ff}\n"),
          s(:str, "                     00{01-10}{00-ff}{00-ff}"))),
      s(:pair,
        s(:str, "UTF-32LE"),
        s(:dstr,
          s(:str, "{00-ff}{00-d7,e0-ff}0000\n"),
          s(:str, "                     {00-ff}{00-ff}{01-10}00"))),
      s(:pair,
        s(:str, "EUC-JP"),
        s(:dstr,
          s(:str, "{00-7f}\n"),
          s(:str, "                     {a1-fe}{a1-fe}\n"),
          s(:str, "                     8e{a1-fe}\n"),
          s(:str, "                     8f{a1-fe}{a1-fe}"))),
      s(:pair,
        s(:str, "CP51932"),
        s(:dstr,
          s(:str, "{00-7f}\n"),
          s(:str, "                     {a1-fe}{a1-fe}\n"),
          s(:str, "                     8e{a1-fe}"))),
      s(:pair,
        s(:str, "EUC-JIS-2004"),
        s(:dstr,
          s(:str, "{00-7f}\n"),
          s(:str, "                     {a1-fe}{a1-fe}\n"),
          s(:str, "                     8e{a1-fe}\n"),
          s(:str, "                     8f{a1-fe}{a1-fe}"))),
      s(:pair,
        s(:str, "Shift_JIS"),
        s(:dstr,
          s(:str, "{00-7f}\n"),
          s(:str, "                     {81-9f,e0-fc}{40-7e,80-fc}\n"),
          s(:str, "                     {a1-df}"))),
      s(:pair,
        s(:str, "EUC-KR"),
        s(:dstr,
          s(:str, "{00-7f}\n"),
          s(:str, "                     {a1-fe}{a1-fe}"))),
      s(:pair,
        s(:str, "CP949"),
        s(:dstr,
          s(:str, "{00-7f}\n"),
          s(:str, "                     {81-fe}{41-5a,61-7a,81-fe}"))),
      s(:pair,
        s(:str, "Big5"),
        s(:dstr,
          s(:str, "{00-7f}\n"),
          s(:str, "                     {81-fe}{40-7e,a1-fe}"))),
      s(:pair,
        s(:str, "EUC-TW"),
        s(:dstr,
          s(:str, "{00-7f}\n"),
          s(:str, "                     {a1-fe}{a1-fe}\n"),
          s(:str, "                     8e{a1-b0}{a1-fe}{a1-fe}"))),
      s(:pair,
        s(:str, "GBK"),
        s(:dstr,
          s(:str, "{00-80}\n"),
          s(:str, "                     {81-fe}{40-7e,80-fe}"))),
      s(:pair,
        s(:str, "GB18030"),
        s(:dstr,
          s(:str, "{00-7f}\n"),
          s(:str, "                     {81-fe}{40-7e,80-fe}\n"),
          s(:str, "                     {81-fe}{30-39}{81-fe}{30-39}"))))),
  s(:def, :ValidEncoding,
    s(:args,
      s(:arg, :enc)),
    s(:send,
      s(:const, nil, :ValidEncoding), :fetch,
      s(:lvar, :enc))),
  s(:def, :set_valid_byte_pattern,
    s(:args,
      s(:arg, :encoding),
      s(:arg, :pattern_or_label)),
    s(:begin,
      s(:lvasgn, :pattern,
        s(:if,
          s(:send,
            s(:const, nil, :ValidEncoding), :[],
            s(:lvar, :pattern_or_label)),
          s(:send,
            s(:const, nil, :ValidEncoding), :[],
            s(:lvar, :pattern_or_label)),
          s(:lvar, :pattern_or_label))),
      s(:if,
        s(:and,
          s(:send,
            s(:const, nil, :ValidEncoding), :[],
            s(:lvar, :encoding)),
          s(:send,
            s(:send,
              s(:const, nil, :ValidEncoding), :[],
              s(:lvar, :encoding)), :!=,
            s(:lvar, :pattern))),
        s(:send, nil, :raise,
          s(:const, nil, :ArgumentError),
          s(:dstr,
            s(:str, "trying to change valid byte pattern for encoding "),
            s(:begin,
              s(:lvar, :encoding)),
            s(:str, " from "),
            s(:begin,
              s(:send,
                s(:const, nil, :ValidEncoding), :[],
                s(:lvar, :encoding))),
            s(:str, " to "),
            s(:begin,
              s(:lvar, :pattern)))), nil),
      s(:send,
        s(:const, nil, :ValidEncoding), :[]=,
        s(:lvar, :encoding),
        s(:lvar, :pattern)))),
  s(:send, nil, :set_valid_byte_pattern,
    s(:str, "ASCII-8BIT"),
    s(:str, "1byte")),
  s(:send, nil, :set_valid_byte_pattern,
    s(:str, "Windows-31J"),
    s(:str, "Shift_JIS")),
  s(:send, nil, :set_valid_byte_pattern,
    s(:str, "eucJP-ms"),
    s(:str, "EUC-JP")),
  s(:def, :make_signature,
    s(:args,
      s(:arg, :filename),
      s(:arg, :src)),
    s(:dstr,
      s(:str, "src="),
      s(:begin,
        s(:send,
          s(:lvar, :filename), :dump)),
      s(:str, ", len="),
      s(:begin,
        s(:send,
          s(:lvar, :src), :length)),
      s(:str, ", checksum="),
      s(:begin,
        s(:send,
          s(:lvar, :src), :sum)))),
  s(:if,
    s(:send,
      s(:str, "(string)"), :==,
      s(:gvar, :$0)),
    s(:begin,
      s(:lvasgn, :start_time,
        s(:send,
          s(:const, nil, :Time), :now)),
      s(:lvasgn, :output_filename,
        s(:nil)),
      s(:lvasgn, :verbose_mode,
        s(:false)),
      s(:lvasgn, :force_mode,
        s(:false)),
      s(:lvasgn, :op,
        s(:send,
          s(:const, nil, :OptionParser), :new)),
      s(:block,
        s(:send,
          s(:lvar, :op), :def_option,
          s(:str, "--help"),
          s(:str, "show help message")),
        s(:args),
        s(:begin,
          s(:send, nil, :puts,
            s(:lvar, :op)),
          s(:send, nil, :exit,
            s(:int, 0)))),
      s(:block,
        s(:send,
          s(:lvar, :op), :def_option,
          s(:str, "--verbose"),
          s(:str, "verbose mode")),
        s(:args),
        s(:lvasgn, :verbose_mode,
          s(:true))),
      s(:block,
        s(:send,
          s(:lvar, :op), :def_option,
          s(:str, "--force"),
          s(:str, "force table generation")),
        s(:args),
        s(:lvasgn, :force_mode,
          s(:true))),
      s(:block,
        s(:send,
          s(:lvar, :op), :def_option,
          s(:str, "--output=FILE"),
          s(:str, "specify output file")),
        s(:args,
          s(:arg, :arg)),
        s(:lvasgn, :output_filename,
          s(:lvar, :arg))),
      s(:send,
        s(:lvar, :op), :parse!),
      s(:casgn, nil, :VERBOSE_MODE,
        s(:lvar, :verbose_mode)),
      s(:casgn, nil, :OUTPUT_FILENAME,
        s(:lvar, :output_filename)),
      s(:casgn, nil, :OUTPUT_PREFIX,
        s(:if,
          s(:lvar, :output_filename),
          s(:send,
            s(:send,
              s(:const, nil, :File), :basename,
              s(:lvar, :output_filename)), :[],
            s(:regexp,
              s(:str, "\\A[A-Za-z0-9_]*"),
              s(:regopt))),
          s(:str, ""))),
      s(:send,
        s(:const, nil, :OUTPUT_PREFIX), :sub!,
        s(:regexp,
          s(:str, "\\A_+"),
          s(:regopt)),
        s(:str, "")),
      s(:send,
        s(:const, nil, :OUTPUT_PREFIX), :sub!,
        s(:regexp,
          s(:str, "_*\\z"),
          s(:regopt)),
        s(:str, "_")),
      s(:casgn, nil, :TRANSCODE_GENERATED_BYTES_CODE,
        s(:send,
          s(:const, nil, :ArrayCode), :new,
          s(:str, "unsigned char"),
          s(:dstr,
            s(:begin,
              s(:const, nil, :OUTPUT_PREFIX)),
            s(:str, "byte_array")))),
      s(:casgn, nil, :TRANSCODE_GENERATED_WORDS_CODE,
        s(:send,
          s(:const, nil, :ArrayCode), :new,
          s(:str, "unsigned int"),
          s(:dstr,
            s(:begin,
              s(:const, nil, :OUTPUT_PREFIX)),
            s(:str, "word_array")))),
      s(:lvasgn, :arg,
        s(:send,
          s(:const, nil, :ARGV), :shift)),
      s(:gvasgn, :$srcdir,
        s(:send,
          s(:const, nil, :File), :dirname,
          s(:lvar, :arg))),
      s(:if,
        s(:send,
          s(:gvar, :$:), :include?,
          s(:gvar, :$srcdir)), nil,
        s(:send,
          s(:gvar, :$:), :unshift,
          s(:gvar, :$srcdir))),
      s(:lvasgn, :src,
        s(:send,
          s(:const, nil, :File), :read,
          s(:lvar, :arg))),
      s(:if,
        s(:send,
          s(:lvar, :src), :respond_to?,
          s(:sym, :force_encoding)),
        s(:send,
          s(:lvar, :src), :force_encoding,
          s(:str, "ascii-8bit")), nil),
      s(:lvasgn, :this_script,
        s(:send,
          s(:const, nil, :File), :read,
          s(:str, "(string)"))),
      s(:if,
        s(:send,
          s(:lvar, :this_script), :respond_to?,
          s(:sym, :force_encoding)),
        s(:send,
          s(:lvar, :this_script), :force_encoding,
          s(:str, "ascii-8bit")), nil),
      s(:lvasgn, :base_signature,
        s(:send,
          s(:str, "/* autogenerated. */\n"), :dup)),
      s(:send,
        s(:lvar, :base_signature), :<<,
        s(:dstr,
          s(:str, "/* "),
          s(:begin,
            s(:send, nil, :make_signature,
              s(:send,
                s(:const, nil, :File), :basename,
                s(:str, "(string)")),
              s(:lvar, :this_script))),
          s(:str, " */\n"))),
      s(:send,
        s(:lvar, :base_signature), :<<,
        s(:dstr,
          s(:str, "/* "),
          s(:begin,
            s(:send, nil, :make_signature,
              s(:send,
                s(:const, nil, :File), :basename,
                s(:lvar, :arg)),
              s(:lvar, :src))),
          s(:str, " */\n"))),
      s(:if,
        s(:and,
          s(:and,
            s(:send,
              s(:lvar, :force_mode), :!),
            s(:lvar, :output_filename)),
          s(:send,
            s(:const, nil, :File), :readable?,
            s(:lvar, :output_filename))),
        s(:begin,
          s(:lvasgn, :old_signature,
            s(:block,
              s(:send,
                s(:const, nil, :File), :open,
                s(:lvar, :output_filename)),
              s(:args,
                s(:arg, :f)),
              s(:send,
                s(:send,
                  s(:lvar, :f), :gets,
                  s(:str, "")), :chomp))),
          s(:lvasgn, :chk_signature,
            s(:send,
              s(:lvar, :base_signature), :dup)),
          s(:block,
            s(:send,
              s(:lvar, :old_signature), :each_line),
            s(:args,
              s(:arg, :line)),
            s(:if,
              s(:match_with_lvasgn,
                s(:regexp,
                  s(:str, "/\\* src=\"([0-9a-z_.-]+)\","),
                  s(:regopt)),
                s(:lvar, :line)),
              s(:begin,
                s(:lvasgn, :name,
                  s(:nth_ref, 1)),
                s(:if,
                  s(:or,
                    s(:send,
                      s(:lvar, :name), :==,
                      s(:send,
                        s(:const, nil, :File), :basename,
                        s(:lvar, :arg))),
                    s(:send,
                      s(:lvar, :name), :==,
                      s(:send,
                        s(:const, nil, :File), :basename,
                        s(:str, "(string)")))),
                  s(:next), nil),
                s(:lvasgn, :path,
                  s(:send,
                    s(:const, nil, :File), :join,
                    s(:gvar, :$srcdir),
                    s(:lvar, :name))),
                s(:if,
                  s(:send,
                    s(:const, nil, :File), :readable?,
                    s(:lvar, :path)),
                  s(:send,
                    s(:lvar, :chk_signature), :<<,
                    s(:dstr,
                      s(:str, "/* "),
                      s(:begin,
                        s(:send, nil, :make_signature,
                          s(:lvar, :name),
                          s(:send,
                            s(:const, nil, :File), :read,
                            s(:lvar, :path)))),
                      s(:str, " */\n"))), nil)), nil)),
          s(:if,
            s(:send,
              s(:lvar, :old_signature), :==,
              s(:lvar, :chk_signature)),
            s(:begin,
              s(:lvasgn, :now,
                s(:send,
                  s(:const, nil, :Time), :now)),
              s(:send,
                s(:const, nil, :File), :utime,
                s(:lvar, :now),
                s(:lvar, :now),
                s(:lvar, :output_filename)),
              s(:if,
                s(:const, nil, :VERBOSE_MODE),
                s(:send,
                  s(:const, nil, :STDERR), :puts,
                  s(:dstr,
                    s(:str, "already up-to-date: "),
                    s(:begin,
                      s(:lvar, :output_filename)))), nil),
              s(:send, nil, :exit)), nil)), nil),
      s(:if,
        s(:const, nil, :VERBOSE_MODE),
        s(:if,
          s(:lvar, :output_filename),
          s(:send,
            s(:const, nil, :STDERR), :puts,
            s(:dstr,
              s(:str, "generating "),
              s(:begin,
                s(:lvar, :output_filename)),
              s(:str, " ..."))), nil), nil),
      s(:lvasgn, :libs1,
        s(:send,
          s(:gvar, :$"), :dup)),
      s(:lvasgn, :erb,
        s(:send,
          s(:const, nil, :ERB), :new,
          s(:lvar, :src),
          s(:nil),
          s(:str, "%"))),
      s(:send,
        s(:lvar, :erb), :filename=,
        s(:lvar, :arg)),
      s(:lvasgn, :erb_result,
        s(:send,
          s(:lvar, :erb), :result,
          s(:send, nil, :binding))),
      s(:lvasgn, :libs2,
        s(:send,
          s(:gvar, :$"), :dup)),
      s(:lvasgn, :libs,
        s(:send,
          s(:lvar, :libs2), :-,
          s(:lvar, :libs1))),
      s(:lvasgn, :lib_sigs,
        s(:send,
          s(:str, ""), :dup)),
      s(:block,
        s(:send,
          s(:lvar, :libs), :each),
        s(:args,
          s(:arg, :lib)),
        s(:begin,
          s(:lvasgn, :lib,
            s(:send,
              s(:const, nil, :File), :basename,
              s(:lvar, :lib))),
          s(:lvasgn, :path,
            s(:send,
              s(:const, nil, :File), :join,
              s(:gvar, :$srcdir),
              s(:lvar, :lib))),
          s(:if,
            s(:send,
              s(:const, nil, :File), :readable?,
              s(:lvar, :path)),
            s(:send,
              s(:lvar, :lib_sigs), :<<,
              s(:dstr,
                s(:str, "/* "),
                s(:begin,
                  s(:send, nil, :make_signature,
                    s(:lvar, :lib),
                    s(:send,
                      s(:const, nil, :File), :read,
                      s(:lvar, :path)))),
                s(:str, " */\n"))), nil))),
      s(:lvasgn, :result,
        s(:send,
          s(:str, ""), :dup)),
      s(:send,
        s(:lvar, :result), :<<,
        s(:lvar, :base_signature)),
      s(:send,
        s(:lvar, :result), :<<,
        s(:lvar, :lib_sigs)),
      s(:send,
        s(:lvar, :result), :<<,
        s(:str, "\n")),
      s(:send,
        s(:lvar, :result), :<<,
        s(:lvar, :erb_result)),
      s(:send,
        s(:lvar, :result), :<<,
        s(:str, "\n")),
      s(:if,
        s(:lvar, :output_filename),
        s(:begin,
          s(:lvasgn, :new_filename,
            s(:send,
              s(:lvar, :output_filename), :+,
              s(:str, ".new"))),
          s(:send,
            s(:const, nil, :FileUtils), :mkdir_p,
            s(:send,
              s(:const, nil, :File), :dirname,
              s(:lvar, :output_filename))),
          s(:block,
            s(:send,
              s(:const, nil, :File), :open,
              s(:lvar, :new_filename),
              s(:str, "wb")),
            s(:args,
              s(:arg, :f)),
            s(:send,
              s(:lvar, :f), :<<,
              s(:lvar, :result))),
          s(:send,
            s(:const, nil, :File), :rename,
            s(:lvar, :new_filename),
            s(:lvar, :output_filename)),
          s(:lvasgn, :tms,
            s(:send,
              s(:const, nil, :Process), :times)),
          s(:lvasgn, :elapsed,
            s(:send,
              s(:send,
                s(:const, nil, :Time), :now), :-,
              s(:lvar, :start_time))),
          s(:if,
            s(:const, nil, :VERBOSE_MODE),
            s(:send,
              s(:const, nil, :STDERR), :puts,
              s(:dstr,
                s(:str, "done.  ("),
                s(:begin,
                  s(:send,
                    s(:str, "%.2f"), :%,
                    s(:send,
                      s(:lvar, :tms), :utime))),
                s(:str, "user "),
                s(:begin,
                  s(:send,
                    s(:str, "%.2f"), :%,
                    s(:send,
                      s(:lvar, :tms), :stime))),
                s(:str, "system "),
                s(:begin,
                  s(:send,
                    s(:str, "%.2f"), :%,
                    s(:lvar, :elapsed))),
                s(:str, "elapsed)"))), nil)),
        s(:send, nil, :print,
          s(:lvar, :result)))), nil))
