s(:module,
  s(:const, nil, :Fiddle),
  s(:module,
    s(:const, nil, :CParser),
    s(:begin,
      s(:def, :parse_struct_signature,
        s(:args,
          s(:arg, :signature),
          s(:optarg, :tymap,
            s(:nil))),
        s(:begin,
          s(:if,
            s(:send,
              s(:lvar, :signature), :is_a?,
              s(:const, nil, :String)),
            s(:lvasgn, :signature,
              s(:send, nil, :split_arguments,
                s(:lvar, :signature),
                s(:regexp,
                  s(:str, "[,;]"),
                  s(:regopt)))), nil),
          s(:lvasgn, :mems,
            s(:array)),
          s(:lvasgn, :tys,
            s(:array)),
          s(:block,
            s(:send,
              s(:lvar, :signature), :each),
            s(:args,
              s(:arg, :msig)),
            s(:begin,
              s(:lvasgn, :msig,
                s(:send, nil, :compact,
                  s(:lvar, :msig))),
              s(:case,
                s(:lvar, :msig),
                s(:when,
                  s(:regexp,
                    s(:str, "^[\\w\\*\\s]+[\\*\\s](\\w+)$"),
                    s(:regopt)),
                  s(:begin,
                    s(:send,
                      s(:lvar, :mems), :push,
                      s(:nth_ref, 1)),
                    s(:send,
                      s(:lvar, :tys), :push,
                      s(:send, nil, :parse_ctype,
                        s(:lvar, :msig),
                        s(:lvar, :tymap))))),
                s(:when,
                  s(:regexp,
                    s(:str, "^[\\w\\*\\s]+\\(\\*(\\w+)\\)\\(.*?\\)$"),
                    s(:regopt)),
                  s(:begin,
                    s(:send,
                      s(:lvar, :mems), :push,
                      s(:nth_ref, 1)),
                    s(:send,
                      s(:lvar, :tys), :push,
                      s(:send, nil, :parse_ctype,
                        s(:lvar, :msig),
                        s(:lvar, :tymap))))),
                s(:when,
                  s(:regexp,
                    s(:str, "^([\\w\\*\\s]+[\\*\\s])(\\w+)\\[(\\d+)\\]$"),
                    s(:regopt)),
                  s(:begin,
                    s(:send,
                      s(:lvar, :mems), :push,
                      s(:nth_ref, 2)),
                    s(:send,
                      s(:lvar, :tys), :push,
                      s(:array,
                        s(:send, nil, :parse_ctype,
                          s(:send,
                            s(:nth_ref, 1), :strip),
                          s(:lvar, :tymap)),
                        s(:send,
                          s(:nth_ref, 3), :to_i))))),
                s(:when,
                  s(:regexp,
                    s(:str, "^([\\w\\*\\s]+)\\[(\\d+)\\](\\w+)$"),
                    s(:regopt)),
                  s(:begin,
                    s(:send,
                      s(:lvar, :mems), :push,
                      s(:nth_ref, 3)),
                    s(:send,
                      s(:lvar, :tys), :push,
                      s(:array,
                        s(:send, nil, :parse_ctype,
                          s(:send,
                            s(:nth_ref, 1), :strip),
                          s(:lvar, :tymap)),
                        s(:send,
                          s(:nth_ref, 2), :to_i))))),
                s(:send, nil, :raise,
                  s(:const, nil, :RuntimeError),
                  s(:dstr,
                    s(:str, "can't parse the struct member: "),
                    s(:begin,
                      s(:lvar, :msig))))))),
          s(:return,
            s(:lvar, :tys),
            s(:lvar, :mems)))),
      s(:def, :parse_signature,
        s(:args,
          s(:arg, :signature),
          s(:optarg, :tymap,
            s(:nil))),
        s(:begin,
          s(:or_asgn,
            s(:lvasgn, :tymap),
            s(:hash)),
          s(:case,
            s(:send, nil, :compact,
              s(:lvar, :signature)),
            s(:when,
              s(:regexp,
                s(:str, "^(?:[\\w\\*\\s]+)\\(\\*(\\w+)\\((.*?)\\)\\)(?:\\[\\w*\\]|\\(.*?\\));?$"),
                s(:regopt)),
              s(:begin,
                s(:masgn,
                  s(:mlhs,
                    s(:lvasgn, :func),
                    s(:lvasgn, :args)),
                  s(:array,
                    s(:nth_ref, 1),
                    s(:nth_ref, 2))),
                s(:return,
                  s(:array,
                    s(:lvar, :func),
                    s(:const, nil, :TYPE_VOIDP),
                    s(:block,
                      s(:send,
                        s(:send, nil, :split_arguments,
                          s(:lvar, :args)), :collect),
                      s(:args,
                        s(:arg, :arg)),
                      s(:send, nil, :parse_ctype,
                        s(:lvar, :arg),
                        s(:lvar, :tymap))))))),
            s(:when,
              s(:regexp,
                s(:str, "^([\\w\\*\\s]+[\\*\\s])(\\w+)\\((.*?)\\);?$"),
                s(:regopt)),
              s(:begin,
                s(:masgn,
                  s(:mlhs,
                    s(:lvasgn, :ret),
                    s(:lvasgn, :func),
                    s(:lvasgn, :args)),
                  s(:array,
                    s(:send,
                      s(:nth_ref, 1), :strip),
                    s(:nth_ref, 2),
                    s(:nth_ref, 3))),
                s(:return,
                  s(:array,
                    s(:lvar, :func),
                    s(:send, nil, :parse_ctype,
                      s(:lvar, :ret),
                      s(:lvar, :tymap)),
                    s(:block,
                      s(:send,
                        s(:send, nil, :split_arguments,
                          s(:lvar, :args)), :collect),
                      s(:args,
                        s(:arg, :arg)),
                      s(:send, nil, :parse_ctype,
                        s(:lvar, :arg),
                        s(:lvar, :tymap))))))),
            s(:send, nil, :raise,
              s(:const, nil, :RuntimeError),
              s(:dstr,
                s(:str, "can't parse the function prototype: "),
                s(:begin,
                  s(:lvar, :signature))))))),
      s(:def, :parse_ctype,
        s(:args,
          s(:arg, :ty),
          s(:optarg, :tymap,
            s(:nil))),
        s(:begin,
          s(:or_asgn,
            s(:lvasgn, :tymap),
            s(:hash)),
          s(:case,
            s(:lvar, :ty),
            s(:when,
              s(:const, nil, :Array),
              s(:return,
                s(:array,
                  s(:send, nil, :parse_ctype,
                    s(:send,
                      s(:lvar, :ty), :[],
                      s(:int, 0)),
                    s(:lvar, :tymap)),
                  s(:send,
                    s(:lvar, :ty), :[],
                    s(:int, 1))))),
            s(:when,
              s(:str, "void"),
              s(:return,
                s(:const, nil, :TYPE_VOID))),
            s(:when,
              s(:regexp,
                s(:str, "^(?:(?:signed\\s+)?long\\s+long(?:\\s+int\\s+)?|int64_t)(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:if,
                s(:begin,
                  s(:defined?,
                    s(:const, nil, :TYPE_LONG_LONG))),
                s(:return,
                  s(:const, nil, :TYPE_LONG_LONG)),
                s(:send, nil, :raise,
                  s(:const, nil, :RuntimeError),
                  s(:dstr,
                    s(:str, "unsupported type: "),
                    s(:begin,
                      s(:lvar, :ty)))))),
            s(:when,
              s(:regexp,
                s(:str, "^(?:unsigned\\s+long\\s+long(?:\\s+int\\s+)?|uint64_t)(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:if,
                s(:begin,
                  s(:defined?,
                    s(:const, nil, :TYPE_LONG_LONG))),
                s(:return,
                  s(:send,
                    s(:const, nil, :TYPE_LONG_LONG), :-@)),
                s(:send, nil, :raise,
                  s(:const, nil, :RuntimeError),
                  s(:dstr,
                    s(:str, "unsupported type: "),
                    s(:begin,
                      s(:lvar, :ty)))))),
            s(:when,
              s(:regexp,
                s(:str, "^(?:signed\\s+)?long(?:\\s+int\\s+)?(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:const, nil, :TYPE_LONG))),
            s(:when,
              s(:regexp,
                s(:str, "^unsigned\\s+long(?:\\s+int\\s+)?(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:send,
                  s(:const, nil, :TYPE_LONG), :-@))),
            s(:when,
              s(:regexp,
                s(:str, "^(?:signed\\s+)?int(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:const, nil, :TYPE_INT))),
            s(:when,
              s(:regexp,
                s(:str, "^(?:unsigned\\s+int|uint)(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:send,
                  s(:const, nil, :TYPE_INT), :-@))),
            s(:when,
              s(:regexp,
                s(:str, "^(?:signed\\s+)?short(?:\\s+int\\s+)?(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:const, nil, :TYPE_SHORT))),
            s(:when,
              s(:regexp,
                s(:str, "^unsigned\\s+short(?:\\s+int\\s+)?(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:send,
                  s(:const, nil, :TYPE_SHORT), :-@))),
            s(:when,
              s(:regexp,
                s(:str, "^(?:signed\\s+)?char(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:const, nil, :TYPE_CHAR))),
            s(:when,
              s(:regexp,
                s(:str, "^unsigned\\s+char(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:send,
                  s(:const, nil, :TYPE_CHAR), :-@))),
            s(:when,
              s(:regexp,
                s(:str, "^float(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:const, nil, :TYPE_FLOAT))),
            s(:when,
              s(:regexp,
                s(:str, "^double(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:const, nil, :TYPE_DOUBLE))),
            s(:when,
              s(:regexp,
                s(:str, "^size_t(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:const, nil, :TYPE_SIZE_T))),
            s(:when,
              s(:regexp,
                s(:str, "^ssize_t(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:const, nil, :TYPE_SSIZE_T))),
            s(:when,
              s(:regexp,
                s(:str, "^ptrdiff_t(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:const, nil, :TYPE_PTRDIFF_T))),
            s(:when,
              s(:regexp,
                s(:str, "^intptr_t(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:const, nil, :TYPE_INTPTR_T))),
            s(:when,
              s(:regexp,
                s(:str, "^uintptr_t(?:\\s+\\w+)?$"),
                s(:regopt)),
              s(:return,
                s(:const, nil, :TYPE_UINTPTR_T))),
            s(:when,
              s(:regexp,
                s(:str, "\\*"),
                s(:regopt)),
              s(:regexp,
                s(:str, "\\[[\\s\\d]*\\]"),
                s(:regopt)),
              s(:return,
                s(:const, nil, :TYPE_VOIDP))),
            s(:begin,
              s(:lvasgn, :ty,
                s(:send,
                  s(:send,
                    s(:lvar, :ty), :split,
                    s(:str, " "),
                    s(:int, 2)), :[],
                  s(:int, 0))),
              s(:if,
                s(:begin,
                  s(:send,
                    s(:lvar, :tymap), :[],
                    s(:lvar, :ty))),
                s(:return,
                  s(:send, nil, :parse_ctype,
                    s(:send,
                      s(:lvar, :tymap), :[],
                      s(:lvar, :ty)),
                    s(:lvar, :tymap))),
                s(:send, nil, :raise,
                  s(:const, nil, :DLError),
                  s(:dstr,
                    s(:str, "unknown type: "),
                    s(:begin,
                      s(:lvar, :ty))))))))),
      s(:send, nil, :private),
      s(:def, :split_arguments,
        s(:args,
          s(:arg, :arguments),
          s(:optarg, :sep,
            s(:str, ","))),
        s(:begin,
          s(:if,
            s(:send,
              s(:send,
                s(:lvar, :arguments), :strip), :==,
              s(:str, "void")),
            s(:return,
              s(:array)), nil),
          s(:block,
            s(:send,
              s(:send,
                s(:lvar, :arguments), :scan,
                s(:regexp,
                  s(:str, "([\\w\\*\\s]+\\(\\*\\w*\\)\\(.*?\\)|[\\w\\*\\s\\[\\]]+)(?:"),
                  s(:begin,
                    s(:lvar, :sep)),
                  s(:str, "\\s*|$)"),
                  s(:regopt))), :collect),
            s(:args,
              s(:arg, :m)),
            s(:send,
              s(:lvar, :m), :[],
              s(:int, 0))))),
      s(:def, :compact,
        s(:args,
          s(:arg, :signature)),
        s(:send,
          s(:send,
            s(:send,
              s(:lvar, :signature), :gsub,
              s(:regexp,
                s(:str, "\\s+"),
                s(:regopt)),
              s(:str, " ")), :gsub,
            s(:regexp,
              s(:str, "\\s*([\\(\\)\\[\\]\\*,;])\\s*"),
              s(:regopt)),
            s(:str, "\\1")), :strip)))))
