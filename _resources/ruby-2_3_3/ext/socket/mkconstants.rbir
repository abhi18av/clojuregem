s(:begin,
  s(:send, nil, :require,
    s(:str, "optparse")),
  s(:send, nil, :require,
    s(:str, "erb")),
  s(:lvasgn, :opt,
    s(:send,
      s(:const, nil, :OptionParser), :new)),
  s(:block,
    s(:send,
      s(:lvar, :opt), :def_option,
      s(:str, "-h"),
      s(:str, "help")),
    s(:args),
    s(:begin,
      s(:send, nil, :puts,
        s(:lvar, :opt)),
      s(:send, nil, :exit,
        s(:int, 0)))),
  s(:lvasgn, :opt_o,
    s(:nil)),
  s(:block,
    s(:send,
      s(:lvar, :opt), :def_option,
      s(:str, "-o FILE"),
      s(:str, "specify output file")),
    s(:args,
      s(:arg, :filename)),
    s(:lvasgn, :opt_o,
      s(:lvar, :filename))),
  s(:lvasgn, :opt_H,
    s(:nil)),
  s(:block,
    s(:send,
      s(:lvar, :opt), :def_option,
      s(:str, "-H FILE"),
      s(:str, "specify output header file")),
    s(:args,
      s(:arg, :filename)),
    s(:lvasgn, :opt_H,
      s(:lvar, :filename))),
  s(:casgn, nil, :C_ESC,
    s(:hash,
      s(:pair,
        s(:str, "\\"),
        s(:str, "\\\\")),
      s(:pair,
        s(:str, "\""),
        s(:str, "\\\"")),
      s(:pair,
        s(:str, "\n"),
        s(:str, "\\n")))),
  s(:block,
    s(:send,
      s(:int, 0), :upto,
      s(:int, 31)),
    s(:args,
      s(:arg, :ch)),
    s(:or_asgn,
      s(:send,
        s(:const, nil, :C_ESC), :[],
        s(:send,
          s(:array,
            s(:lvar, :ch)), :pack,
          s(:str, "C"))),
      s(:send,
        s(:str, "\\%03o"), :%,
        s(:lvar, :ch)))),
  s(:block,
    s(:send,
      s(:int, 127), :upto,
      s(:int, 255)),
    s(:args,
      s(:arg, :ch)),
    s(:send,
      s(:const, nil, :C_ESC), :[]=,
      s(:send,
        s(:array,
          s(:lvar, :ch)), :pack,
        s(:str, "C")),
      s(:send,
        s(:str, "\\%03o"), :%,
        s(:lvar, :ch)))),
  s(:casgn, nil, :C_ESC_PAT,
    s(:send,
      s(:const, nil, :Regexp), :union,
      s(:splat,
        s(:send,
          s(:const, nil, :C_ESC), :keys)))),
  s(:def, :c_str,
    s(:args,
      s(:arg, :str)),
    s(:send,
      s(:send,
        s(:str, "\""), :+,
        s(:block,
          s(:send,
            s(:lvar, :str), :gsub,
            s(:const, nil, :C_ESC_PAT)),
          s(:args,
            s(:arg, :s)),
          s(:send,
            s(:const, nil, :C_ESC), :[],
            s(:lvar, :s)))), :+,
      s(:str, "\""))),
  s(:send,
    s(:lvar, :opt), :parse!),
  s(:lvasgn, :h,
    s(:hash)),
  s(:casgn, nil, :COMMENTS,
    s(:block,
      s(:send,
        s(:const, nil, :Hash), :new),
      s(:args,
        s(:arg, :h),
        s(:arg, :name)),
      s(:send,
        s(:lvar, :h), :[]=,
        s(:lvar, :name),
        s(:lvar, :name)))),
  s(:block,
    s(:send,
      s(:const, nil, :DATA), :each_line),
    s(:args,
      s(:arg, :s)),
    s(:begin,
      s(:masgn,
        s(:mlhs,
          s(:lvasgn, :name),
          s(:lvasgn, :default_value),
          s(:lvasgn, :comment)),
        s(:send,
          s(:send,
            s(:lvar, :s), :chomp), :split,
          s(:regexp,
            s(:str, "\\s+"),
            s(:regopt)),
          s(:int, 3))),
      s(:if,
        s(:and,
          s(:lvar, :name),
          s(:send,
            s(:send,
              s(:lvar, :name), :[],
              s(:int, 0)), :!=,
            s(:str, "#"))), nil,
        s(:next)),
      s(:if,
        s(:send,
          s(:lvar, :default_value), :==,
          s(:str, "nil")),
        s(:lvasgn, :default_value,
          s(:nil)), nil),
      s(:if,
        s(:send,
          s(:lvar, :h), :has_key?,
          s(:lvar, :name)),
        s(:begin,
          s(:send, nil, :warn,
            s(:dstr,
              s(:begin,
                s(:gvar, :$.)),
              s(:str, ": warning: duplicate name: "),
              s(:begin,
                s(:lvar, :name)))),
          s(:next)), nil),
      s(:send,
        s(:lvar, :h), :[]=,
        s(:lvar, :name),
        s(:lvar, :default_value)),
      s(:send,
        s(:const, nil, :COMMENTS), :[]=,
        s(:lvar, :name),
        s(:lvar, :comment)))),
  s(:casgn, nil, :DEFS,
    s(:send,
      s(:lvar, :h), :to_a)),
  s(:def, :each_const,
    s(:args),
    s(:block,
      s(:send,
        s(:const, nil, :DEFS), :each),
      s(:args,
        s(:arg, :name),
        s(:arg, :default_value)),
      s(:begin,
        s(:lvasgn, :guard,
          s(:nil)),
        s(:if,
          s(:match_with_lvasgn,
            s(:regexp,
              s(:str, "\\A(AF_INET6|PF_INET6|IPV6_.*)\\z"),
              s(:regopt)),
            s(:lvar, :name)),
          s(:lvasgn, :guard,
            s(:str, "defined(INET6)")), nil),
        s(:yield,
          s(:lvar, :guard),
          s(:lvar, :name),
          s(:lvar, :default_value))))),
  s(:def, :each_name,
    s(:args,
      s(:arg, :pat)),
    s(:block,
      s(:send,
        s(:const, nil, :DEFS), :each),
      s(:args,
        s(:arg, :name),
        s(:arg, :default_value)),
      s(:begin,
        s(:if,
          s(:send,
            s(:lvar, :pat), :!~,
            s(:lvar, :name)),
          s(:next), nil),
        s(:yield,
          s(:lvar, :name))))),
  s(:send,
    s(:send,
      s(:const, nil, :ERB), :new,
      s(:dstr,
        s(:str, "% each_const {|guard, name, default_value|\n"),
        s(:str, "#if !defined(<%=name%>)\n"),
        s(:str, "# if defined(HAVE_CONST_<%=name.upcase%>)\n"),
        s(:str, "#  define <%=name%> <%=name%>\n"),
        s(:str, "%if default_value\n"),
        s(:str, "# else\n"),
        s(:str, "#  define <%=name%> <%=default_value%>\n"),
        s(:str, "%end\n"),
        s(:str, "# endif\n"),
        s(:str, "#endif\n"),
        s(:str, "% }\n")),
      s(:nil),
      s(:str, "%")), :def_method,
    s(:const, nil, :Object),
    s(:str, "gen_const_decls")),
  s(:send,
    s(:send,
      s(:const, nil, :ERB), :new,
      s(:dstr,
        s(:str, "#if defined(<%=name%>)\n"),
        s(:str, "    /* <%= COMMENTS[name] %> */\n"),
        s(:str, "    rb_define_const(rb_cSocket, <%=c_str name%>, INTEGER2NUM(<%=name%>));\n"),
        s(:str, "    /* <%= COMMENTS[name] %> */\n"),
        s(:str, "    rb_define_const(rb_mSockConst, <%=c_str name%>, INTEGER2NUM(<%=name%>));\n"),
        s(:str, "#endif\n")),
      s(:nil),
      s(:str, "%")), :def_method,
    s(:const, nil, :Object),
    s(:str, "gen_const_defs_in_guard(name, default_value)")),
  s(:send,
    s(:send,
      s(:const, nil, :ERB), :new,
      s(:dstr,
        s(:str, "% each_const {|guard, name, default_value|\n"),
        s(:str, "%   if guard\n"),
        s(:str, "#if <%=guard%>\n"),
        s(:str, "<%= gen_const_defs_in_guard(name, default_value).chomp %>\n"),
        s(:str, "#endif\n"),
        s(:str, "%   else\n"),
        s(:str, "<%= gen_const_defs_in_guard(name, default_value).chomp %>\n"),
        s(:str, "%   end\n"),
        s(:str, "% }\n")),
      s(:nil),
      s(:str, "%")), :def_method,
    s(:const, nil, :Object),
    s(:str, "gen_const_defs")),
  s(:def, :reverse_each_name,
    s(:args,
      s(:arg, :pat)),
    s(:block,
      s(:send,
        s(:const, nil, :DEFS), :reverse_each),
      s(:args,
        s(:arg, :name),
        s(:arg, :default_value)),
      s(:begin,
        s(:if,
          s(:send,
            s(:lvar, :pat), :!~,
            s(:lvar, :name)),
          s(:next), nil),
        s(:yield,
          s(:lvar, :name))))),
  s(:def, :each_names_with_len,
    s(:args,
      s(:arg, :pat),
      s(:optarg, :prefix_optional,
        s(:nil))),
    s(:begin,
      s(:lvasgn, :h,
        s(:hash)),
      s(:block,
        s(:send,
          s(:const, nil, :DEFS), :each),
        s(:args,
          s(:arg, :name),
          s(:arg, :default_value)),
        s(:begin,
          s(:if,
            s(:send,
              s(:lvar, :pat), :!~,
              s(:lvar, :name)),
            s(:next), nil),
          s(:send,
            s(:begin,
              s(:or_asgn,
                s(:send,
                  s(:lvar, :h), :[],
                  s(:send,
                    s(:lvar, :name), :length)),
                s(:array))), :<<,
            s(:array,
              s(:lvar, :name),
              s(:lvar, :name))))),
      s(:if,
        s(:lvar, :prefix_optional),
        s(:begin,
          s(:if,
            s(:send,
              s(:const, nil, :Regexp), :===,
              s(:lvar, :prefix_optional)),
            s(:lvasgn, :prefix_pat,
              s(:lvar, :prefix_optional)),
            s(:lvasgn, :prefix_pat,
              s(:regexp,
                s(:str, "\\A"),
                s(:begin,
                  s(:send,
                    s(:const, nil, :Regexp), :escape,
                    s(:lvar, :prefix_optional))),
                s(:regopt)))),
          s(:block,
            s(:send,
              s(:const, nil, :DEFS), :each),
            s(:args,
              s(:arg, :const),
              s(:arg, :default_value)),
            s(:begin,
              s(:if,
                s(:send,
                  s(:lvar, :pat), :!~,
                  s(:lvar, :const)),
                s(:next), nil),
              s(:if,
                s(:send,
                  s(:lvar, :prefix_pat), :!~,
                  s(:lvar, :const)),
                s(:next), nil),
              s(:lvasgn, :name,
                s(:back_ref, :$')),
              s(:send,
                s(:begin,
                  s(:or_asgn,
                    s(:send,
                      s(:lvar, :h), :[],
                      s(:send,
                        s(:lvar, :name), :length)),
                    s(:array))), :<<,
                s(:array,
                  s(:lvar, :name),
                  s(:lvar, :const)))))), nil),
      s(:lvasgn, :hh,
        s(:hash)),
      s(:block,
        s(:send,
          s(:lvar, :h), :each),
        s(:args,
          s(:arg, :len),
          s(:arg, :pairs)),
        s(:block,
          s(:send,
            s(:lvar, :pairs), :each),
          s(:args,
            s(:arg, :name),
            s(:arg, :const)),
          s(:begin,
            s(:if,
              s(:send,
                s(:lvar, :hh), :[],
                s(:lvar, :name)),
              s(:send, nil, :raise,
                s(:dstr,
                  s(:str, "name crash: "),
                  s(:begin,
                    s(:lvar, :name)))), nil),
            s(:send,
              s(:lvar, :hh), :[]=,
              s(:lvar, :name),
              s(:true))))),
      s(:block,
        s(:send,
          s(:send,
            s(:send,
              s(:lvar, :h), :keys), :sort), :each),
        s(:args,
          s(:arg, :len)),
        s(:yield,
          s(:send,
            s(:lvar, :h), :[],
            s(:lvar, :len)),
          s(:lvar, :len))))),
  s(:send,
    s(:send,
      s(:const, nil, :ERB), :new,
      s(:dstr,
        s(:str, "%if guard\n"),
        s(:str, "#ifdef <%=guard%>\n"),
        s(:str, "int <%=funcname%>(const char *str, long len, int *valp);\n"),
        s(:str, "#endif\n"),
        s(:str, "%else\n"),
        s(:str, "int <%=funcname%>(const char *str, long len, int *valp);\n"),
        s(:str, "%end\n")),
      s(:nil),
      s(:str, "%")), :def_method,
    s(:const, nil, :Object),
    s(:str, "gen_name_to_int_decl(funcname, pat, prefix_optional, guard=nil)")),
  s(:send,
    s(:send,
      s(:const, nil, :ERB), :new,
      s(:dstr,
        s(:str, "int\n"),
        s(:str, "<%=funcname%>(const char *str, long len, int *valp)\n"),
        s(:str, "{\n"),
        s(:str, "    switch (len) {\n"),
        s(:str, "%    each_names_with_len(pat, prefix_optional) {|pairs, len|\n"),
        s(:str, "      case <%=len%>:\n"),
        s(:str, "%      pairs.each {|name, const|\n"),
        s(:str, "#ifdef <%=const%>\n"),
        s(:str, "        if (memcmp(str, <%=c_str name%>, <%=len%>) == 0) { *valp = <%=const%>; return 0; }\n"),
        s(:str, "#endif\n"),
        s(:str, "%      }\n"),
        s(:str, "        return -1;\n"),
        s(:str, "\n"),
        s(:str, "%    }\n"),
        s(:str, "      default:\n"),
        s(:str, "        return -1;\n"),
        s(:str, "    }\n"),
        s(:str, "}\n")),
      s(:nil),
      s(:str, "%")), :def_method,
    s(:const, nil, :Object),
    s(:str, "gen_name_to_int_func_in_guard(funcname, pat, prefix_optional, guard=nil)")),
  s(:send,
    s(:send,
      s(:const, nil, :ERB), :new,
      s(:dstr,
        s(:str, "%if guard\n"),
        s(:str, "#ifdef <%=guard%>\n"),
        s(:str, "<%=gen_name_to_int_func_in_guard(funcname, pat, prefix_optional, guard)%>\n"),
        s(:str, "#endif\n"),
        s(:str, "%else\n"),
        s(:str, "<%=gen_name_to_int_func_in_guard(funcname, pat, prefix_optional, guard)%>\n"),
        s(:str, "%end\n")),
      s(:nil),
      s(:str, "%")), :def_method,
    s(:const, nil, :Object),
    s(:str, "gen_name_to_int_func(funcname, pat, prefix_optional, guard=nil)")),
  s(:casgn, nil, :NAME_TO_INT_DEFS,
    s(:array)),
  s(:def, :def_name_to_int,
    s(:args,
      s(:arg, :funcname),
      s(:arg, :pat),
      s(:arg, :prefix_optional),
      s(:optarg, :guard,
        s(:nil))),
    s(:begin,
      s(:lvasgn, :decl,
        s(:send, nil, :gen_name_to_int_decl,
          s(:lvar, :funcname),
          s(:lvar, :pat),
          s(:lvar, :prefix_optional),
          s(:lvar, :guard))),
      s(:lvasgn, :func,
        s(:send, nil, :gen_name_to_int_func,
          s(:lvar, :funcname),
          s(:lvar, :pat),
          s(:lvar, :prefix_optional),
          s(:lvar, :guard))),
      s(:send,
        s(:const, nil, :NAME_TO_INT_DEFS), :<<,
        s(:array,
          s(:lvar, :decl),
          s(:lvar, :func))))),
  s(:def, :reverse_each_name_with_prefix_optional,
    s(:args,
      s(:arg, :pat),
      s(:arg, :prefix_pat)),
    s(:begin,
      s(:block,
        s(:send, nil, :reverse_each_name,
          s(:lvar, :pat)),
        s(:args,
          s(:arg, :n)),
        s(:yield,
          s(:lvar, :n),
          s(:lvar, :n))),
      s(:if,
        s(:lvar, :prefix_pat),
        s(:block,
          s(:send, nil, :reverse_each_name,
            s(:lvar, :pat)),
          s(:args,
            s(:arg, :n)),
          s(:begin,
            s(:if,
              s(:send,
                s(:lvar, :prefix_pat), :!~,
                s(:lvar, :n)),
              s(:next), nil),
            s(:yield,
              s(:lvar, :n),
              s(:back_ref, :$')))), nil))),
  s(:send,
    s(:send,
      s(:const, nil, :ERB), :new,
      s(:dstr,
        s(:str, "    <%=hash_var%> = st_init_numtable();\n"),
        s(:str, "% reverse_each_name_with_prefix_optional(pat, prefix_pat) {|n,s|\n"),
        s(:str, "#ifdef <%=n%>\n"),
        s(:str, "    st_insert(<%=hash_var%>, (st_data_t)<%=n%>, (st_data_t)rb_intern2(<%=c_str s%>, <%=s.length%>));\n"),
        s(:str, "#endif\n"),
        s(:str, "% }\n")),
      s(:nil),
      s(:str, "%")), :def_method,
    s(:const, nil, :Object),
    s(:str, "gen_int_to_name_hash(hash_var, pat, prefix_pat)")),
  s(:send,
    s(:send,
      s(:const, nil, :ERB), :new,
      s(:dstr,
        s(:str, "ID\n"),
        s(:str, "<%=func_name%>(int val)\n"),
        s(:str, "{\n"),
        s(:str, "    st_data_t name;\n"),
        s(:str, "    if (st_lookup(<%=hash_var%>, (st_data_t)val, &name))\n"),
        s(:str, "        return (ID)name;\n"),
        s(:str, "    return 0;\n"),
        s(:str, "}\n")),
      s(:nil),
      s(:str, "%")), :def_method,
    s(:const, nil, :Object),
    s(:str, "gen_int_to_name_func(func_name, hash_var)")),
  s(:send,
    s(:send,
      s(:const, nil, :ERB), :new,
      s(:str, "ID <%=func_name%>(int val);\n"),
      s(:nil),
      s(:str, "%")), :def_method,
    s(:const, nil, :Object),
    s(:str, "gen_int_to_name_decl(func_name, hash_var)")),
  s(:casgn, nil, :INTERN_DEFS,
    s(:array)),
  s(:def, :def_intern,
    s(:args,
      s(:arg, :func_name),
      s(:arg, :pat),
      s(:optarg, :prefix_optional,
        s(:nil))),
    s(:begin,
      s(:lvasgn, :prefix_pat,
        s(:nil)),
      s(:if,
        s(:lvar, :prefix_optional),
        s(:if,
          s(:send,
            s(:const, nil, :Regexp), :===,
            s(:lvar, :prefix_optional)),
          s(:lvasgn, :prefix_pat,
            s(:lvar, :prefix_optional)),
          s(:lvasgn, :prefix_pat,
            s(:regexp,
              s(:str, "\\A"),
              s(:begin,
                s(:send,
                  s(:const, nil, :Regexp), :escape,
                  s(:lvar, :prefix_optional))),
              s(:regopt)))), nil),
      s(:lvasgn, :hash_var,
        s(:dstr,
          s(:begin,
            s(:lvar, :func_name)),
          s(:str, "_hash"))),
      s(:lvasgn, :vardef,
        s(:dstr,
          s(:str, "static st_table *"),
          s(:begin,
            s(:lvar, :hash_var)),
          s(:str, ";"))),
      s(:lvasgn, :gen_hash,
        s(:send, nil, :gen_int_to_name_hash,
          s(:lvar, :hash_var),
          s(:lvar, :pat),
          s(:lvar, :prefix_pat))),
      s(:lvasgn, :decl,
        s(:send, nil, :gen_int_to_name_decl,
          s(:lvar, :func_name),
          s(:lvar, :hash_var))),
      s(:lvasgn, :func,
        s(:send, nil, :gen_int_to_name_func,
          s(:lvar, :func_name),
          s(:lvar, :hash_var))),
      s(:send,
        s(:const, nil, :INTERN_DEFS), :<<,
        s(:array,
          s(:lvar, :vardef),
          s(:lvar, :gen_hash),
          s(:lvar, :decl),
          s(:lvar, :func))))),
  s(:send, nil, :def_name_to_int,
    s(:str, "rsock_family_to_int"),
    s(:regexp,
      s(:str, "\\A(AF_|PF_)"),
      s(:regopt)),
    s(:str, "AF_")),
  s(:send, nil, :def_name_to_int,
    s(:str, "rsock_socktype_to_int"),
    s(:regexp,
      s(:str, "\\ASOCK_"),
      s(:regopt)),
    s(:str, "SOCK_")),
  s(:send, nil, :def_name_to_int,
    s(:str, "rsock_ipproto_to_int"),
    s(:regexp,
      s(:str, "\\AIPPROTO_"),
      s(:regopt)),
    s(:str, "IPPROTO_")),
  s(:send, nil, :def_name_to_int,
    s(:str, "rsock_unknown_level_to_int"),
    s(:regexp,
      s(:str, "\\ASOL_SOCKET\\z"),
      s(:regopt)),
    s(:str, "SOL_")),
  s(:send, nil, :def_name_to_int,
    s(:str, "rsock_ip_level_to_int"),
    s(:regexp,
      s(:str, "\\A(SOL_SOCKET\\z|IPPROTO_)"),
      s(:regopt)),
    s(:regexp,
      s(:str, "\\A(SOL_|IPPROTO_)"),
      s(:regopt))),
  s(:send, nil, :def_name_to_int,
    s(:str, "rsock_so_optname_to_int"),
    s(:regexp,
      s(:str, "\\ASO_"),
      s(:regopt)),
    s(:str, "SO_")),
  s(:send, nil, :def_name_to_int,
    s(:str, "rsock_ip_optname_to_int"),
    s(:regexp,
      s(:str, "\\AIP_"),
      s(:regopt)),
    s(:str, "IP_")),
  s(:send, nil, :def_name_to_int,
    s(:str, "rsock_ipv6_optname_to_int"),
    s(:regexp,
      s(:str, "\\AIPV6_"),
      s(:regopt)),
    s(:str, "IPV6_"),
    s(:str, "IPPROTO_IPV6")),
  s(:send, nil, :def_name_to_int,
    s(:str, "rsock_tcp_optname_to_int"),
    s(:regexp,
      s(:str, "\\ATCP_"),
      s(:regopt)),
    s(:str, "TCP_")),
  s(:send, nil, :def_name_to_int,
    s(:str, "rsock_udp_optname_to_int"),
    s(:regexp,
      s(:str, "\\AUDP_"),
      s(:regopt)),
    s(:str, "UDP_")),
  s(:send, nil, :def_name_to_int,
    s(:str, "rsock_shutdown_how_to_int"),
    s(:regexp,
      s(:str, "\\ASHUT_"),
      s(:regopt)),
    s(:str, "SHUT_")),
  s(:send, nil, :def_name_to_int,
    s(:str, "rsock_scm_optname_to_int"),
    s(:regexp,
      s(:str, "\\ASCM_"),
      s(:regopt)),
    s(:str, "SCM_")),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_family"),
    s(:regexp,
      s(:str, "\\AAF_"),
      s(:regopt))),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_family_noprefix"),
    s(:regexp,
      s(:str, "\\AAF_"),
      s(:regopt)),
    s(:str, "AF_")),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_protocol_family"),
    s(:regexp,
      s(:str, "\\APF_"),
      s(:regopt))),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_socktype"),
    s(:regexp,
      s(:str, "\\ASOCK_"),
      s(:regopt))),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_ipproto"),
    s(:regexp,
      s(:str, "\\AIPPROTO_"),
      s(:regopt))),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_iplevel"),
    s(:regexp,
      s(:str, "\\A(SOL_SOCKET\\z|IPPROTO_)"),
      s(:regopt)),
    s(:regexp,
      s(:str, "\\A(SOL_|IPPROTO_)"),
      s(:regopt))),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_so_optname"),
    s(:regexp,
      s(:str, "\\ASO_"),
      s(:regopt)),
    s(:str, "SO_")),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_ip_optname"),
    s(:regexp,
      s(:str, "\\AIP_"),
      s(:regopt)),
    s(:str, "IP_")),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_ipv6_optname"),
    s(:regexp,
      s(:str, "\\AIPV6_"),
      s(:regopt)),
    s(:str, "IPV6_")),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_tcp_optname"),
    s(:regexp,
      s(:str, "\\ATCP_"),
      s(:regopt)),
    s(:str, "TCP_")),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_udp_optname"),
    s(:regexp,
      s(:str, "\\AUDP_"),
      s(:regopt)),
    s(:str, "UDP_")),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_scm_optname"),
    s(:regexp,
      s(:str, "\\ASCM_"),
      s(:regopt)),
    s(:str, "SCM_")),
  s(:send, nil, :def_intern,
    s(:str, "rsock_intern_local_optname"),
    s(:regexp,
      s(:str, "\\ALOCAL_"),
      s(:regopt)),
    s(:str, "LOCAL_")),
  s(:lvasgn, :result,
    s(:send,
      s(:send,
        s(:const, nil, :ERB), :new,
        s(:dstr,
          s(:str, "/* autogenerated file */\n"),
          s(:str, "\n"),
          s(:str, "<%= INTERN_DEFS.map {|vardef, gen_hash, decl, func| vardef }.join(\"\\n\") %>\n"),
          s(:str, "\n"),
          s(:str, "#ifdef HAVE_LONG_LONG\n"),
          s(:str, "#define INTEGER2NUM(n) \\\n"),
          s(:str, "    (FIXNUM_MAX < (n) ? ULL2NUM(n) : \\\n"),
          s(:str, "     FIXNUM_MIN > (LONG_LONG)(n) ? LL2NUM(n) : \\\n"),
          s(:str, "     LONG2FIX(n))\n"),
          s(:str, "#else\n"),
          s(:str, "#define INTEGER2NUM(n) \\\n"),
          s(:str, "    (FIXNUM_MAX < (n) ? ULONG2NUM(n) : \\\n"),
          s(:str, "     FIXNUM_MIN > (long)(n) ? LONG2NUM(n) : \\\n"),
          s(:str, "     LONG2FIX(n))\n"),
          s(:str, "#endif\n"),
          s(:str, "\n"),
          s(:str, "static void\n"),
          s(:str, "init_constants(void)\n"),
          s(:str, "{\n"),
          s(:str, "    /*\n"),
          s(:str, "     * Document-module: Socket::Constants\n"),
          s(:str, "     *\n"),
          s(:str, "     * Socket::Constants provides socket-related constants.  All possible\n"),
          s(:str, "     * socket constants are listed in the documentation but they may not all\n"),
          s(:str, "     * be present on your platform.\n"),
          s(:str, "     *\n"),
          s(:str, "     * If the underlying platform doesn't define a constant the corresponding\n"),
          s(:str, "     * Ruby constant is not defined.\n"),
          s(:str, "     *\n"),
          s(:str, "     */\n"),
          s(:str, "    rb_mSockConst = rb_define_module_under(rb_cSocket, \"Constants\");\n"),
          s(:str, "\n"),
          s(:str, "<%= gen_const_defs %>\n"),
          s(:str, "<%= INTERN_DEFS.map {|vardef, gen_hash, decl, func| gen_hash }.join(\"\\n\") %>\n"),
          s(:str, "}\n"),
          s(:str, "\n"),
          s(:str, "<%= NAME_TO_INT_DEFS.map {|decl, func| func }.join(\"\\n\") %>\n"),
          s(:str, "\n"),
          s(:str, "<%= INTERN_DEFS.map {|vardef, gen_hash, decl, func| func }.join(\"\\n\") %>\n"),
          s(:str, "\n")),
        s(:nil),
        s(:str, "%")), :result,
      s(:send, nil, :binding))),
  s(:lvasgn, :header_result,
    s(:send,
      s(:send,
        s(:const, nil, :ERB), :new,
        s(:dstr,
          s(:str, "/* autogenerated file */\n"),
          s(:str, "<%= gen_const_decls %>\n"),
          s(:str, "<%= NAME_TO_INT_DEFS.map {|decl, func| decl }.join(\"\\n\") %>\n"),
          s(:str, "<%= INTERN_DEFS.map {|vardef, gen_hash, decl, func| decl }.join(\"\\n\") %>\n")),
        s(:nil),
        s(:str, "%")), :result,
      s(:send, nil, :binding))),
  s(:if,
    s(:lvar, :opt_H),
    s(:block,
      s(:send,
        s(:const, nil, :File), :open,
        s(:lvar, :opt_H),
        s(:str, "w")),
      s(:args,
        s(:arg, :f)),
      s(:send,
        s(:lvar, :f), :<<,
        s(:lvar, :header_result))),
    s(:lvasgn, :result,
      s(:send,
        s(:lvar, :header_result), :+,
        s(:lvar, :result)))),
  s(:if,
    s(:lvar, :opt_o),
    s(:block,
      s(:send,
        s(:const, nil, :File), :open,
        s(:lvar, :opt_o),
        s(:str, "w")),
      s(:args,
        s(:arg, :f)),
      s(:send,
        s(:lvar, :f), :<<,
        s(:lvar, :result))),
    s(:send,
      s(:gvar, :$stdout), :<<,
      s(:lvar, :result))))
