s(:begin,
  s(:send, nil, :require,
    s(:str, "mkmf")),
  s(:casgn, nil, :AF_INET6_SOCKET_CREATION_TEST,
    s(:dstr,
      s(:str, "#include <sys/types.h>\n"),
      s(:str, "#ifndef _WIN32\n"),
      s(:str, "#include <sys/socket.h>\n"),
      s(:str, "#endif\n"),
      s(:str, "int\n"),
      s(:str, "main(void)\n"),
      s(:str, "{\n"),
      s(:str, "  socket(AF_INET6, SOCK_STREAM, 0);\n"),
      s(:str, "  return 0;\n"),
      s(:str, "}\n"))),
  s(:casgn, nil, :GETADDRINFO_GETNAMEINFO_TEST,
    s(:dstr,
      s(:str, "#include <stdlib.h>\n"),
      s(:str, "\n"),
      s(:str, "#ifndef EXIT_SUCCESS\n"),
      s(:str, "#define EXIT_SUCCESS 0\n"),
      s(:str, "#endif\n"),
      s(:str, "#ifndef EXIT_FAILURE\n"),
      s(:str, "#define EXIT_FAILURE 1\n"),
      s(:str, "#endif\n"),
      s(:str, "\n"),
      s(:str, "#ifndef AF_LOCAL\n"),
      s(:str, "#define AF_LOCAL AF_UNIX\n"),
      s(:str, "#endif\n"),
      s(:str, "\n"),
      s(:str, "int\n"),
      s(:str, "main(void)\n"),
      s(:str, "{\n"),
      s(:str, "  int passive, gaierr, inet4 = 0, inet6 = 0;\n"),
      s(:str, "  struct addrinfo hints, *ai, *aitop;\n"),
      s(:str, "  char straddr[INET6_ADDRSTRLEN], strport[16];\n"),
      s(:str, "#ifdef _WIN32\n"),
      s(:str, "  WSADATA retdata;\n"),
      s(:str, "\n"),
      s(:str, "  WSAStartup(MAKEWORD(2, 0), &retdata);\n"),
      s(:str, "#endif\n"),
      s(:str, "\n"),
      s(:str, "  for (passive = 0; passive <= 1; passive++) {\n"),
      s(:str, "    memset(&hints, 0, sizeof(hints));\n"),
      s(:str, "    hints.ai_family = AF_UNSPEC;\n"),
      s(:str, "    hints.ai_protocol = IPPROTO_TCP;\n"),
      s(:str, "    hints.ai_flags = passive ? AI_PASSIVE : 0;\n"),
      s(:str, "    hints.ai_socktype = SOCK_STREAM;\n"),
      s(:str, "    if ((gaierr = getaddrinfo(NULL, \"54321\", &hints, &aitop)) != 0) {\n"),
      s(:str, "      (void)gai_strerror(gaierr);\n"),
      s(:str, "      goto bad;\n"),
      s(:str, "    }\n"),
      s(:str, "    for (ai = aitop; ai; ai = ai->ai_next) {\n"),
      s(:str, "      if (ai->ai_family == AF_LOCAL) continue;\n"),
      s(:str, "      if (ai->ai_addr == NULL)\n"),
      s(:str, "        goto bad;\n"),
      s(:str, "#if defined(_AIX)\n"),
      s(:str, "      if (ai->ai_family == AF_INET6 && passive) {\n"),
      s(:str, "        inet6++;\n"),
      s(:str, "        continue;\n"),
      s(:str, "      }\n"),
      s(:str, "      ai->ai_addr->sa_len = ai->ai_addrlen;\n"),
      s(:str, "      ai->ai_addr->sa_family = ai->ai_family;\n"),
      s(:str, "#endif\n"),
      s(:str, "      if (ai->ai_addrlen == 0 ||\n"),
      s(:str, "          getnameinfo(ai->ai_addr, ai->ai_addrlen,\n"),
      s(:str, "                      straddr, sizeof(straddr), strport, sizeof(strport),\n"),
      s(:str, "                      NI_NUMERICHOST|NI_NUMERICSERV) != 0) {\n"),
      s(:str, "        goto bad;\n"),
      s(:str, "      }\n"),
      s(:str, "      if (strcmp(strport, \"54321\") != 0) {\n"),
      s(:str, "        goto bad;\n"),
      s(:str, "      }\n"),
      s(:str, "      switch (ai->ai_family) {\n"),
      s(:str, "      case AF_INET:\n"),
      s(:str, "        if (passive) {\n"),
      s(:str, "          if (strcmp(straddr, \"0.0.0.0\") != 0) {\n"),
      s(:str, "            goto bad;\n"),
      s(:str, "          }\n"),
      s(:str, "        } else {\n"),
      s(:str, "          if (strcmp(straddr, \"127.0.0.1\") != 0) {\n"),
      s(:str, "            goto bad;\n"),
      s(:str, "          }\n"),
      s(:str, "        }\n"),
      s(:str, "        inet4++;\n"),
      s(:str, "        break;\n"),
      s(:str, "      case AF_INET6:\n"),
      s(:str, "        if (passive) {\n"),
      s(:str, "          if (strcmp(straddr, \"::\") != 0) {\n"),
      s(:str, "            goto bad;\n"),
      s(:str, "          }\n"),
      s(:str, "        } else {\n"),
      s(:str, "          if (strcmp(straddr, \"::1\") != 0) {\n"),
      s(:str, "            goto bad;\n"),
      s(:str, "          }\n"),
      s(:str, "        }\n"),
      s(:str, "        inet6++;\n"),
      s(:str, "        break;\n"),
      s(:str, "      case AF_UNSPEC:\n"),
      s(:str, "        goto bad;\n"),
      s(:str, "        break;\n"),
      s(:str, "      default:\n"),
      s(:str, "        /* another family support? */\n"),
      s(:str, "        break;\n"),
      s(:str, "      }\n"),
      s(:str, "    }\n"),
      s(:str, "  }\n"),
      s(:str, "\n"),
      s(:str, "  if (!(inet4 == 0 || inet4 == 2))\n"),
      s(:str, "    goto bad;\n"),
      s(:str, "  if (!(inet6 == 0 || inet6 == 2))\n"),
      s(:str, "    goto bad;\n"),
      s(:str, "\n"),
      s(:str, "  if (aitop)\n"),
      s(:str, "    freeaddrinfo(aitop);\n"),
      s(:str, "  return EXIT_SUCCESS;\n"),
      s(:str, "\n"),
      s(:str, " bad:\n"),
      s(:str, "  if (aitop)\n"),
      s(:str, "    freeaddrinfo(aitop);\n"),
      s(:str, "  return EXIT_FAILURE;\n"),
      s(:str, "}\n"))),
  s(:casgn, nil, :RECVMSG_WITH_MSG_PEEK_ALLOCATE_FD_TEST,
    s(:dstr,
      s(:str, "#include <stdlib.h>\n"),
      s(:str, "#include <stdio.h>\n"),
      s(:str, "#include <string.h>\n"),
      s(:str, "#include <sys/types.h>\n"),
      s(:str, "#include <sys/stat.h>\n"),
      s(:str, "#include <sys/socket.h>\n"),
      s(:str, "#include <sys/un.h>\n"),
      s(:str, "#include <unistd.h>\n"),
      s(:str, "\n"),
      s(:str, "int main(int argc, char *argv[])\n"),
      s(:str, "{\n"),
      s(:str, "    int ps[2], sv[2];\n"),
      s(:str, "    int ret;\n"),
      s(:str, "    ssize_t ss;\n"),
      s(:str, "    int s_fd, r_fd;\n"),
      s(:str, "    struct msghdr s_msg, r_msg;\n"),
      s(:str, "    union {\n"),
      s(:str, "        struct cmsghdr hdr;\n"),
      s(:str, "        char dummy[CMSG_SPACE(sizeof(int))];\n"),
      s(:str, "    } s_cmsg, r_cmsg;\n"),
      s(:str, "    struct iovec s_iov, r_iov;\n"),
      s(:str, "    char s_buf[1], r_buf[1];\n"),
      s(:str, "    struct stat s_statbuf, r_statbuf;\n"),
      s(:str, "\n"),
      s(:str, "    ret = pipe(ps);\n"),
      s(:str, "    if (ret == -1) { perror(\"pipe\"); exit(EXIT_FAILURE); }\n"),
      s(:str, "\n"),
      s(:str, "    s_fd = ps[0];\n"),
      s(:str, "\n"),
      s(:str, "    ret = socketpair(AF_UNIX, SOCK_DGRAM, 0, sv);\n"),
      s(:str, "    if (ret == -1) { perror(\"socketpair\"); exit(EXIT_FAILURE); }\n"),
      s(:str, "\n"),
      s(:str, "    s_msg.msg_name = NULL;\n"),
      s(:str, "    s_msg.msg_namelen = 0;\n"),
      s(:str, "    s_msg.msg_iov = &s_iov;\n"),
      s(:str, "    s_msg.msg_iovlen = 1;\n"),
      s(:str, "    s_msg.msg_control = &s_cmsg;\n"),
      s(:str, "    s_msg.msg_controllen = CMSG_SPACE(sizeof(int));;\n"),
      s(:str, "    s_msg.msg_flags = 0;\n"),
      s(:str, "\n"),
      s(:str, "    s_iov.iov_base = &s_buf;\n"),
      s(:str, "    s_iov.iov_len = sizeof(s_buf);\n"),
      s(:str, "\n"),
      s(:str, "    s_buf[0] = 'a';\n"),
      s(:str, "\n"),
      s(:str, "    s_cmsg.hdr.cmsg_len = CMSG_LEN(sizeof(int));\n"),
      s(:str, "    s_cmsg.hdr.cmsg_level = SOL_SOCKET;\n"),
      s(:str, "    s_cmsg.hdr.cmsg_type = SCM_RIGHTS;\n"),
      s(:str, "    memcpy(CMSG_DATA(&s_cmsg.hdr), (char *)&s_fd, sizeof(int));\n"),
      s(:str, "\n"),
      s(:str, "    ss = sendmsg(sv[0], &s_msg, 0);\n"),
      s(:str, "    if (ss == -1) { perror(\"sendmsg\"); exit(EXIT_FAILURE); }\n"),
      s(:str, "\n"),
      s(:str, "    r_msg.msg_name = NULL;\n"),
      s(:str, "    r_msg.msg_namelen = 0;\n"),
      s(:str, "    r_msg.msg_iov = &r_iov;\n"),
      s(:str, "    r_msg.msg_iovlen = 1;\n"),
      s(:str, "    r_msg.msg_control = &r_cmsg;\n"),
      s(:str, "    r_msg.msg_controllen = CMSG_SPACE(sizeof(int));\n"),
      s(:str, "    r_msg.msg_flags = 0;\n"),
      s(:str, "\n"),
      s(:str, "    r_iov.iov_base = &r_buf;\n"),
      s(:str, "    r_iov.iov_len = sizeof(r_buf);\n"),
      s(:str, "\n"),
      s(:str, "    r_buf[0] = '0';\n"),
      s(:str, "\n"),
      s(:str, "    memset(&r_cmsg, 0xff, CMSG_SPACE(sizeof(int)));\n"),
      s(:str, "\n"),
      s(:str, "    ss = recvmsg(sv[1], &r_msg, MSG_PEEK);\n"),
      s(:str, "    if (ss == -1) { perror(\"recvmsg\"); exit(EXIT_FAILURE); }\n"),
      s(:str, "\n"),
      s(:str, "    if (ss != 1) {\n"),
      s(:str, "        fprintf(stderr, \"unexpected return value from recvmsg: %ld\\n\", (long)ss);\n"),
      s(:str, "        exit(EXIT_FAILURE);\n"),
      s(:str, "    }\n"),
      s(:str, "    if (r_buf[0] != 'a') {\n"),
      s(:str, "        fprintf(stderr, \"unexpected return data from recvmsg: 0x%02x\\n\", r_buf[0]);\n"),
      s(:str, "        exit(EXIT_FAILURE);\n"),
      s(:str, "    }\n"),
      s(:str, "\n"),
      s(:str, "    if (r_msg.msg_controllen < CMSG_LEN(sizeof(int))) {\n"),
      s(:str, "        fprintf(stderr, \"unexpected: r_msg.msg_controllen < CMSG_LEN(sizeof(int)) not hold: %ld\\n\",\n"),
      s(:str, "                (long)r_msg.msg_controllen);\n"),
      s(:str, "        exit(EXIT_FAILURE);\n"),
      s(:str, "    }\n"),
      s(:str, "    if (r_cmsg.hdr.cmsg_len < CMSG_LEN(sizeof(int))) {\n"),
      s(:str, "        fprintf(stderr, \"unexpected: r_cmsg.hdr.cmsg_len < CMSG_LEN(sizeof(int)) not hold: %ld\\n\",\n"),
      s(:str, "                (long)r_cmsg.hdr.cmsg_len);\n"),
      s(:str, "        exit(EXIT_FAILURE);\n"),
      s(:str, "    }\n"),
      s(:str, "    memcpy((char *)&r_fd, CMSG_DATA(&r_cmsg.hdr), sizeof(int));\n"),
      s(:str, "\n"),
      s(:str, "    if (r_fd < 0) {\n"),
      s(:str, "        fprintf(stderr, \"negative r_fd: %d\\n\", r_fd);\n"),
      s(:str, "        exit(EXIT_FAILURE);\n"),
      s(:str, "    }\n"),
      s(:str, "\n"),
      s(:str, "    if (r_fd == s_fd) {\n"),
      s(:str, "        fprintf(stderr, \"r_fd and s_fd is same: %d\\n\", r_fd);\n"),
      s(:str, "        exit(EXIT_FAILURE);\n"),
      s(:str, "    }\n"),
      s(:str, "\n"),
      s(:str, "    ret = fstat(s_fd, &s_statbuf);\n"),
      s(:str, "    if (ret == -1) { perror(\"fstat(s_fd)\"); exit(EXIT_FAILURE); }\n"),
      s(:str, "\n"),
      s(:str, "    ret = fstat(r_fd, &r_statbuf);\n"),
      s(:str, "    if (ret == -1) { perror(\"fstat(r_fd)\"); exit(EXIT_FAILURE); }\n"),
      s(:str, "\n"),
      s(:str, "    if (s_statbuf.st_dev != r_statbuf.st_dev ||\n"),
      s(:str, "        s_statbuf.st_ino != r_statbuf.st_ino) {\n"),
      s(:str, "        fprintf(stderr, \"dev/ino doesn't match: s_fd:%ld/%ld r_fd:%ld/%ld\\n\",\n"),
      s(:str, "                (long)s_statbuf.st_dev, (long)s_statbuf.st_ino,\n"),
      s(:str, "                (long)r_statbuf.st_dev, (long)r_statbuf.st_ino);\n"),
      s(:str, "        exit(EXIT_FAILURE);\n"),
      s(:str, "    }\n"),
      s(:str, "\n"),
      s(:str, "    return EXIT_SUCCESS;\n"),
      s(:str, "}\n"))),
  s(:def, :test_recvmsg_with_msg_peek_creates_fds,
    s(:args,
      s(:arg, :headers)),
    s(:begin,
      s(:case,
        s(:const, nil, :RUBY_PLATFORM),
        s(:when,
          s(:regexp,
            s(:str, "linux"),
            s(:regopt)),
          s(:lvasgn, :close_fds,
            s(:true))),
        s(:when,
          s(:regexp,
            s(:str, "bsd|darwin"),
            s(:regopt)),
          s(:lvasgn, :close_fds,
            s(:false))),
        s(:when,
          s(:regexp,
            s(:str, "cygwin"),
            s(:regopt)),
          s(:lvasgn, :close_fds,
            s(:false))),
        s(:lvasgn, :close_fds,
          s(:nil))),
      s(:if,
        s(:send,
          s(:const, nil, :CROSS_COMPILING), :!),
        s(:if,
          s(:block,
            s(:send, nil, :checking_for,
              s(:str, "recvmsg() with MSG_PEEK allocate file descriptors")),
            s(:args),
            s(:send, nil, :try_run,
              s(:send,
                s(:send, nil, :cpp_include,
                  s(:lvar, :headers)), :+,
                s(:const, nil, :RECVMSG_WITH_MSG_PEEK_ALLOCATE_FD_TEST)))),
          s(:begin,
            s(:if,
              s(:send,
                s(:lvar, :close_fds), :==,
                s(:false)),
              s(:send, nil, :warn,
                s(:dstr,
                  s(:str, "unexpected fd-passing recvmsg() with MSG_PEEK behavor on "),
                  s(:begin,
                    s(:const, nil, :RUBY_PLATFORM)),
                  s(:str, ": fd allocation unexpected."))),
              s(:if,
                s(:send,
                  s(:lvar, :close_fds), :==,
                  s(:nil)),
                s(:send, nil, :puts,
                  s(:dstr,
                    s(:str, "info: "),
                    s(:begin,
                      s(:const, nil, :RUBY_PLATFORM)),
                    s(:str, " recvmsg() with MSG_PEEK allocates fds on fd-passing."))), nil)),
            s(:lvasgn, :close_fds,
              s(:true))),
          s(:begin,
            s(:if,
              s(:send,
                s(:lvar, :close_fds), :==,
                s(:true)),
              s(:send, nil, :warn,
                s(:dstr,
                  s(:str, "unexpected fd-passing recvmsg() with MSG_PEEK behavor on "),
                  s(:begin,
                    s(:const, nil, :RUBY_PLATFORM)),
                  s(:str, ": fd allocation expected."))),
              s(:if,
                s(:send,
                  s(:lvar, :close_fds), :==,
                  s(:nil)),
                s(:send, nil, :puts,
                  s(:dstr,
                    s(:str, "info: "),
                    s(:begin,
                      s(:const, nil, :RUBY_PLATFORM)),
                    s(:str, ": recvmsg() with MSG_PEEK doesn't allocates fds on fd-passing."))), nil)),
            s(:lvasgn, :close_fds,
              s(:false)))), nil),
      s(:if,
        s(:send,
          s(:lvar, :close_fds), :==,
          s(:nil)),
        s(:send, nil, :abort,
          s(:dstr,
            s(:str, "Fatal: cannot test fd-passing recvmsg() with MSG_PEEK behavor\n"),
            s(:str, "because cross-compilation for "),
            s(:begin,
              s(:const, nil, :RUBY_PLATFORM)),
            s(:str, ".\n"),
            s(:str, "If recvmsg() with MSG_PEEK allocates fds on fd passing:\n"),
            s(:str, "--enable-close-fds-by-recvmsg-with-peek\n"),
            s(:str, "If recvmsg() with MSG_PEEK doesn't allocate fds on fd passing:\n"),
            s(:str, "--disable-close-fds-by-recvmsg-with-peek\n"))), nil),
      s(:lvar, :close_fds))),
  s(:send,
    s(:gvar, :$INCFLAGS), :<<,
    s(:str, " -I$(topdir) -I$(top_srcdir)")),
  s(:if,
    s(:match_with_lvasgn,
      s(:regexp,
        s(:str, "darwin"),
        s(:regopt)),
      s(:const, nil, :RUBY_PLATFORM)),
    s(:send,
      s(:gvar, :$CFLAGS), :<<,
      s(:str, " -D__APPLE_USE_RFC_3542")), nil),
  s(:lvasgn, :headers,
    s(:array)),
  s(:if,
    s(:or,
      s(:gvar, :$mswin),
      s(:gvar, :$mingw)), nil,
    s(:lvasgn, :headers,
      s(:array,
        s(:str, "sys/types.h"),
        s(:str, "netdb.h"),
        s(:str, "string.h"),
        s(:str, "sys/socket.h"),
        s(:str, "netinet/in.h")))),
  s(:block,
    s(:send,
      s(:array,
        s(:str, "sys/uio.h"),
        s(:str, "xti.h"),
        s(:str, "netinet/in_systm.h"),
        s(:str, "netinet/tcp.h"),
        s(:str, "netinet/tcp_fsm.h"),
        s(:str, "netinet/udp.h"),
        s(:str, "arpa/inet.h"),
        s(:str, "netpacket/packet.h"),
        s(:str, "net/ethernet.h"),
        s(:str, "sys/un.h"),
        s(:str, "ifaddrs.h"),
        s(:str, "sys/ioctl.h"),
        s(:str, "sys/sockio.h"),
        s(:str, "net/if.h"),
        s(:str, "sys/param.h"),
        s(:str, "sys/ucred.h"),
        s(:str, "ucred.h"),
        s(:str, "net/if_dl.h"),
        s(:str, "arpa/nameser.h"),
        s(:str, "resolv.h")), :each),
    s(:args,
      s(:arg, :h)),
    s(:if,
      s(:send, nil, :have_header,
        s(:lvar, :h),
        s(:lvar, :headers)),
      s(:send,
        s(:lvar, :headers), :<<,
        s(:lvar, :h)), nil)),
  s(:send, nil, :have_struct_member,
    s(:str, "struct sockaddr"),
    s(:str, "sa_len"),
    s(:lvar, :headers)),
  s(:send, nil, :have_struct_member,
    s(:str, "struct sockaddr_in"),
    s(:str, "sin_len"),
    s(:lvar, :headers)),
  s(:send, nil, :have_struct_member,
    s(:str, "struct sockaddr_in6"),
    s(:str, "sin6_len"),
    s(:lvar, :headers)),
  s(:if,
    s(:send, nil, :have_type,
      s(:str, "struct sockaddr_un"),
      s(:lvar, :headers)),
    s(:send, nil, :have_struct_member,
      s(:str, "struct sockaddr_un"),
      s(:str, "sun_len"),
      s(:lvar, :headers)), nil),
  s(:send, nil, :have_type,
    s(:str, "struct sockaddr_dl"),
    s(:lvar, :headers)),
  s(:send, nil, :have_type,
    s(:str, "struct sockaddr_storage"),
    s(:lvar, :headers)),
  s(:send, nil, :have_type,
    s(:str, "struct addrinfo"),
    s(:lvar, :headers)),
  s(:if,
    s(:send, nil, :have_type,
      s(:str, "socklen_t"),
      s(:lvar, :headers)),
    s(:if,
      s(:send, nil, :try_static_assert,
        s(:str, "sizeof(socklen_t) >= sizeof(long)"),
        s(:lvar, :headers)),
      s(:send,
        s(:gvar, :$defs), :<<,
        s(:str, "-DRSTRING_SOCKLEN=(socklen_t)RSTRING_LEN")), nil), nil),
  s(:and,
    s(:block,
      s(:send, nil, :have_type,
        s(:str, "struct in_pktinfo"),
        s(:lvar, :headers)),
      s(:args,
        s(:arg, :src)),
      s(:send,
        s(:send,
          s(:send,
            s(:send,
              s(:send,
                s(:lvar, :src), :sub,
                s(:regexp,
                  s(:str, "^/\\*top\\*/"),
                  s(:regopt)),
                s(:dstr,
                  s(:str, "\\&"),
                  s(:str, "\n#if defined(IPPROTO_IP) && defined(IP_PKTINFO)"))), :<<,
              s(:str, "#else\n")), :<<,
            s(:str, "#error\n")), :<<,
          s(:str, ">>>>>> no in_pktinfo <<<<<<\n")), :<<,
        s(:str, "#endif\n"))),
    s(:send, nil, :have_struct_member,
      s(:str, "struct in_pktinfo"),
      s(:str, "ipi_spec_dst"),
      s(:lvar, :headers))),
  s(:block,
    s(:send, nil, :have_type,
      s(:str, "struct in6_pktinfo"),
      s(:lvar, :headers)),
    s(:args,
      s(:arg, :src)),
    s(:send,
      s(:send,
        s(:send,
          s(:send,
            s(:send,
              s(:lvar, :src), :sub,
              s(:regexp,
                s(:str, "^/\\*top\\*/"),
                s(:regopt)),
              s(:dstr,
                s(:str, "\\&"),
                s(:str, "\n#if defined(IPPROTO_IPV6) && defined(IPV6_PKTINFO)"))), :<<,
            s(:str, "#else\n")), :<<,
          s(:str, "#error\n")), :<<,
        s(:str, ">>>>>> no in6_pktinfo <<<<<<\n")), :<<,
      s(:str, "#endif\n"))),
  s(:send, nil, :have_type,
    s(:str, "struct sockcred"),
    s(:lvar, :headers)),
  s(:send, nil, :have_type,
    s(:str, "struct cmsgcred"),
    s(:lvar, :headers)),
  s(:send, nil, :have_type,
    s(:str, "struct ip_mreq"),
    s(:lvar, :headers)),
  s(:send, nil, :have_type,
    s(:str, "struct ip_mreqn"),
    s(:lvar, :headers)),
  s(:send, nil, :have_type,
    s(:str, "struct ipv6_mreq"),
    s(:lvar, :headers)),
  s(:lvasgn, :have_msg_control,
    s(:nil)),
  s(:if,
    s(:or,
      s(:gvar, :$mswin),
      s(:gvar, :$mingw)), nil,
    s(:lvasgn, :have_msg_control,
      s(:send, nil, :have_struct_member,
        s(:str, "struct msghdr"),
        s(:str, "msg_control"),
        s(:lvar, :headers)))),
  s(:send, nil, :have_struct_member,
    s(:str, "struct msghdr"),
    s(:str, "msg_accrights"),
    s(:lvar, :headers)),
  s(:if,
    s(:send, nil, :have_type,
      s(:str, "struct tcp_info"),
      s(:lvar, :headers)),
    s(:begin,
      s(:send, nil, :have_const,
        s(:str, "TCP_ESTABLISHED"),
        s(:lvar, :headers)),
      s(:send, nil, :have_const,
        s(:str, "TCP_SYN_SENT"),
        s(:lvar, :headers)),
      s(:send, nil, :have_const,
        s(:str, "TCP_SYN_RECV"),
        s(:lvar, :headers)),
      s(:send, nil, :have_const,
        s(:str, "TCP_FIN_WAIT1"),
        s(:lvar, :headers)),
      s(:send, nil, :have_const,
        s(:str, "TCP_FIN_WAIT2"),
        s(:lvar, :headers)),
      s(:send, nil, :have_const,
        s(:str, "TCP_TIME_WAIT"),
        s(:lvar, :headers)),
      s(:send, nil, :have_const,
        s(:str, "TCP_CLOSE"),
        s(:lvar, :headers)),
      s(:send, nil, :have_const,
        s(:str, "TCP_CLOSE_WAIT"),
        s(:lvar, :headers)),
      s(:send, nil, :have_const,
        s(:str, "TCP_LAST_ACK"),
        s(:lvar, :headers)),
      s(:send, nil, :have_const,
        s(:str, "TCP_LISTEN"),
        s(:lvar, :headers)),
      s(:send, nil, :have_const,
        s(:str, "TCP_CLOSING"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_state"),
        s(:lvar, :headers)),
      s(:if,
        s(:send,
          s(:regexp,
            s(:str, "solaris"),
            s(:regopt)), :!~,
          s(:const, nil, :RUBY_PLATFORM)),
        s(:send, nil, :have_struct_member,
          s(:str, "struct tcp_info"),
          s(:str, "tcpi_ca_state"),
          s(:lvar, :headers)), nil),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_retransmits"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_probes"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_backoff"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_options"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_snd_wscale"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_rcv_wscale"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_rto"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_ato"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_snd_mss"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_rcv_mss"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_unacked"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_sacked"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_lost"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_retrans"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_fackets"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_last_data_sent"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_last_ack_sent"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_last_data_recv"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_last_ack_recv"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_pmtu"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_rcv_ssthresh"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_rtt"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_rttvar"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_snd_ssthresh"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_snd_cwnd"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_advmss"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_reordering"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_rcv_rtt"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_rcv_space"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_total_retrans"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_snd_wnd"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_snd_bwnd"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_snd_nxt"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_rcv_nxt"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_toe_tid"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_snd_rexmitpack"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_rcv_ooopack"),
        s(:lvar, :headers)),
      s(:send, nil, :have_struct_member,
        s(:str, "struct tcp_info"),
        s(:str, "tcpi_snd_zerowin"),
        s(:lvar, :headers))), nil),
  s(:case,
    s(:const, nil, :RUBY_PLATFORM),
    s(:when,
      s(:regexp,
        s(:str, "mswin(32|64)|mingw"),
        s(:regopt)),
      s(:begin,
        s(:lvasgn, :test_func,
          s(:str, "WSACleanup")),
        s(:send, nil, :have_library,
          s(:str, "ws2_32"),
          s(:str, "WSACleanup"),
          s(:lvar, :headers)))),
    s(:when,
      s(:regexp,
        s(:str, "cygwin"),
        s(:regopt)),
      s(:lvasgn, :test_func,
        s(:str, "socket(0,0,0)"))),
    s(:when,
      s(:regexp,
        s(:str, "haiku"),
        s(:regopt)),
      s(:begin,
        s(:lvasgn, :test_func,
          s(:str, "socket(0,0,0)")),
        s(:send, nil, :have_library,
          s(:str, "network"),
          s(:str, "socket(0,0,0)"),
          s(:lvar, :headers)))),
    s(:begin,
      s(:lvasgn, :test_func,
        s(:str, "socket(0,0,0)")),
      s(:send, nil, :have_library,
        s(:str, "nsl"),
        s(:str, "t_open(\"\", 0, (struct t_info *)NULL)"),
        s(:lvar, :headers)),
      s(:send, nil, :have_library,
        s(:str, "socket"),
        s(:str, "socket(0,0,0)"),
        s(:lvar, :headers)))),
  s(:if,
    s(:send, nil, :have_func,
      s(:lvar, :test_func),
      s(:lvar, :headers)),
    s(:begin,
      s(:send, nil, :have_func,
        s(:str, "sendmsg(0, (struct msghdr *)NULL, 0)"),
        s(:lvar, :headers)),
      s(:lvasgn, :have_recvmsg,
        s(:send, nil, :have_func,
          s(:str, "recvmsg(0, (struct msghdr *)NULL, 0)"),
          s(:lvar, :headers))),
      s(:send, nil, :have_func,
        s(:str, "freehostent((struct hostent *)NULL)"),
        s(:lvar, :headers)),
      s(:send, nil, :have_func,
        s(:str, "freeaddrinfo((struct addrinfo *)NULL)"),
        s(:lvar, :headers)),
      s(:if,
        s(:and,
          s(:send,
            s(:regexp,
              s(:str, "haiku"),
              s(:regopt)), :!~,
            s(:const, nil, :RUBY_PLATFORM)),
          s(:send, nil, :have_func,
            s(:str, "gai_strerror(0)"),
            s(:lvar, :headers))),
        s(:if,
          s(:block,
            s(:send, nil, :checking_for,
              s(:str, "gai_strerror() returns const pointer")),
            s(:args),
            s(:send,
              s(:send, nil, :try_compile,
                s(:dstr,
                  s(:begin,
                    s(:send, nil, :cpp_include,
                      s(:lvar, :headers))),
                  s(:str, "\n"),
                  s(:str, "#include <stdlib.h>\n"),
                  s(:str, "void\n"),
                  s(:str, "conftest_gai_strerror_is_const()\n"),
                  s(:str, "{\n"),
                  s(:str, "    *gai_strerror(0) = 0;\n"),
                  s(:str, "}\n"))), :!)),
          s(:send,
            s(:gvar, :$defs), :<<,
            s(:str, "-DGAI_STRERROR_CONST")), nil), nil),
      s(:send, nil, :have_func,
        s(:str, "accept4"),
        s(:lvar, :headers)),
      s(:or,
        s(:send, nil, :have_func,
          s(:str, "inet_ntop(0, (const void *)0, (char *)0, 0)"),
          s(:lvar, :headers)),
        s(:send, nil, :have_func,
          s(:str, "inet_ntoa(*(struct in_addr *)NULL)"),
          s(:lvar, :headers))),
      s(:or,
        s(:send, nil, :have_func,
          s(:str, "inet_pton(0, \"\", (void *)0)"),
          s(:lvar, :headers)),
        s(:send, nil, :have_func,
          s(:str, "inet_aton(\"\", (struct in_addr *)0)"),
          s(:lvar, :headers))),
      s(:send, nil, :have_func,
        s(:str, "getservbyport(0, \"\")"),
        s(:lvar, :headers)),
      s(:send, nil, :have_func,
        s(:str, "getifaddrs((struct ifaddrs **)NULL)"),
        s(:lvar, :headers)),
      s(:send, nil, :have_func,
        s(:str, "getpeereid"),
        s(:lvar, :headers)),
      s(:send, nil, :have_func,
        s(:str, "getpeerucred(0, (ucred_t **)NULL)"),
        s(:lvar, :headers)),
      s(:lvasgn, :have_func_decl,
        s(:block,
          s(:send, nil, :proc),
          s(:args,
            s(:arg, :name),
            s(:arg, :headers)),
          s(:if,
            s(:send,
              s(:block,
                s(:send, nil, :checking_for,
                  s(:dstr,
                    s(:str, "declaration of "),
                    s(:begin,
                      s(:lvar, :name)),
                    s(:str, "()"))),
                s(:args),
                s(:send,
                  s(:block,
                    s(:send,
                      s(:array,
                        s(:str, "int"),
                        s(:str, "void")), :all?),
                    s(:args,
                      s(:arg, :ret)),
                    s(:send, nil, :try_compile,
                      s(:dstr,
                        s(:begin,
                          s(:send, nil, :cpp_include,
                            s(:lvar, :headers))),
                        s(:str, "\n"),
                        s(:begin,
                          s(:lvar, :ret)),
                        s(:str, " "),
                        s(:begin,
                          s(:lvar, :name)),
                        s(:str, "(void);\n")))), :!)), :!),
            s(:send,
              s(:gvar, :$defs), :<<,
              s(:dstr,
                s(:str, "-DNEED_"),
                s(:begin,
                  s(:send,
                    s(:lvar, :name), :tr_cpp)),
                s(:str, "_DECL"))), nil))),
      s(:if,
        s(:send, nil, :have_func,
          s(:str, "if_indextoname(0, \"\")"),
          s(:lvar, :headers)),
        s(:send,
          s(:lvar, :have_func_decl), :[],
          s(:str, "if_indextoname")), nil),
      s(:if,
        s(:send, nil, :have_func,
          s(:str, "if_nametoindex(\"\")"),
          s(:lvar, :headers)),
        s(:send,
          s(:lvar, :have_func_decl), :[],
          s(:str, "if_nametoindex")), nil),
      s(:send, nil, :have_func,
        s(:str, "hsterror"),
        s(:lvar, :headers)),
      s(:send, nil, :have_func,
        s(:str, "getipnodebyname(\"\", 0, 0, (int *)0)"),
        s(:lvar, :headers)),
      s(:send, nil, :have_func,
        s(:str, "gethostbyname2(\"\", 0)"),
        s(:lvar, :headers)),
      s(:send, nil, :have_func,
        s(:str, "socketpair(0, 0, 0, 0)"),
        s(:lvar, :headers)),
      s(:if,
        s(:send, nil, :have_func,
          s(:str, "gethostname((char *)0, 0)"),
          s(:lvar, :headers)), nil,
        s(:send, nil, :have_func,
          s(:str, "uname((struct utsname *)NULL)"),
          s(:lvar, :headers))),
      s(:lvasgn, :ipv6,
        s(:false)),
      s(:lvasgn, :default_ipv6,
        s(:send,
          s(:regexp,
            s(:str, "haiku"),
            s(:regopt)), :!~,
          s(:const, nil, :RUBY_PLATFORM))),
      s(:if,
        s(:send, nil, :enable_config,
          s(:str, "ipv6"),
          s(:lvar, :default_ipv6)),
        s(:if,
          s(:block,
            s(:send, nil, :checking_for,
              s(:str, "ipv6")),
            s(:args),
            s(:send, nil, :try_link,
              s(:const, nil, :AF_INET6_SOCKET_CREATION_TEST))),
          s(:begin,
            s(:send,
              s(:send,
                s(:gvar, :$defs), :<<,
                s(:str, "-DENABLE_IPV6")), :<<,
              s(:str, "-DINET6")),
            s(:lvasgn, :ipv6,
              s(:true))), nil), nil),
      s(:if,
        s(:lvar, :ipv6),
        s(:begin,
          s(:if,
            s(:gvar, :$mingw),
            s(:if,
              s(:send,
                s(:gvar, :$CPPFLAGS), :include?,
                s(:str, "_WIN32_WINNT")), nil,
              s(:send,
                s(:gvar, :$CPPFLAGS), :<<,
                s(:str, " -D_WIN32_WINNT=0x501"))), nil),
          s(:lvasgn, :ipv6lib,
            s(:nil)),
          s(:sclass,
            s(:begin,
              s(:lvasgn, :fmt,
                s(:str, "unknown"))),
            s(:def, :%,
              s(:args,
                s(:arg, :s)),
              s(:or,
                s(:lvar, :s),
                s(:self)))),
          s(:masgn,
            s(:mlhs,
              s(:lvasgn, :idirs),
              s(:lvasgn, :ldirs)),
            s(:send, nil, :dir_config,
              s(:str, "inet6"),
              s(:block,
                s(:send,
                  s(:array,
                    s(:str, "/usr/inet6"),
                    s(:str, "/usr/local/v6")), :find),
                s(:args,
                  s(:arg, :d)),
                s(:send,
                  s(:const, nil, :File), :directory?,
                  s(:lvar, :d))))),
          s(:or,
            s(:or,
              s(:block,
                s(:send, nil, :checking_for,
                  s(:str, "ipv6 type"),
                  s(:lvar, :fmt)),
                s(:args),
                s(:if,
                  s(:send, nil, :have_macro,
                    s(:str, "IPV6_INRIA_VERSION"),
                    s(:str, "netinet/in.h")),
                  s(:str, "inria"),
                  s(:if,
                    s(:send, nil, :have_macro,
                      s(:str, "__KAME__"),
                      s(:str, "netinet/in.h")),
                    s(:begin,
                      s(:send, nil, :have_library,
                        s(:lvasgn, :ipv6lib,
                          s(:str, "inet6"))),
                      s(:str, "kame")),
                    s(:if,
                      s(:send, nil, :have_macro,
                        s(:str, "_TOSHIBA_INET6"),
                        s(:str, "sys/param.h")),
                      s(:and,
                        s(:send, nil, :have_library,
                          s(:lvasgn, :ipv6lib,
                            s(:str, "inet6"))),
                        s(:str, "toshiba")),
                      s(:if,
                        s(:send, nil, :have_macro,
                          s(:str, "__V6D__"),
                          s(:str, "sys/v6config.h")),
                        s(:and,
                          s(:send, nil, :have_library,
                            s(:lvasgn, :ipv6lib,
                              s(:str, "v6"))),
                          s(:str, "v6d")),
                        s(:if,
                          s(:send, nil, :have_macro,
                            s(:str, "_ZETA_MINAMI_INET6"),
                            s(:str, "sys/param.h")),
                          s(:and,
                            s(:send, nil, :have_library,
                              s(:lvasgn, :ipv6lib,
                                s(:str, "inet6"))),
                            s(:str, "zeta")),
                          s(:if,
                            s(:send, nil, :have_library,
                              s(:str, "inet6")),
                            s(:str, "inet6"), nil))))))),
              s(:send,
                s(:lvar, :ipv6lib), :!)),
            s(:send, nil, :abort,
              s(:dstr,
                s(:str, "\n"),
                s(:str, "Fatal: no "),
                s(:begin,
                  s(:lvar, :ipv6lib)),
                s(:str, " library found.  cannot continue.\n"),
                s(:str, "You need to fetch lib"),
                s(:begin,
                  s(:lvar, :ipv6lib)),
                s(:str, ".a from appropriate\n"),
                s(:str, "ipv6 kit and compile beforehand.\n"))))), nil),
      s(:if,
        s(:and,
          s(:send,
            s(:send, nil, :have_macro,
              s(:str, "IPPROTO_IPV6"),
              s(:lvar, :headers)), :!),
          s(:send, nil, :have_const,
            s(:str, "IPPROTO_IPV6"),
            s(:lvar, :headers))),
        s(:block,
          s(:send,
            s(:block,
              s(:send,
                s(:send,
                  s(:send,
                    s(:send,
                      s(:const, nil, :IO), :read,
                      s(:send,
                        s(:const, nil, :File), :join,
                        s(:send,
                          s(:const, nil, :File), :dirname,
                          s(:str, "(string)")),
                        s(:str, "mkconstants.rb"))), :sub,
                    s(:regexp,
                      s(:str, "\\A.*^__END__$"),
                      s(:regopt, :m)),
                    s(:str, "")), :split,
                  s(:regexp,
                    s(:str, "\\r?\\n"),
                    s(:regopt))), :grep,
                s(:regexp,
                  s(:str, "\\AIPPROTO_\\w*"),
                  s(:regopt))),
              s(:args),
              s(:back_ref, :$&)), :each),
          s(:args,
            s(:arg, :name)),
          s(:if,
            s(:send,
              s(:gvar, :$defs), :include?,
              s(:dstr,
                s(:str, "-DHAVE_CONST_"),
                s(:begin,
                  s(:send,
                    s(:lvar, :name), :upcase)))), nil,
            s(:send, nil, :have_const,
              s(:lvar, :name),
              s(:lvar, :headers)))), nil),
      s(:if,
        s(:block,
          s(:send, nil, :enable_config,
            s(:str, "close-fds-by-recvmsg-with-peek")),
          s(:args),
          s(:and,
            s(:and,
              s(:and,
                s(:and,
                  s(:lvar, :have_msg_control),
                  s(:lvar, :have_recvmsg)),
                s(:send, nil, :have_const,
                  s(:str, "AF_UNIX"),
                  s(:lvar, :headers))),
              s(:send, nil, :have_const,
                s(:str, "SCM_RIGHTS"),
                s(:lvar, :headers))),
            s(:send, nil, :test_recvmsg_with_msg_peek_creates_fds,
              s(:lvar, :headers)))),
        s(:send,
          s(:gvar, :$defs), :<<,
          s(:str, "-DFD_PASSING_WORK_WITH_RECVMSG_MSG_PEEK")), nil),
      s(:case,
        s(:send, nil, :enable_config,
          s(:str, "wide-getaddrinfo")),
        s(:when,
          s(:true),
          s(:lvasgn, :getaddr_info_ok,
            s(:sym, :wide))),
        s(:when,
          s(:nil),
          s(:false),
          s(:begin,
            s(:lvasgn, :getaddr_info_ok,
              s(:begin,
                s(:if,
                  s(:send,
                    s(:lvar, :getaddr_info_ok), :nil?),
                  s(:sym, :wide), nil))),
            s(:if,
              s(:and,
                s(:send, nil, :have_func,
                  s(:str, "getnameinfo"),
                  s(:lvar, :headers)),
                s(:send, nil, :have_func,
                  s(:str, "getaddrinfo"),
                  s(:lvar, :headers))),
              s(:if,
                s(:or,
                  s(:const, nil, :CROSS_COMPILING),
                  s(:block,
                    s(:send, nil, :checking_for,
                      s(:str, "system getaddrinfo working")),
                    s(:args),
                    s(:send, nil, :try_run,
                      s(:send,
                        s(:send, nil, :cpp_include,
                          s(:lvar, :headers)), :+,
                        s(:const, nil, :GETADDRINFO_GETNAMEINFO_TEST))))),
                s(:lvasgn, :getaddr_info_ok,
                  s(:sym, :os)), nil), nil))),
        s(:send, nil, :raise,
          s(:str, "unexpected enable_config() value"))),
      s(:if,
        s(:and,
          s(:lvar, :ipv6),
          s(:send,
            s(:lvar, :getaddr_info_ok), :!)),
        s(:send, nil, :abort,
          s(:dstr,
            s(:str, "\n"),
            s(:str, "Fatal: --enable-ipv6 is specified, and your OS seems to support IPv6 feature.\n"),
            s(:str, "But your getaddrinfo() and getnameinfo() are appeared to be broken.  Sorry,\n"),
            s(:str, "you cannot compile IPv6 socket classes with broken these functions.\n"),
            s(:str, "You can try --enable-wide-getaddrinfo.\n"))), nil),
      s(:case,
        s(:send, nil, :with_config,
          s(:str, "lookup-order-hack"),
          s(:str, "UNSPEC")),
        s(:when,
          s(:str, "INET"),
          s(:send,
            s(:gvar, :$defs), :<<,
            s(:str, "-DLOOKUP_ORDER_HACK_INET"))),
        s(:when,
          s(:str, "INET6"),
          s(:send,
            s(:gvar, :$defs), :<<,
            s(:str, "-DLOOKUP_ORDER_HACK_INET6"))),
        s(:when,
          s(:str, "UNSPEC"), nil),
        s(:send, nil, :abort,
          s(:dstr,
            s(:str, "\n"),
            s(:str, "Fatal: invalid value for --with-lookup-order-hack (expected INET, INET6 or UNSPEC)\n")))),
      s(:gvasgn, :$objs,
        s(:array,
          s(:dstr,
            s(:str, "init."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "constants."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "basicsocket."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "socket."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "ipsocket."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "tcpsocket."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "tcpserver."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "sockssocket."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "udpsocket."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "unixsocket."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "unixserver."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "option."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "ancdata."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "raddrinfo."),
            s(:begin,
              s(:gvar, :$OBJEXT))),
          s(:dstr,
            s(:str, "ifaddr."),
            s(:begin,
              s(:gvar, :$OBJEXT))))),
      s(:if,
        s(:send,
          s(:lvar, :getaddr_info_ok), :==,
          s(:sym, :wide)),
        s(:begin,
          s(:if,
            s(:and,
              s(:send,
                s(:send, nil, :have_type,
                  s(:str, "struct in6_addr"),
                  s(:lvar, :headers)), :!),
              s(:send, nil, :have_type,
                s(:str, "struct in_addr6"),
                s(:lvar, :headers))),
            s(:begin,
              s(:send,
                s(:gvar, :$defs), :pop,
                s(:int, 2)),
              s(:send,
                s(:gvar, :$defs), :<<,
                s(:str, "-Din_addr6=in6_addr"))), nil),
          s(:if,
            s(:send, nil, :have_struct_member,
              s(:str, "struct in6_addr"),
              s(:str, "s6_addr8"),
              s(:lvar, :headers)),
            s(:send,
              s(:gvar, :$defs), :[]=,
              s(:int, -1),
              s(:str, "-Ds6_addr=s6_addr8")), nil),
          s(:if,
            s(:and,
              s(:send,
                s(:lvar, :ipv6), :==,
                s(:str, "kame")),
              s(:send, nil, :have_struct_member,
                s(:str, "struct in6_addr"),
                s(:str, "s6_addr32"),
                s(:lvar, :headers))),
            s(:send,
              s(:gvar, :$defs), :[]=,
              s(:int, -1),
              s(:str, "-DFAITH")), nil),
          s(:gvasgn, :$CPPFLAGS,
            s(:send,
              s(:str, "-I. "), :+,
              s(:gvar, :$CPPFLAGS))),
          s(:op_asgn,
            s(:gvasgn, :$objs), :+,
            s(:array,
              s(:dstr,
                s(:str, "getaddrinfo."),
                s(:begin,
                  s(:gvar, :$OBJEXT))))),
          s(:op_asgn,
            s(:gvasgn, :$objs), :+,
            s(:array,
              s(:dstr,
                s(:str, "getnameinfo."),
                s(:begin,
                  s(:gvar, :$OBJEXT))))),
          s(:send,
            s(:gvar, :$defs), :<<,
            s(:str, "-DGETADDRINFO_EMU"))), nil),
      s(:if,
        s(:and,
          s(:send,
            s(:gvar, :$defs), :include?,
            s(:str, "-DHAVE_CONST_IPPROTO_IPV6")),
          s(:send,
            s(:send, nil, :have_macro,
              s(:str, "IPPROTO_IPV6")), :!)),
        s(:send,
          s(:gvar, :$defs), :<<,
          s(:str, "-DIPPROTO_IPV6=IPPROTO_IPV6")), nil),
      s(:send,
        s(:send,
          s(:gvar, :$distcleanfiles), :<<,
          s(:str, "constants.h")), :<<,
        s(:str, "constdefs.*")),
      s(:if,
        s(:send, nil, :enable_config,
          s(:str, "socks"),
          s(:send,
            s(:const, nil, :ENV), :[],
            s(:str, "SOCKS_SERVER"))),
        s(:if,
          s(:send, nil, :have_library,
            s(:str, "socks5"),
            s(:str, "SOCKSinit")),
          s(:send,
            s(:send,
              s(:gvar, :$defs), :<<,
              s(:str, "-DSOCKS5")), :<<,
            s(:str, "-DSOCKS")),
          s(:if,
            s(:send, nil, :have_library,
              s(:str, "socks"),
              s(:str, "Rconnect")),
            s(:send,
              s(:gvar, :$defs), :<<,
              s(:str, "-DSOCKS")), nil)), nil),
      s(:lvasgn, :hdr,
        s(:str, "netinet6/in6.h")),
      s(:if,
        s(:and,
          s(:match_with_lvasgn,
            s(:regexp,
              s(:str, "darwin"),
              s(:regopt)),
            s(:const, nil, :RUBY_PLATFORM)),
          s(:send,
            s(:send, nil, :try_compile,
              s(:dstr,
                s(:str, "#include <netinet/in.h>\n"),
                s(:str, "int t(struct in6_addr *addr) {return IN6_IS_ADDR_UNSPECIFIED(addr);}\n")),
              s(:nil),
              s(:hash,
                s(:pair,
                  s(:sym, :werror),
                  s(:true)))), :!)),
        s(:begin,
          s(:send, nil, :print,
            s(:str, "fixing apple's netinet6/in6.rb ...")),
          s(:send,
            s(:gvar, :$stdout), :flush),
          s(:lvasgn, :in6,
            s(:send,
              s(:const, nil, :File), :read,
              s(:dstr,
                s(:str, "/usr/include/"),
                s(:begin,
                  s(:lvar, :hdr))))),
          s(:if,
            s(:block,
              s(:send,
                s(:lvar, :in6), :gsub!,
                s(:regexp,
                  s(:str, "\\*\\(const\\s+__uint32_t\\s+\\*\\)\\(const\\s+void\\s+\\*\\)\\(&(\\(\\w+\\))->s6_addr\\[(\\d+)\\]\\)"),
                  s(:regopt))),
              s(:args),
              s(:begin,
                s(:masgn,
                  s(:mlhs,
                    s(:lvasgn, :i),
                    s(:lvasgn, :r)),
                  s(:send,
                    s(:send,
                      s(:nth_ref, 2), :to_i), :divmod,
                    s(:int, 4))),
                s(:if,
                  s(:send,
                    s(:lvar, :r), :zero?),
                  s(:dstr,
                    s(:nth_ref, 1),
                    s(:str, "->__u6_addr.__u6_addr32["),
                    s(:begin,
                      s(:lvar, :i)),
                    s(:str, "]")),
                  s(:back_ref, :$&)))),
            s(:begin,
              s(:send,
                s(:const, nil, :FileUtils), :mkdir_p,
                s(:send,
                  s(:const, nil, :File), :dirname,
                  s(:lvar, :hdr))),
              s(:block,
                s(:send, nil, :open,
                  s(:lvar, :hdr),
                  s(:str, "w")),
                s(:args,
                  s(:arg, :f)),
                s(:send,
                  s(:lvar, :f), :write,
                  s(:lvar, :in6))),
              s(:send,
                s(:gvar, :$distcleanfiles), :<<,
                s(:lvar, :hdr)),
              s(:send,
                s(:gvar, :$distcleandirs), :<<,
                s(:send,
                  s(:const, nil, :File), :dirname,
                  s(:lvar, :hdr))),
              s(:send, nil, :puts,
                s(:str, "done"))),
            s(:send, nil, :puts,
              s(:str, "not needed")))), nil),
      s(:send, nil, :create_makefile,
        s(:str, "socket"))), nil))
