s(:begin,
  s(:send, nil, :require,
    s(:str, "optparse")),
  s(:send, nil, :require,
    s(:str, "erb")),
  s(:casgn, nil, :C_ESC,
    s(:hash,
      s(:pair,
        s(:str, "\\"),
        s(:str, "\\\\")),
      s(:pair,
        s(:str, "\""),
        s(:str, "\\\"")),
      s(:pair,
        s(:str, "\n"),
        s(:str, "\\n")))),
  s(:block,
    s(:send,
      s(:int, 0), :upto,
      s(:int, 31)),
    s(:args,
      s(:arg, :ch)),
    s(:or_asgn,
      s(:send,
        s(:const, nil, :C_ESC), :[],
        s(:send,
          s(:array,
            s(:lvar, :ch)), :pack,
          s(:str, "C"))),
      s(:send,
        s(:str, "\\%03o"), :%,
        s(:lvar, :ch)))),
  s(:block,
    s(:send,
      s(:int, 127), :upto,
      s(:int, 255)),
    s(:args,
      s(:arg, :ch)),
    s(:send,
      s(:const, nil, :C_ESC), :[]=,
      s(:send,
        s(:array,
          s(:lvar, :ch)), :pack,
        s(:str, "C")),
      s(:send,
        s(:str, "\\%03o"), :%,
        s(:lvar, :ch)))),
  s(:casgn, nil, :C_ESC_PAT,
    s(:send,
      s(:const, nil, :Regexp), :union,
      s(:splat,
        s(:send,
          s(:const, nil, :C_ESC), :keys)))),
  s(:def, :c_str,
    s(:args,
      s(:arg, :str)),
    s(:send,
      s(:send,
        s(:str, "\""), :+,
        s(:block,
          s(:send,
            s(:lvar, :str), :gsub,
            s(:const, nil, :C_ESC_PAT)),
          s(:args,
            s(:arg, :s)),
          s(:send,
            s(:const, nil, :C_ESC), :[],
            s(:lvar, :s)))), :+,
      s(:str, "\""))),
  s(:lvasgn, :opt,
    s(:send,
      s(:const, nil, :OptionParser), :new)),
  s(:block,
    s(:send,
      s(:lvar, :opt), :def_option,
      s(:str, "-h"),
      s(:str, "help")),
    s(:args),
    s(:begin,
      s(:send, nil, :puts,
        s(:lvar, :opt)),
      s(:send, nil, :exit,
        s(:int, 0)))),
  s(:lvasgn, :opt_o,
    s(:nil)),
  s(:block,
    s(:send,
      s(:lvar, :opt), :def_option,
      s(:str, "-o FILE"),
      s(:str, "specify output file")),
    s(:args,
      s(:arg, :filename)),
    s(:lvasgn, :opt_o,
      s(:lvar, :filename))),
  s(:lvasgn, :opt_H,
    s(:nil)),
  s(:block,
    s(:send,
      s(:lvar, :opt), :def_option,
      s(:str, "-H FILE"),
      s(:str, "specify output header file")),
    s(:args,
      s(:arg, :filename)),
    s(:lvasgn, :opt_H,
      s(:lvar, :filename))),
  s(:send,
    s(:lvar, :opt), :parse!),
  s(:lvasgn, :h,
    s(:hash)),
  s(:casgn, nil, :COMMENTS,
    s(:hash)),
  s(:block,
    s(:send,
      s(:const, nil, :DATA), :each_line),
    s(:args,
      s(:arg, :s)),
    s(:begin,
      s(:if,
        s(:match_with_lvasgn,
          s(:regexp,
            s(:str, "\\A\\s*(\\#|\\z)"),
            s(:regopt)),
          s(:lvar, :s)),
        s(:next), nil),
      s(:masgn,
        s(:mlhs,
          s(:lvasgn, :name),
          s(:lvasgn, :default_value),
          s(:lvasgn, :comment)),
        s(:send,
          s(:send,
            s(:lvar, :s), :chomp), :split,
          s(:regexp,
            s(:str, "\\s+"),
            s(:regopt)),
          s(:int, 3))),
      s(:if,
        s(:send,
          s(:lvar, :default_value), :==,
          s(:str, "nil")),
        s(:lvasgn, :default_value,
          s(:nil)), nil),
      s(:if,
        s(:send,
          s(:lvar, :h), :has_key?,
          s(:lvar, :name)),
        s(:begin,
          s(:send, nil, :warn,
            s(:dstr,
              s(:begin,
                s(:gvar, :$.)),
              s(:str, ": warning: duplicate name: "),
              s(:begin,
                s(:lvar, :name)))),
          s(:next)), nil),
      s(:send,
        s(:lvar, :h), :[]=,
        s(:lvar, :name),
        s(:lvar, :default_value)),
      s(:if,
        s(:lvar, :comment),
        s(:send,
          s(:const, nil, :COMMENTS), :[]=,
          s(:lvar, :name),
          s(:lvar, :comment)), nil))),
  s(:casgn, nil, :DEFS,
    s(:send,
      s(:lvar, :h), :to_a)),
  s(:def, :each_const,
    s(:args),
    s(:block,
      s(:send,
        s(:const, nil, :DEFS), :each),
      s(:args,
        s(:arg, :name),
        s(:arg, :default_value)),
      s(:yield,
        s(:lvar, :name),
        s(:lvar, :default_value)))),
  s(:def, :each_name,
    s(:args,
      s(:arg, :pat)),
    s(:block,
      s(:send,
        s(:const, nil, :DEFS), :each),
      s(:args,
        s(:arg, :name),
        s(:arg, :default_value)),
      s(:begin,
        s(:if,
          s(:send,
            s(:lvar, :pat), :!~,
            s(:lvar, :name)),
          s(:next), nil),
        s(:yield,
          s(:lvar, :name))))),
  s(:send,
    s(:send,
      s(:const, nil, :ERB), :new,
      s(:dstr,
        s(:str, "% each_const {|name, default_value|\n"),
        s(:str, "#if !defined(<%=name%>)\n"),
        s(:str, "# if defined(HAVE_CONST_<%=name.upcase%>)\n"),
        s(:str, "#  define <%=name%> <%=name%>\n"),
        s(:str, "%if default_value\n"),
        s(:str, "# else\n"),
        s(:str, "#  define <%=name%> <%=default_value%>\n"),
        s(:str, "%end\n"),
        s(:str, "# endif\n"),
        s(:str, "#endif\n"),
        s(:str, "% }\n")),
      s(:nil),
      s(:str, "%")), :def_method,
    s(:const, nil, :Object),
    s(:str, "gen_const_decls")),
  s(:send,
    s(:send,
      s(:const, nil, :ERB), :new,
      s(:dstr,
        s(:str, "% each_const {|name, default_value|\n"),
        s(:str, "#if defined(<%=name%>)\n"),
        s(:str, "%   if comment = COMMENTS[name]\n"),
        s(:str, "    /* <%=comment%> */\n"),
        s(:str, "%   end\n"),
        s(:str, "    rb_define_const(mod, <%=c_str name.sub(/\\A_*/, '')%>, INTEGER2NUM(<%=name%>));\n"),
        s(:str, "#endif\n"),
        s(:str, "% }\n")),
      s(:nil),
      s(:str, "%")), :def_method,
    s(:const, nil, :Object),
    s(:str, "gen_const_defs")),
  s(:lvasgn, :header_result,
    s(:send,
      s(:send,
        s(:const, nil, :ERB), :new,
        s(:dstr,
          s(:str, "/* autogenerated file */\n"),
          s(:str, "\n"),
          s(:str, "<%= gen_const_decls %>\n")),
        s(:nil),
        s(:str, "%")), :result,
      s(:send, nil, :binding))),
  s(:lvasgn, :result,
    s(:send,
      s(:send,
        s(:const, nil, :ERB), :new,
        s(:dstr,
          s(:str, "/* autogenerated file */\n"),
          s(:str, "\n"),
          s(:str, "#ifdef HAVE_LONG_LONG\n"),
          s(:str, "#define INTEGER2NUM(n) \\\n"),
          s(:str, "    (FIXNUM_MAX < (n) ? ULL2NUM(n) : \\\n"),
          s(:str, "     FIXNUM_MIN > (LONG_LONG)(n) ? LL2NUM(n) : \\\n"),
          s(:str, "     LONG2FIX(n))\n"),
          s(:str, "#else\n"),
          s(:str, "#define INTEGER2NUM(n) \\\n"),
          s(:str, "    (FIXNUM_MAX < (n) ? ULONG2NUM(n) : \\\n"),
          s(:str, "     FIXNUM_MIN > (long)(n) ? LONG2NUM(n) : \\\n"),
          s(:str, "     LONG2FIX(n))\n"),
          s(:str, "#endif\n"),
          s(:str, "\n"),
          s(:str, "static void\n"),
          s(:str, "init_constants(VALUE mod)\n"),
          s(:str, "{\n"),
          s(:str, "<%= gen_const_defs %>\n"),
          s(:str, "}\n")),
        s(:nil),
        s(:str, "%")), :result,
      s(:send, nil, :binding))),
  s(:if,
    s(:lvar, :opt_H),
    s(:block,
      s(:send,
        s(:const, nil, :File), :open,
        s(:lvar, :opt_H),
        s(:str, "w")),
      s(:args,
        s(:arg, :f)),
      s(:send,
        s(:lvar, :f), :<<,
        s(:lvar, :header_result))),
    s(:lvasgn, :result,
      s(:send,
        s(:lvar, :header_result), :+,
        s(:lvar, :result)))),
  s(:if,
    s(:lvar, :opt_o),
    s(:block,
      s(:send,
        s(:const, nil, :File), :open,
        s(:lvar, :opt_o),
        s(:str, "w")),
      s(:args,
        s(:arg, :f)),
      s(:send,
        s(:lvar, :f), :<<,
        s(:lvar, :result))),
    s(:send,
      s(:gvar, :$stdout), :<<,
      s(:lvar, :result))))
