s(:begin,
  s(:send, nil, :require,
    s(:str, "win32/registry")),
  s(:module,
    s(:const, nil, :Win32),
    s(:module,
      s(:const, nil, :Resolv),
      s(:begin,
        s(:casgn, nil, :API,
          s(:const,
            s(:const, nil, :Registry), :API)),
        s(:defs,
          s(:self), :get_hosts_path,
          s(:args),
          s(:begin,
            s(:lvasgn, :path,
              s(:send, nil, :get_hosts_dir)),
            s(:lvasgn, :path,
              s(:send,
                s(:const, nil, :File), :expand_path,
                s(:str, "hosts"),
                s(:lvar, :path))),
            s(:if,
              s(:send,
                s(:const, nil, :File), :exist?,
                s(:lvar, :path)),
              s(:lvar, :path),
              s(:nil)))),
        s(:defs,
          s(:self), :get_resolv_info,
          s(:args),
          s(:begin,
            s(:masgn,
              s(:mlhs,
                s(:lvasgn, :search),
                s(:lvasgn, :nameserver)),
              s(:send, nil, :get_info)),
            s(:if,
              s(:send,
                s(:lvar, :search), :empty?),
              s(:lvasgn, :search,
                s(:nil)),
              s(:begin,
                s(:send,
                  s(:lvar, :search), :delete,
                  s(:str, "")),
                s(:send,
                  s(:lvar, :search), :uniq!))),
            s(:if,
              s(:send,
                s(:lvar, :nameserver), :empty?),
              s(:lvasgn, :nameserver,
                s(:nil)),
              s(:begin,
                s(:send,
                  s(:lvar, :nameserver), :delete,
                  s(:str, "")),
                s(:send,
                  s(:lvar, :nameserver), :delete,
                  s(:str, "0.0.0.0")),
                s(:send,
                  s(:lvar, :nameserver), :uniq!))),
            s(:array,
              s(:lvar, :search),
              s(:lvar, :nameserver)))),
        s(:module,
          s(:const, nil, :Kernel32),
          s(:begin,
            s(:send, nil, :extend,
              s(:const, nil, :Importer)),
            s(:send, nil, :dlload,
              s(:str, "kernel32")))),
        s(:lvasgn, :getv,
          s(:send,
            s(:const, nil, :Kernel32), :extern,
            s(:str, "int GetVersionExA(void *)"),
            s(:sym, :stdcall))),
        s(:lvasgn, :info,
          s(:send,
            s(:send,
              s(:array,
                s(:int, 148),
                s(:int, 0),
                s(:int, 0),
                s(:int, 0),
                s(:int, 0)), :pack,
              s(:str, "V5")), :+,
            s(:send,
              s(:str, "\u0000"), :*,
              s(:int, 128)))),
        s(:send,
          s(:lvar, :getv), :call,
          s(:lvar, :info)),
        s(:if,
          s(:send,
            s(:send,
              s(:send,
                s(:lvar, :info), :unpack,
                s(:str, "V5")), :[],
              s(:int, 4)), :==,
            s(:int, 2)),
          s(:send, nil, :module_eval,
            s(:dstr,
              s(:str, "    TCPIP_NT = 'SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters'\n"),
              s(:str, "\n"),
              s(:str, "    class << self\n"),
              s(:str, "      private\n"),
              s(:str, "      def get_hosts_dir\n"),
              s(:str, "        Registry::HKEY_LOCAL_MACHINE.open(TCPIP_NT) do |reg|\n"),
              s(:str, "          reg.read_s_expand('DataBasePath')\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      def get_info\n"),
              s(:str, "        search = nil\n"),
              s(:str, "        nameserver = []\n"),
              s(:str, "        Registry::HKEY_LOCAL_MACHINE.open(TCPIP_NT) do |reg|\n"),
              s(:str, "          begin\n"),
              s(:str, "            slist = reg.read_s('SearchList')\n"),
              s(:str, "            search = slist.split(/,\\s*/) unless slist.empty?\n"),
              s(:str, "          rescue Registry::Error\n"),
              s(:str, "          end\n"),
              s(:str, "\n"),
              s(:str, "          if add_search = search.nil?\n"),
              s(:str, "            search = []\n"),
              s(:str, "            begin\n"),
              s(:str, "              nvdom = reg.read_s('NV Domain')\n"),
              s(:str, "              unless nvdom.empty?\n"),
              s(:str, "                @search = [ nvdom ]\n"),
              s(:str, "                if reg.read_i('UseDomainNameDevolution') != 0\n"),
              s(:str, "                  if /^\\w+\\./ =~ nvdom\n"),
              s(:str, "                    devo = $'\n"),
              s(:str, "                  end\n"),
              s(:str, "                end\n"),
              s(:str, "              end\n"),
              s(:str, "            rescue Registry::Error\n"),
              s(:str, "            end\n"),
              s(:str, "          end\n"),
              s(:str, "\n"),
              s(:str, "          reg.open('Interfaces') do |h|\n"),
              s(:str, "            h.each_key do |iface,|\n"),
              s(:str, "              h.open(iface) do |regif|\n"),
              s(:str, "                begin\n"),
              s(:str, "                  [ 'NameServer', 'DhcpNameServer' ].each do |key|\n"),
              s(:str, "                    begin\n"),
              s(:str, "                      ns = regif.read_s(key)\n"),
              s(:str, "                    rescue\n"),
              s(:str, "                    else\n"),
              s(:str, "                      unless ns.empty?\n"),
              s(:str, "                        nameserver.concat(ns.split(/[,\\s]\\s*/))\n"),
              s(:str, "                        break\n"),
              s(:str, "                      end\n"),
              s(:str, "                    end\n"),
              s(:str, "                  end\n"),
              s(:str, "                rescue Registry::Error\n"),
              s(:str, "                end\n"),
              s(:str, "\n"),
              s(:str, "                if add_search\n"),
              s(:str, "                  begin\n"),
              s(:str, "                    [ 'Domain', 'DhcpDomain' ].each do |key|\n"),
              s(:str, "                      dom = regif.read_s(key)\n"),
              s(:str, "                      unless dom.empty?\n"),
              s(:str, "                        search.concat(dom.split(/,\\s*/))\n"),
              s(:str, "                        break\n"),
              s(:str, "                      end\n"),
              s(:str, "                    end\n"),
              s(:str, "                  rescue Registry::Error\n"),
              s(:str, "                  end\n"),
              s(:str, "                end\n"),
              s(:str, "              end\n"),
              s(:str, "            end\n"),
              s(:str, "          end\n"),
              s(:str, "          search << devo if add_search and devo\n"),
              s(:str, "        end\n"),
              s(:str, "        [ search.uniq, nameserver.uniq ]\n"),
              s(:str, "      end\n"),
              s(:str, "    end\n")),
            s(:str, "(string)"),
            s(:send,
              s(:int, 48), :+,
              s(:int, 1))),
          s(:send, nil, :module_eval,
            s(:dstr,
              s(:str, "    TCPIP_9X = 'SYSTEM\\CurrentControlSet\\Services\\VxD\\MSTCP'\n"),
              s(:str, "    DHCP_9X = 'SYSTEM\\CurrentControlSet\\Services\\VxD\\DHCP'\n"),
              s(:str, "    WINDOWS = 'Software\\Microsoft\\Windows\\CurrentVersion'\n"),
              s(:str, "\n"),
              s(:str, "    class << self\n"),
              s(:str, "   #   private\n"),
              s(:str, "\n"),
              s(:str, "      def get_hosts_dir\n"),
              s(:str, "        Registry::HKEY_LOCAL_MACHINE.open(WINDOWS) do |reg|\n"),
              s(:str, "          reg.read_s_expand('SystemRoot')\n"),
              s(:str, "        end\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      def get_info\n"),
              s(:str, "        search = []\n"),
              s(:str, "        nameserver = []\n"),
              s(:str, "        begin\n"),
              s(:str, "          Registry::HKEY_LOCAL_MACHINE.open(TCPIP_9X) do |reg|\n"),
              s(:str, "            if reg.read_s(\"EnableDNS\") == \"1\"\n"),
              s(:str, "              domain = reg.read_s(\"Domain\")\n"),
              s(:str, "              ns = reg.read_s(\"NameServer\")\n"),
              s(:str, "              slist = reg.read_s(\"SearchList\")\n"),
              s(:str, "              search << domain unless domain.empty?\n"),
              s(:str, "              search.concat(slist.split(/,\\s*/))\n"),
              s(:str, "              nameserver.concat(ns.split(/[,\\s]\\s*/))\n"),
              s(:str, "            end\n"),
              s(:str, "          end\n"),
              s(:str, "        rescue Registry::Error\n"),
              s(:str, "        end\n"),
              s(:str, "\n"),
              s(:str, "        dhcpinfo = get_dhcpinfo\n"),
              s(:str, "        search.concat(dhcpinfo[0])\n"),
              s(:str, "        nameserver.concat(dhcpinfo[1])\n"),
              s(:str, "        [ search, nameserver ]\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      def get_dhcpinfo\n"),
              s(:str, "        macaddrs = {}\n"),
              s(:str, "        ipaddrs = {}\n"),
              s(:str, "        WsControl.get_iflist.each do |index, macaddr, *ipaddr|\n"),
              s(:str, "          macaddrs[macaddr] = 1\n"),
              s(:str, "          ipaddr.each { |ipaddr| ipaddrs[ipaddr] = 1 }\n"),
              s(:str, "        end\n"),
              s(:str, "        iflist = [ macaddrs, ipaddrs ]\n"),
              s(:str, "\n"),
              s(:str, "        search = []\n"),
              s(:str, "        nameserver = []\n"),
              s(:str, "        version = -1\n"),
              s(:str, "        Registry::HKEY_LOCAL_MACHINE.open(DHCP_9X) do |reg|\n"),
              s(:str, "          begin\n"),
              s(:str, "            version = API.unpackdw(reg.read_bin(\"Version\"))\n"),
              s(:str, "          rescue Registry::Error\n"),
              s(:str, "          end\n"),
              s(:str, "\n"),
              s(:str, "          reg.each_key do |key,|\n"),
              s(:str, "            catch(:not_used) do\n"),
              s(:str, "              reg.open(key) do |regdi|\n"),
              s(:str, "                dom, ns = get_dhcpinfo_key(version, regdi, iflist)\n"),
              s(:str, "                search << dom if dom\n"),
              s(:str, "                nameserver.concat(ns) if ns\n"),
              s(:str, "              end\n"),
              s(:str, "            end\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "        [ search, nameserver ]\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      def get_dhcpinfo_95(reg)\n"),
              s(:str, "        dhcp = reg.read_bin(\"DhcpInfo\")\n"),
              s(:str, "        [\n"),
              s(:str, "          API.unpackdw(dhcp[4..7]),\n"),
              s(:str, "          API.unpackdw(dhcp[8..11]),\n"),
              s(:str, "          1,\n"),
              s(:str, "          dhcp[45..50],\n"),
              s(:str, "          reg.read_bin(\"OptionInfo\"),\n"),
              s(:str, "        ]\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      def get_dhcpinfo_98(reg)\n"),
              s(:str, "        [\n"),
              s(:str, "          API.unpackdw(reg.read_bin(\"DhcpIPAddress\")),\n"),
              s(:str, "          API.unpackdw(reg.read_bin(\"DhcpSubnetMask\")),\n"),
              s(:str, "          API.unpackdw(reg.read_bin(\"HardwareType\")),\n"),
              s(:str, "          reg.read_bin(\"HardwareAddress\"),\n"),
              s(:str, "          reg.read_bin(\"OptionInfo\"),\n"),
              s(:str, "        ]\n"),
              s(:str, "      end\n"),
              s(:str, "\n"),
              s(:str, "      def get_dhcpinfo_key(version, reg, iflist)\n"),
              s(:str, "        info = case version\n"),
              s(:str, "               when 1\n"),
              s(:str, "                 get_dhcpinfo_95(reg)\n"),
              s(:str, "               when 2\n"),
              s(:str, "                 get_dhcpinfo_98(reg)\n"),
              s(:str, "               else\n"),
              s(:str, "                 begin\n"),
              s(:str, "                   get_dhcpinfo_98(reg)\n"),
              s(:str, "                 rescue Registry::Error\n"),
              s(:str, "                   get_dhcpinfo_95(reg)\n"),
              s(:str, "                 end\n"),
              s(:str, "               end\n"),
              s(:str, "        ipaddr, netmask, hwtype, macaddr, opt = info\n"),
              s(:str, "        throw :not_used unless\n"),
              s(:str, "          ipaddr and ipaddr != 0 and\n"),
              s(:str, "          netmask and netmask != 0 and\n"),
              s(:str, "          macaddr and macaddr.size == 6 and\n"),
              s(:str, "          hwtype == 1 and\n"),
              s(:str, "          iflist[0][macaddr] and iflist[1][ipaddr]\n"),
              s(:str, "\n"),
              s(:str, "        size = opt.size\n"),
              s(:str, "        idx = 0\n"),
              s(:str, "        while idx <= size\n"),
              s(:str, "          opttype = opt[idx]\n"),
              s(:str, "          optsize = opt[idx + 1]\n"),
              s(:str, "          optval  = opt[idx + 2, optsize]\n"),
              s(:str, "          case opttype\n"),
              s(:str, "          when 0xFF    ## term\n"),
              s(:str, "            break\n"),
              s(:str, "          when 0x0F    ## domain\n"),
              s(:str, "            domain = optval.chomp(\"\\0\")\n"),
              s(:str, "          when 0x06    ## dns\n"),
              s(:str, "            nameserver = optval.scan(/..../).collect { |addr|\n"),
              s(:str, "              \"%d.%d.%d.%d\" % addr.unpack('C4')\n"),
              s(:str, "            }\n"),
              s(:str, "          end\n"),
              s(:str, "          idx += optsize + 2\n"),
              s(:str, "        end\n"),
              s(:str, "        [ domain, nameserver ]\n"),
              s(:str, "      rescue Registry::Error\n"),
              s(:str, "        throw :not_used\n"),
              s(:str, "      end\n"),
              s(:str, "    end\n"),
              s(:str, "\n"),
              s(:str, "    module WsControl\n"),
              s(:str, "      module WSock32\n"),
              s(:str, "        extend Importer\n"),
              s(:str, "        dlload \"wsock32.dll\"\n"),
              s(:str, "      end\n"),
              s(:str, "      WsControl = WSock32.extern \"int WsControl(int, int, void *, void *, void *, void *\", :stdcall\n"),
              s(:str, "      WSAGetLastError = WSock32.extern \"int WSAGetLastError(void)\", :stdcall\n"),
              s(:str, "\n"),
              s(:str, "      MAX_TDI_ENTITIES = 512\n"),
              s(:str, "      IPPROTO_TCP = 6\n"),
              s(:str, "      WSCTL_TCP_QUERY_INFORMATION = 0\n"),
              s(:str, "      INFO_CLASS_GENERIC = 0x100\n"),
              s(:str, "      INFO_CLASS_PROTOCOL = 0x200\n"),
              s(:str, "      INFO_TYPE_PROVIDER = 0x100\n"),
              s(:str, "      ENTITY_LIST_ID = 0\n"),
              s(:str, "      GENERIC_ENTITY = 0\n"),
              s(:str, "      CL_NL_ENTITY = 0x301\n"),
              s(:str, "      IF_ENTITY = 0x200\n"),
              s(:str, "      ENTITY_TYPE_ID = 1\n"),
              s(:str, "      CL_NL_IP = 0x303\n"),
              s(:str, "      IF_MIB = 0x202\n"),
              s(:str, "      IF_MIB_STATS_ID = 1\n"),
              s(:str, "      IP_MIB_ADDRTABLE_ENTRY_ID = 0x102\n"),
              s(:str, "\n"),
              s(:str, "      def self.wsctl(tei_entity, tei_instance,\n"),
              s(:str, "                     toi_class, toi_type, toi_id,\n"),
              s(:str, "                     buffsize)\n"),
              s(:str, "        reqinfo = [\n"),
              s(:str, "                  ## TDIEntityID\n"),
              s(:str, "                    tei_entity, tei_instance,\n"),
              s(:str, "                  ## TDIObjectID\n"),
              s(:str, "                    toi_class, toi_type, toi_id,\n"),
              s(:str, "                  ## TCP_REQUEST_INFORMATION_EX\n"),
              s(:str, "                    \"\"\n"),
              s(:str, "                  ].pack('VVVVVa16')\n"),
              s(:str, "        reqsize = API.packdw(reqinfo.size)\n"),
              s(:str, "        buff = \"\\0\" * buffsize\n"),
              s(:str, "        buffsize = API.packdw(buffsize)\n"),
              s(:str, "        result = WsControl.call(\n"),
              s(:str, "                   IPPROTO_TCP,\n"),
              s(:str, "                   WSCTL_TCP_QUERY_INFORMATION,\n"),
              s(:str, "                   reqinfo, reqsize,\n"),
              s(:str, "                   buff, buffsize)\n"),
              s(:str, "        if result != 0\n"),
              s(:str, "          raise RuntimeError, \"WsControl failed.(\#{result})\"\n"),
              s(:str, "        end\n"),
              s(:str, "        [ buff, API.unpackdw(buffsize) ]\n"),
              s(:str, "      end\n"),
              s(:str, "      private_class_method :wsctl\n"),
              s(:str, "\n"),
              s(:str, "      def self.get_iflist\n"),
              s(:str, "        # Get TDI Entity List\n"),
              s(:str, "        entities, size =\n"),
              s(:str, "          wsctl(GENERIC_ENTITY, 0,\n"),
              s(:str, "                INFO_CLASS_GENERIC,\n"),
              s(:str, "                INFO_TYPE_PROVIDER,\n"),
              s(:str, "                ENTITY_LIST_ID,\n"),
              s(:str, "                MAX_TDI_ENTITIES * 8)  # sizeof(TDIEntityID)\n"),
              s(:str, "        entities = entities[0, size].\n"),
              s(:str, "                     scan(/.{8}/).\n"),
              s(:str, "                     collect { |e| e.unpack('VV') }\n"),
              s(:str, "\n"),
              s(:str, "        # Get MIB Interface List\n"),
              s(:str, "        iflist = []\n"),
              s(:str, "        ifcount = 0\n"),
              s(:str, "        entities.each do |entity, instance|\n"),
              s(:str, "          if( (entity & IF_ENTITY)>0 )\n"),
              s(:str, "            ifcount += 1\n"),
              s(:str, "            etype, = wsctl(entity, instance,\n"),
              s(:str, "                           INFO_CLASS_GENERIC,\n"),
              s(:str, "                           INFO_TYPE_PROVIDER,\n"),
              s(:str, "                           ENTITY_TYPE_ID,\n"),
              s(:str, "                           4)\n"),
              s(:str, "            if( (API.unpackdw(etype) & IF_MIB)==IF_MIB )\n"),
              s(:str, "              ifentry, = wsctl(entity, instance,\n"),
              s(:str, "                               INFO_CLASS_PROTOCOL,\n"),
              s(:str, "                               INFO_TYPE_PROVIDER,\n"),
              s(:str, "                               IF_MIB_STATS_ID,\n"),
              s(:str, "                               21 * 4 + 8 + 130)  # sizeof(IFEntry)\n"),
              s(:str, "              iflist << [\n"),
              s(:str, "                API.unpackdw(ifentry[0,4]),\n"),
              s(:str, "                ifentry[20, 6]\n"),
              s(:str, "              ]\n"),
              s(:str, "            end\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "\n"),
              s(:str, "        # Get IP Addresses\n"),
              s(:str, "        entities.each do |entity, instance|\n"),
              s(:str, "          if entity == CL_NL_ENTITY\n"),
              s(:str, "            etype, = wsctl(entity, instance,\n"),
              s(:str, "                           INFO_CLASS_GENERIC,\n"),
              s(:str, "                           INFO_TYPE_PROVIDER,\n"),
              s(:str, "                           ENTITY_TYPE_ID,\n"),
              s(:str, "                           4)\n"),
              s(:str, "            if API.unpackdw(etype) == CL_NL_IP\n"),
              s(:str, "              ipentries, = wsctl(entity, instance,\n"),
              s(:str, "                                 INFO_CLASS_PROTOCOL,\n"),
              s(:str, "                                 INFO_TYPE_PROVIDER,\n"),
              s(:str, "                                 IP_MIB_ADDRTABLE_ENTRY_ID,\n"),
              s(:str, "                                 24 * (ifcount+1))  # sizeof(IPAddrEntry)\n"),
              s(:str, "              ipentries.scan(/.{24}/) do |ipentry|\n"),
              s(:str, "                ipaddr, index = ipentry.unpack('VV')\n"),
              s(:str, "                if ifitem = iflist.assoc(index)\n"),
              s(:str, "                  ifitem << ipaddr\n"),
              s(:str, "                end\n"),
              s(:str, "              end\n"),
              s(:str, "            end\n"),
              s(:str, "          end\n"),
              s(:str, "        end\n"),
              s(:str, "        iflist\n"),
              s(:str, "      end\n"),
              s(:str, "    end\n")),
            s(:str, "(string)"),
            s(:send,
              s(:int, 128), :+,
              s(:int, 1))))))))
